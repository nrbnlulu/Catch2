{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"Readme/","title":"Readme","text":""},{"location":"Readme/#reference","title":"Reference","text":"<p>To get the most out of Catch2, start with the tutorial. Once you're up and running consider the following reference material.</p> <p>Writing tests: </p> <ul> <li>Assertion macros</li> <li>Matchers (asserting complex properties)</li> <li>Comparing floating point numbers</li> <li>Logging macros</li> <li>Test cases and sections</li> <li>Test fixtures</li> <li>Explicitly skipping, passing, and failing tests at runtime</li> <li>Reporters (output customization)</li> <li>Event Listeners</li> <li>Data Generators (value parameterized tests)</li> <li>Other macros</li> <li>Micro benchmarking</li> </ul> <p>Fine tuning: </p> <ul> <li>Supplying your own main()</li> <li>Compile-time configuration</li> <li>String Conversions</li> </ul> <p>Running: </p> <ul> <li>Command line</li> </ul> <p>Odds and ends: </p> <ul> <li>Frequently Asked Questions (FAQ)</li> <li>Best practices and other tips</li> <li>CMake integration</li> <li>Tooling integration (CI, test runners, other)</li> <li>Known limitations</li> </ul> <p>Other: </p> <ul> <li>Why Catch2?</li> <li>Migrating from v2 to v3</li> <li>Open Source Projects using Catch2</li> <li>Commercial Projects using Catch2</li> <li>Contributing</li> <li>Release Notes</li> <li>Deprecations and incoming changes</li> </ul>"},{"location":"assertions/","title":"Assertions","text":""},{"location":"assertions/#assertion-macros","title":"Assertion Macros","text":"<p>Contents Natural Expressions Floating point comparisons Exceptions Matcher expressions Thread Safety Expressions with commas</p> <p>Most test frameworks have a large collection of assertion macros to capture all possible conditional forms (<code>_EQUALS</code>, <code>_NOTEQUALS</code>, <code>_GREATER_THAN</code> etc).</p> <p>Catch is different. Because it decomposes natural C-style conditional expressions most of these forms are reduced to one or two that you will use all the time. That said there is a rich set of auxiliary macros as well. We'll describe all of these here.</p> <p>Most of these macros come in two forms:</p>"},{"location":"assertions/#natural-expressions","title":"Natural Expressions","text":"<p>The <code>REQUIRE</code> family of macros tests an expression and aborts the test case if it fails. The <code>CHECK</code> family are equivalent but execution continues in the same test case even if the assertion fails. This is useful if you have a series of essentially orthogonal assertions and it is useful to see all the results rather than stopping at the first failure.</p> <ul> <li>REQUIRE( expression ) and</li> <li>CHECK( expression )</li> </ul> <p>Evaluates the expression and records the result. If an exception is thrown, it is caught, reported, and counted as a failure. These are the macros you will use most of the time.</p> <p>Examples: <pre><code>CHECK( str == \"string value\" );\nCHECK( thisReturnsTrue() );\nREQUIRE( i == 42 );\n</code></pre></p> <p>Expressions prefixed with <code>!</code> cannot be decomposed. If you have a type that is convertible to bool and you want to assert that it evaluates to false, use the two forms below:</p> <ul> <li>REQUIRE_FALSE( expression ) and</li> <li>CHECK_FALSE( expression )</li> </ul> <p>Note that there is no reason to use these forms for plain bool variables, because there is no added value in decomposing them.</p> <p>Example: <pre><code>Status ret = someFunction();\nREQUIRE_FALSE(ret); // ret must evaluate to false, and Catch2 will print\n// out the value of ret if possibly\n</code></pre></p>"},{"location":"assertions/#other-limitations","title":"Other limitations","text":"<p>Note that expressions containing either of the binary logical operators, <code>&amp;&amp;</code> or <code>||</code>, cannot be decomposed and will not compile. The reason behind this is that it is impossible to overload <code>&amp;&amp;</code> and <code>||</code> in a way that keeps their short-circuiting semantics, and expression decomposition relies on overloaded operators to work.</p> <p>Simple example of an issue with overloading binary logical operators is a common pointer idiom, <code>p &amp;&amp; p-&gt;foo == 2</code>. Using the built-in <code>&amp;&amp;</code> operator, <code>p</code> is only dereferenced if it is not null. With overloaded <code>&amp;&amp;</code>, <code>p</code> is always dereferenced, thus causing a segfault if <code>p == nullptr</code>.</p> <p>If you want to test expression that contains <code>&amp;&amp;</code> or <code>||</code>, you have two options.</p> <p>1) Enclose it in parentheses. Parentheses force evaluation of the expression    before the expression decomposition can touch it, and thus it cannot    be used.</p> <p>2) Rewrite the expression. <code>REQUIRE(a == 1 &amp;&amp; b == 2)</code> can always be split    into <code>REQUIRE(a == 1); REQUIRE(b == 2);</code>. Alternatively, if this is a    common pattern in your tests, think about using Matchers.    instead. There is no simple rewrite rule for <code>||</code>, but I generally    believe that if you have <code>||</code> in your test expression, you should rethink    your tests.</p>"},{"location":"assertions/#floating-point-comparisons","title":"Floating point comparisons","text":"<p>Comparing floating point numbers is complex, and so it has its own documentation page.</p>"},{"location":"assertions/#exceptions","title":"Exceptions","text":"<ul> <li>REQUIRE_NOTHROW( expression ) and</li> <li>CHECK_NOTHROW( expression )</li> </ul> <p>Expects that no exception is thrown during evaluation of the expression.</p> <ul> <li>REQUIRE_THROWS( expression ) and</li> <li>CHECK_THROWS( expression )</li> </ul> <p>Expects that an exception (of any type) is be thrown during evaluation of the expression.</p> <ul> <li>REQUIRE_THROWS_AS( expression, exception type ) and</li> <li>CHECK_THROWS_AS( expression, exception type )</li> </ul> <p>Expects that an exception of the specified type is thrown during evaluation of the expression. Note that the exception type is extended with <code>const&amp;</code> and you should not include it yourself.</p> <ul> <li>REQUIRE_THROWS_WITH( expression, string or string matcher ) and</li> <li>CHECK_THROWS_WITH( expression, string or string matcher )</li> </ul> <p>Expects that an exception is thrown that, when converted to a string, matches the string or string matcher provided (see next section for Matchers).</p> <p>e.g. <pre><code>REQUIRE_THROWS_WITH( openThePodBayDoors(), Contains( \"afraid\" ) &amp;&amp; Contains( \"can't do that\" ) );\nREQUIRE_THROWS_WITH( dismantleHal(), \"My mind is going\" );\n</code></pre></p> <ul> <li>REQUIRE_THROWS_MATCHES( expression, exception type, matcher for given exception type ) and</li> <li>CHECK_THROWS_MATCHES( expression, exception type, matcher for given exception type )</li> </ul> <p>Expects that exception of exception type is thrown and it matches provided matcher (see the documentation for Matchers).</p> <p>Please note that the <code>THROW</code> family of assertions expects to be passed a single expression, not a statement or series of statements. If you want to check a more complicated sequence of operations, you can use a C++11 lambda function.</p> <pre><code>REQUIRE_NOTHROW([&amp;](){\nint i = 1;\nint j = 2;\nauto k = i + j;\nif (k == 3) {\nthrow 1;\n}\n}());\n</code></pre>"},{"location":"assertions/#matcher-expressions","title":"Matcher expressions","text":"<p>To support Matchers a slightly different form is used. Matchers have their own documentation.</p> <ul> <li>REQUIRE_THAT( lhs, matcher expression ) and</li> <li>CHECK_THAT( lhs, matcher expression )</li> </ul> <p>Matchers can be composed using <code>&amp;&amp;</code>, <code>||</code> and <code>!</code> operators.</p>"},{"location":"assertions/#thread-safety","title":"Thread Safety","text":"<p>Currently assertions in Catch are not thread safe. For more details, along with workarounds, see the section on the limitations page.</p>"},{"location":"assertions/#expressions-with-commas","title":"Expressions with commas","text":"<p>Because the preprocessor parses code using different rules than the compiler, multiple-argument assertions (e.g. <code>REQUIRE_THROWS_AS</code>) have problems with commas inside the provided expressions. As an example <code>REQUIRE_THROWS_AS(std::pair&lt;int, int&gt;(1, 2), std::invalid_argument);</code> will fail to compile, because the preprocessor sees 3 arguments provided, but the macro accepts only 2. There are two possible workarounds.</p> <p>1) Use typedef: <pre><code>using int_pair = std::pair&lt;int, int&gt;;\nREQUIRE_THROWS_AS(int_pair(1, 2), std::invalid_argument);\n</code></pre></p> <p>This solution is always applicable, but makes the meaning of the code less clear.</p> <p>2) Parenthesize the expression: <pre><code>TEST_CASE_METHOD((Fixture&lt;int, int&gt;), \"foo\", \"[bar]\") {\nSUCCEED();\n}\n</code></pre></p> <p>This solution is not always applicable, because it might require extra changes on the Catch's side to work.</p>"},{"location":"benchmarks/","title":"Benchmarks","text":""},{"location":"benchmarks/#authoring-benchmarks","title":"Authoring benchmarks","text":"<p>Introduced in Catch2 2.9.0.</p> <p>Writing benchmarks is not easy. Catch simplifies certain aspects but you'll always need to take care about various aspects. Understanding a few things about the way Catch runs your code will be very helpful when writing your benchmarks.</p> <p>First off, let's go over some terminology that will be used throughout this guide.</p> <ul> <li>User code: user code is the code that the user provides to be measured.</li> <li>Run: one run is one execution of the user code. Sometimes also referred   to as an iteration.</li> <li>Sample: one sample is one data point obtained by measuring the time it takes   to perform a certain number of runs. One sample can consist of more than one   run if the clock available does not have enough resolution to accurately   measure a single run. All samples for a given benchmark execution are obtained   with the same number of runs.</li> </ul>"},{"location":"benchmarks/#execution-procedure","title":"Execution procedure","text":"<p>Now I can explain how a benchmark is executed in Catch. There are three main steps, though the first does not need to be repeated for every benchmark.</p> <ol> <li> <p>Environmental probe: before any benchmarks can be executed, the clock's resolution is estimated. A few other environmental artifacts are also estimated at this point, like the cost of calling the clock function, but they almost never have any impact in the results.</p> </li> <li> <p>Estimation: the user code is executed a few times to obtain an estimate of the amount of runs that should be in each sample. This also has the potential effect of bringing relevant code and data into the caches before the actual measurement starts.</p> </li> <li> <p>Measurement: all the samples are collected sequentially by performing the number of runs estimated in the previous step for each sample.</p> </li> </ol> <p>This already gives us one important rule for writing benchmarks for Catch: the benchmarks must be repeatable. The user code will be executed several times, and the number of times it will be executed during the estimation step cannot be known beforehand since it depends on the time it takes to execute the code. User code that cannot be executed repeatedly will lead to bogus results or crashes.</p>"},{"location":"benchmarks/#benchmark-specification","title":"Benchmark specification","text":"<p>Benchmarks can be specified anywhere inside a Catch test case. There is a simple and a slightly more advanced version of the <code>BENCHMARK</code> macro.</p> <p>Let's have a look how a naive Fibonacci implementation could be benchmarked: <pre><code>std::uint64_t Fibonacci(std::uint64_t number) {\nreturn number &lt; 2 ? 1 : Fibonacci(number - 1) + Fibonacci(number - 2);\n}\n</code></pre> Now the most straight forward way to benchmark this function, is just adding a <code>BENCHMARK</code> macro to our test case: <pre><code>TEST_CASE(\"Fibonacci\") {\nCHECK(Fibonacci(0) == 1);\n// some more asserts..\nCHECK(Fibonacci(5) == 8);\n// some more asserts..\n// now let's benchmark:\nBENCHMARK(\"Fibonacci 20\") {\nreturn Fibonacci(20);\n};\nBENCHMARK(\"Fibonacci 25\") {\nreturn Fibonacci(25);\n};\nBENCHMARK(\"Fibonacci 30\") {\nreturn Fibonacci(30);\n};\nBENCHMARK(\"Fibonacci 35\") {\nreturn Fibonacci(35);\n};\n}\n</code></pre> There's a few things to note: - As <code>BENCHMARK</code> expands to a lambda expression it is necessary to add a semicolon after  the closing brace (as opposed to the first experimental version). - The <code>return</code> is a handy way to avoid the compiler optimizing away the benchmark code.</p> <p>Running this already runs the benchmarks and outputs something similar to: <pre><code>-------------------------------------------------------------------------------\nFibonacci\n-------------------------------------------------------------------------------\nC:\\path\\to\\Catch2\\Benchmark.tests.cpp(10)\n...............................................................................\nbenchmark name                                  samples       iterations    estimated\n                                                mean          low mean      high mean\n                                                std dev       low std dev   high std dev\n-------------------------------------------------------------------------------\nFibonacci 20                                            100       416439   83.2878 ms\n                                                       2 ns         2 ns         2 ns\n                                                       0 ns         0 ns         0 ns\n\nFibonacci 25                                            100       400776   80.1552 ms\n                                                       3 ns         3 ns         3 ns\n                                                       0 ns         0 ns         0 ns\n\nFibonacci 30                                            100       396873   79.3746 ms\n                                                      17 ns        17 ns        17 ns\n                                                       0 ns         0 ns         0 ns\n\nFibonacci 35                                            100       145169   87.1014 ms\n                                                     468 ns       464 ns       473 ns\n                                                      21 ns        15 ns        34 ns\n</code></pre></p>"},{"location":"benchmarks/#advanced-benchmarking","title":"Advanced benchmarking","text":"<p>The simplest use case shown above, takes no arguments and just runs the user code that needs to be measured. However, if using the <code>BENCHMARK_ADVANCED</code> macro and adding a <code>Catch::Benchmark::Chronometer</code> argument after the macro, some advanced features are available. The contents of the simple benchmarks are invoked once per run, while the blocks of the advanced benchmarks are invoked exactly twice: once during the estimation phase, and another time during the execution phase.</p> <pre><code>BENCHMARK(\"simple\"){ return long_computation(); };\nBENCHMARK_ADVANCED(\"advanced\")(Catch::Benchmark::Chronometer meter) {\nset_up();\nmeter.measure([] { return long_computation(); });\n};\n</code></pre> <p>These advanced benchmarks no longer consist entirely of user code to be measured. In these cases, the code to be measured is provided via the <code>Catch::Benchmark::Chronometer::measure</code> member function. This allows you to set up any kind of state that might be required for the benchmark but is not to be included in the measurements, like making a vector of random integers to feed to a sorting algorithm.</p> <p>A single call to <code>Catch::Benchmark::Chronometer::measure</code> performs the actual measurements by invoking the callable object passed in as many times as necessary. Anything that needs to be done outside the measurement can be done outside the call to <code>measure</code>.</p> <p>The callable object passed in to <code>measure</code> can optionally accept an <code>int</code> parameter.</p> <pre><code>meter.measure([](int i) { return long_computation(i); });\n</code></pre> <p>If it accepts an <code>int</code> parameter, the sequence number of each run will be passed in, starting with 0. This is useful if you want to measure some mutating code, for example. The number of runs can be known beforehand by calling <code>Catch::Benchmark::Chronometer::runs</code>; with this one can set up a different instance to be mutated by each run.</p> <pre><code>std::vector&lt;std::string&gt; v(meter.runs());\nstd::fill(v.begin(), v.end(), test_string());\nmeter.measure([&amp;v](int i) { in_place_escape(v[i]); });\n</code></pre> <p>Note that it is not possible to simply use the same instance for different runs and resetting it between each run since that would pollute the measurements with the resetting code.</p> <p>It is also possible to just provide an argument name to the simple <code>BENCHMARK</code> macro to get the same semantics as providing a callable to <code>meter.measure</code> with <code>int</code> argument:</p> <pre><code>BENCHMARK(\"indexed\", i){ return long_computation(i); };\n</code></pre>"},{"location":"benchmarks/#constructors-and-destructors","title":"Constructors and destructors","text":"<p>All of these tools give you a lot mileage, but there are two things that still need special handling: constructors and destructors. The problem is that if you use automatic objects they get destroyed by the end of the scope, so you end up measuring the time for construction and destruction together. And if you use dynamic allocation instead, you end up including the time to allocate memory in the measurements.</p> <p>To solve this conundrum, Catch provides class templates that let you manually construct and destroy objects without dynamic allocation and in a way that lets you measure construction and destruction separately.</p> <pre><code>BENCHMARK_ADVANCED(\"construct\")(Catch::Benchmark::Chronometer meter) {\nstd::vector&lt;Catch::Benchmark::storage_for&lt;std::string&gt;&gt; storage(meter.runs());\nmeter.measure([&amp;](int i) { storage[i].construct(\"thing\"); });\n};\nBENCHMARK_ADVANCED(\"destroy\")(Catch::Benchmark::Chronometer meter) {\nstd::vector&lt;Catch::Benchmark::destructable_object&lt;std::string&gt;&gt; storage(meter.runs());\nfor(auto&amp;&amp; o : storage)\no.construct(\"thing\");\nmeter.measure([&amp;](int i) { storage[i].destruct(); });\n};\n</code></pre> <p><code>Catch::Benchmark::storage_for&lt;T&gt;</code> objects are just pieces of raw storage suitable for <code>T</code> objects. You can use the <code>Catch::Benchmark::storage_for::construct</code> member function to call a constructor and create an object in that storage. So if you want to measure the time it takes for a certain constructor to run, you can just measure the time it takes to run this function.</p> <p>When the lifetime of a <code>Catch::Benchmark::storage_for&lt;T&gt;</code> object ends, if an actual object was constructed there it will be automatically destroyed, so nothing leaks.</p> <p>If you want to measure a destructor, though, we need to use <code>Catch::Benchmark::destructable_object&lt;T&gt;</code>. These objects are similar to <code>Catch::Benchmark::storage_for&lt;T&gt;</code> in that construction of the <code>T</code> object is manual, but it does not destroy anything automatically. Instead, you are required to call the <code>Catch::Benchmark::destructable_object::destruct</code> member function, which is what you can use to measure the destruction time.</p>"},{"location":"benchmarks/#the-optimizer","title":"The optimizer","text":"<p>Sometimes the optimizer will optimize away the very code that you want to measure. There are several ways to use results that will prevent the optimiser from removing them. You can use the <code>volatile</code> keyword, or you can output the value to standard output or to a file, both of which force the program to actually generate the value somehow.</p> <p>Catch adds a third option. The values returned by any function provided as user code are guaranteed to be evaluated and not optimised out. This means that if your user code consists of computing a certain value, you don't need to bother with using <code>volatile</code> or forcing output. Just <code>return</code> it from the function. That helps with keeping the code in a natural fashion.</p> <p>Here's an example:</p> <pre><code>// may measure nothing at all by skipping the long calculation since its\n// result is not used\nBENCHMARK(\"no return\"){ long_calculation(); };\n// the result of long_calculation() is guaranteed to be computed somehow\nBENCHMARK(\"with return\"){ return long_calculation(); };\n</code></pre> <p>However, there's no other form of control over the optimizer whatsoever. It is up to you to write a benchmark that actually measures what you want and doesn't just measure the time to do a whole bunch of nothing.</p> <p>To sum up, there are two simple rules: whatever you would do in handwritten code to control optimization still works in Catch; and Catch makes return values from user code into observable effects that can't be optimized away.</p> <p>Adapted from nonius' documentation.</p>"},{"location":"ci-and-misc/","title":"Ci and misc","text":""},{"location":"ci-and-misc/#tooling-integration-ci-test-runners-and-so-on","title":"Tooling integration (CI, test runners and so on)","text":"<p>Contents Continuous Integration systems Bazel test runner integration Low-level tools CMake</p> <p>This page talks about Catch2's integration with other related tooling, like Continuous Integration and 3rd party test runners.</p>"},{"location":"ci-and-misc/#continuous-integration-systems","title":"Continuous Integration systems","text":"<p>Probably the most important aspect to using Catch with a build server is the use of different reporters. Catch comes bundled with three reporters that should cover the majority of build servers out there - although adding more for better integration with some is always a possibility (currently we also offer TeamCity, TAP, Automake and SonarQube reporters).</p> <p>Two of these reporters are built in (XML and JUnit) and the third (TeamCity) is included as a separate header. It's possible that the other two may be split out in the future too - as that would make the core of Catch smaller for those that don't need them.</p>"},{"location":"ci-and-misc/#xml-reporter","title":"XML Reporter","text":"<p><code>-r xml</code></p> <p>The XML Reporter writes in an XML format that is specific to Catch.</p> <p>The advantage of this format is that it corresponds well to the way Catch works (especially the more unusual features, such as nested sections) and is a fully streaming format - that is it writes output as it goes, without having to store up all its results before it can start writing.</p> <p>The disadvantage is that, being specific to Catch, no existing build servers understand the format natively. It can be used as input to an XSLT transformation that could convert it to, say, HTML - although this loses the streaming advantage, of course.</p>"},{"location":"ci-and-misc/#junit-reporter","title":"JUnit Reporter","text":"<p><code>-r junit</code></p> <p>The JUnit Reporter writes in an XML format that mimics the JUnit ANT schema.</p> <p>The advantage of this format is that the JUnit Ant schema is widely understood by most build servers and so can usually be consumed with no additional work.</p> <p>The disadvantage is that this schema was designed to correspond to how JUnit works - and there is a significant mismatch with how Catch works. Additionally the format is not streamable (because opening elements hold counts of failed and passing tests as attributes) - so the whole test run must complete before it can be written.</p>"},{"location":"ci-and-misc/#teamcity-reporter","title":"TeamCity Reporter","text":"<p><code>-r teamcity</code></p> <p>The TeamCity Reporter writes TeamCity service messages to stdout. In order to be able to use this reporter an additional header must also be included.</p> <p>Being specific to TeamCity this is the best reporter to use with it - but it is completely unsuitable for any other purpose. It is a streaming format (it writes as it goes) - although test results don't appear in the TeamCity interface until the completion of a suite (usually the whole test run).</p>"},{"location":"ci-and-misc/#automake-reporter","title":"Automake Reporter","text":"<p><code>-r automake</code></p> <p>The Automake Reporter writes out the meta tags expected by automake via <code>make check</code>.</p>"},{"location":"ci-and-misc/#tap-test-anything-protocol-reporter","title":"TAP (Test Anything Protocol) Reporter","text":"<p><code>-r tap</code></p> <p>Because of the incremental nature of Catch's test suites and ability to run specific tests, our implementation of TAP reporter writes out the number of tests in a suite last.</p>"},{"location":"ci-and-misc/#sonarqube-reporter","title":"SonarQube Reporter","text":"<p><code>-r sonarqube</code> SonarQube Generic Test Data XML format for tests metrics.</p>"},{"location":"ci-and-misc/#bazel-test-runner-integration","title":"Bazel test runner integration","text":"<p>Catch2 understands some of the environment variables Bazel uses to control test execution. Specifically it understands</p> <ul> <li>JUnit output path via <code>XML_OUTPUT_FILE</code></li> <li>Test filtering via <code>TESTBRIDGE_TEST_ONLY</code></li> <li>Test sharding via <code>TEST_SHARD_INDEX</code>, <code>TEST_TOTAL_SHARDS</code>, and <code>TEST_SHARD_STATUS_FILE</code></li> </ul> <p>Support for <code>XML_OUTPUT_FILE</code> was introduced in Catch2 3.0.1</p> <p>Support for <code>TESTBRIDGE_TEST_ONLY</code> and sharding was introduced in Catch2 3.2.0</p> <p>This integration is enabled via either a compile time configuration option, or via <code>BAZEL_TEST</code> environment variable set to \"1\".</p> <p>Support for <code>BAZEL_TEST</code> was introduced in Catch2 3.1.0</p>"},{"location":"ci-and-misc/#low-level-tools","title":"Low-level tools","text":""},{"location":"ci-and-misc/#codecoverage-module-gcov-lcov","title":"CodeCoverage module (GCOV, LCOV...)","text":"<p>If you are using GCOV tool to get testing coverage of your code, and are not sure how to integrate it with CMake and Catch, there should be an external example over at https://github.com/fkromer/catch_cmake_coverage</p>"},{"location":"ci-and-misc/#pkg-config","title":"pkg-config","text":"<p>Catch2 provides a rudimentary pkg-config integration, by registering itself under the name <code>catch2</code>. This means that after Catch2 is installed, you can use <code>pkg-config</code> to get its include path: <code>pkg-config --cflags catch2</code>.</p>"},{"location":"ci-and-misc/#gdb-and-lldb-scripts","title":"gdb and lldb scripts","text":"<p>Catch2's <code>extras</code> folder also contains two simple debugger scripts, <code>gdbinit</code> for <code>gdb</code> and <code>lldbinit</code> for <code>lldb</code>. If loaded into their respective debugger, these will tell it to step over Catch2's internals when stepping through code.</p>"},{"location":"ci-and-misc/#cmake","title":"CMake","text":"<p>As it has been getting kinda long, the documentation of Catch2's integration with CMake has been moved to its own page.</p>"},{"location":"cmake-integration/","title":"Cmake integration","text":""},{"location":"cmake-integration/#cmake-integration","title":"CMake integration","text":"<p>Contents CMake targets Automatic test registration CMake project options <code>CATCH_CONFIG_*</code> customization options in CMake Installing Catch2 from git repository Installing Catch2 from vcpkg</p> <p>Because we use CMake to build Catch2, we also provide a couple of integration points for our users.</p> <p>1) Catch2 exports a (namespaced) CMake target 2) Catch2's repository contains CMake scripts for automatic registration of <code>TEST_CASE</code>s in CTest</p>"},{"location":"cmake-integration/#cmake-targets","title":"CMake targets","text":"<p>Catch2's CMake build exports two targets, <code>Catch2::Catch2</code>, and <code>Catch2::Catch2WithMain</code>. If you do not need custom <code>main</code> function, you should be using the latter (and only the latter). Linking against it will add the proper include paths and link your target together with 2 static libraries that implement Catch2 and its main respectively. If you need custom <code>main</code>, you should link only against <code>Catch2::Catch2</code>.</p> <p>This means that if Catch2 has been installed on the system, it should be enough to do <pre><code>find_package(Catch2 3 REQUIRED)\n# These tests can use the Catch2-provided main\nadd_executable(tests test.cpp)\ntarget_link_libraries(tests PRIVATE Catch2::Catch2WithMain)\n# These tests need their own main\nadd_executable(custom-main-tests test.cpp test-main.cpp)\ntarget_link_libraries(custom-main-tests PRIVATE Catch2::Catch2)\n</code></pre></p> <p>These targets are also provided when Catch2 is used as a subdirectory. Assuming Catch2 has been cloned to <code>lib/Catch2</code>, you only need to replace the <code>find_package</code> call with <code>add_subdirectory(lib/Catch2)</code> and the snippet above still works.</p> <p>Another possibility is to use FetchContent: <pre><code>Include(FetchContent)\nFetchContent_Declare(\nCatch2\nGIT_REPOSITORY https://github.com/catchorg/Catch2.git\nGIT_TAG        v3.0.1 # or a later release\n)\nFetchContent_MakeAvailable(Catch2)\nadd_executable(tests test.cpp)\ntarget_link_libraries(tests PRIVATE Catch2::Catch2WithMain)\n</code></pre></p>"},{"location":"cmake-integration/#automatic-test-registration","title":"Automatic test registration","text":"<p>Catch2's repository also contains three CMake scripts that help users with automatically registering their <code>TEST_CASE</code>s with CTest. They can be found in the <code>extras</code> folder, and are</p> <p>1) <code>Catch.cmake</code> (and its dependency <code>CatchAddTests.cmake</code>) 2) <code>ParseAndAddCatchTests.cmake</code> (deprecated) 3) <code>CatchShardTests.cmake</code> (and its dependency <code>CatchShardTestsImpl.cmake</code>)</p> <p>If Catch2 has been installed in system, both of these can be used after doing <code>find_package(Catch2 REQUIRED)</code>. Otherwise you need to add them to your CMake module path.</p> <p></p>"},{"location":"cmake-integration/#catchcmake-and-catchaddtestscmake","title":"<code>Catch.cmake</code> and <code>CatchAddTests.cmake</code>","text":"<p><code>Catch.cmake</code> provides function <code>catch_discover_tests</code> to get tests from a target. This function works by running the resulting executable with <code>--list-test-names-only</code> flag, and then parsing the output to find all existing tests.</p>"},{"location":"cmake-integration/#usage","title":"Usage","text":"<pre><code>cmake_minimum_required(VERSION 3.5)\nproject(baz LANGUAGES CXX VERSION 0.0.1)\nfind_package(Catch2 REQUIRED)\nadd_executable(tests test.cpp)\ntarget_link_libraries(tests PRIVATE Catch2::Catch2)\ninclude(CTest)\ninclude(Catch)\ncatch_discover_tests(tests)\n</code></pre> <p>When using <code>FetchContent</code>, <code>include(Catch)</code> will fail unless <code>CMAKE_MODULE_PATH</code> is explicitly updated to include the extras directory.</p> <pre><code># ... FetchContent ...\n#\nlist(APPEND CMAKE_MODULE_PATH ${catch2_SOURCE_DIR}/extras)\ninclude(CTest)\ninclude(Catch)\ncatch_discover_tests(tests)\n</code></pre>"},{"location":"cmake-integration/#customization","title":"Customization","text":"<p><code>catch_discover_tests</code> can be given several extra arguments: <pre><code>catch_discover_tests(target\n[TEST_SPEC arg1...]\n[EXTRA_ARGS arg1...]\n[WORKING_DIRECTORY dir]\n[TEST_PREFIX prefix]\n[TEST_SUFFIX suffix]\n[PROPERTIES name1 value1...]\n[TEST_LIST var]\n[REPORTER reporter]\n[OUTPUT_DIR dir]\n[OUTPUT_PREFIX prefix]\n[OUTPUT_SUFFIX suffix]\n[DISCOVERY_MODE &lt;POST_BUILD|PRE_TEST&gt;]\n)\n</code></pre></p> <ul> <li><code>TEST_SPEC arg1...</code></li> </ul> <p>Specifies test cases, wildcarded test cases, tags and tag expressions to pass to the Catch executable alongside the <code>--list-test-names-only</code> flag.</p> <ul> <li><code>EXTRA_ARGS arg1...</code></li> </ul> <p>Any extra arguments to pass on the command line to each test case.</p> <ul> <li><code>WORKING_DIRECTORY dir</code></li> </ul> <p>Specifies the directory in which to run the discovered test cases.  If this option is not provided, the current binary directory is used.</p> <ul> <li><code>TEST_PREFIX prefix</code></li> </ul> <p>Specifies a prefix to be added to the name of each discovered test case. This can be useful when the same test executable is being used in multiple calls to <code>catch_discover_tests()</code>, with different <code>TEST_SPEC</code> or <code>EXTRA_ARGS</code>.</p> <ul> <li><code>TEST_SUFFIX suffix</code></li> </ul> <p>Same as <code>TEST_PREFIX</code>, except it specific the suffix for the test names. Both <code>TEST_PREFIX</code> and <code>TEST_SUFFIX</code> can be specified at the same time.</p> <ul> <li><code>PROPERTIES name1 value1...</code></li> </ul> <p>Specifies additional properties to be set on all tests discovered by this invocation of <code>catch_discover_tests</code>.</p> <ul> <li><code>TEST_LIST var</code></li> </ul> <p>Make the list of tests available in the variable <code>var</code>, rather than the default <code>&lt;target&gt;_TESTS</code>.  This can be useful when the same test executable is being used in multiple calls to <code>catch_discover_tests()</code>. Note that this variable is only available in CTest.</p> <ul> <li><code>REPORTER reporter</code></li> </ul> <p>Use the specified reporter when running the test case. The reporter will be passed to the test runner as <code>--reporter reporter</code>.</p> <ul> <li><code>OUTPUT_DIR dir</code></li> </ul> <p>If specified, the parameter is passed along as <code>--out dir/&lt;test_name&gt;</code> to test executable. The actual file name is the same as the test name. This should be used instead of <code>EXTRA_ARGS --out foo</code> to avoid race conditions writing the result output when using parallel test execution.</p> <ul> <li><code>OUTPUT_PREFIX prefix</code></li> </ul> <p>May be used in conjunction with <code>OUTPUT_DIR</code>. If specified, <code>prefix</code> is added to each output file name, like so <code>--out dir/prefix&lt;test_name&gt;</code>.</p> <ul> <li><code>OUTPUT_SUFFIX suffix</code></li> </ul> <p>May be used in conjunction with <code>OUTPUT_DIR</code>. If specified, <code>suffix</code> is added to each output file name, like so <code>--out dir/&lt;test_name&gt;suffix</code>. This can be used to add a file extension to the output file name e.g. \".xml\".</p> <ul> <li><code>DISCOVERY_MODE mode</code></li> </ul> <p>If specified allows control over when test discovery is performed. For a value of <code>POST_BUILD</code> (default) test discovery is performed at build time. For a a value of <code>PRE_TEST</code> test discovery is delayed until just prior to test execution (useful e.g. in cross-compilation environments). <code>DISCOVERY_MODE</code> defaults to the value of the <code>CMAKE_CATCH_DISCOVER_TESTS_DISCOVERY_MODE</code> variable if it is not passed when calling <code>catch_discover_tests</code>. This provides a mechanism for globally selecting a preferred test discovery behavior.</p>"},{"location":"cmake-integration/#parseandaddcatchtestscmake","title":"<code>ParseAndAddCatchTests.cmake</code>","text":"<p>\u26a0 This script is deprecated in Catch2 2.13.4 and superseded by the above approach using <code>catch_discover_tests</code>. See #2092 for details.</p> <p><code>ParseAndAddCatchTests</code> works by parsing all implementation files associated with the provided target, and registering them via CTest's <code>add_test</code>. This approach has some limitations, such as the fact that commented-out tests will be registered anyway. More serious, only a subset of the assertion macros currently available in Catch can be detected by this script and tests with any macros that cannot be parsed are silently ignored.</p>"},{"location":"cmake-integration/#usage_1","title":"Usage","text":"<pre><code>cmake_minimum_required(VERSION 3.5)\nproject(baz LANGUAGES CXX VERSION 0.0.1)\nfind_package(Catch2 REQUIRED)\nadd_executable(tests test.cpp)\ntarget_link_libraries(tests PRIVATE Catch2::Catch2)\ninclude(CTest)\ninclude(ParseAndAddCatchTests)\nParseAndAddCatchTests(tests)\n</code></pre>"},{"location":"cmake-integration/#customization_1","title":"Customization","text":"<p><code>ParseAndAddCatchTests</code> provides some customization points: * <code>PARSE_CATCH_TESTS_VERBOSE</code> -- When <code>ON</code>, the script prints debug messages. Defaults to <code>OFF</code>. * <code>PARSE_CATCH_TESTS_NO_HIDDEN_TESTS</code> -- When <code>ON</code>, hidden tests (tests tagged with either of <code>[.]</code> or <code>[.foo]</code>) will not be registered. Defaults to <code>OFF</code>. * <code>PARSE_CATCH_TESTS_ADD_FIXTURE_IN_TEST_NAME</code> -- When <code>ON</code>, adds fixture class name to the test name in CTest. Defaults to <code>ON</code>. * <code>PARSE_CATCH_TESTS_ADD_TARGET_IN_TEST_NAME</code> -- When <code>ON</code>, adds target name to the test name in CTest. Defaults to <code>ON</code>. * <code>PARSE_CATCH_TESTS_ADD_TO_CONFIGURE_DEPENDS</code> -- When <code>ON</code>, adds test file to <code>CMAKE_CONFIGURE_DEPENDS</code>. This means that the CMake configuration step will be re-ran when the test files change, letting new tests be automatically discovered. Defaults to <code>OFF</code>.</p> <p>Optionally, one can specify a launching command to run tests by setting the variable <code>OptionalCatchTestLauncher</code> before calling <code>ParseAndAddCatchTests</code>. For instance to run some tests using <code>MPI</code> and other sequentially, one can write <pre><code>set(OptionalCatchTestLauncher ${MPIEXEC} ${MPIEXEC_NUMPROC_FLAG} ${NUMPROC})\nParseAndAddCatchTests(mpi_foo)\nunset(OptionalCatchTestLauncher)\nParseAndAddCatchTests(bar)\n</code></pre></p>"},{"location":"cmake-integration/#catchshardtestscmake","title":"<code>CatchShardTests.cmake</code>","text":"<p><code>CatchShardTests.cmake</code> was introduced in Catch2 3.1.0.</p> <p><code>CatchShardTests.cmake</code> provides a function <code>catch_add_sharded_tests(TEST_BINARY)</code> that splits tests from <code>TEST_BINARY</code> into multiple shards. The tests in each shard and their order is randomized, and the seed changes every invocation of CTest.</p> <p>Currently there are 3 customization points for this script:</p> <ul> <li>SHARD_COUNT - number of shards to split target's tests into</li> <li>REPORTER    - reporter spec to use for tests</li> <li>TEST_SPEC   - test spec used for filtering tests</li> </ul> <p>Example usage:</p> <pre><code>include(CatchShardTests)\n\ncatch_add_sharded_tests(foo-tests\n  SHARD_COUNT 4\n  REPORTER \"xml::out=-\"\n  TEST_SPEC \"A\"\n)\n\ncatch_add_sharded_tests(tests\n  SHARD_COUNT 8\n  REPORTER \"xml::out=-\"\n  TEST_SPEC \"B\"\n)\n</code></pre> <p>This registers total of 12 CTest tests (4 + 8 shards) to run shards from <code>foo-tests</code> test binary, filtered by a test spec.</p> <p>Note that this script is currently a proof-of-concept for reseeding shards per CTest run, and thus does not support (nor does it currently aim to support) all customization points from <code>catch_discover_tests</code>.</p>"},{"location":"cmake-integration/#cmake-project-options","title":"CMake project options","text":"<p>Catch2's CMake project also provides some options for other projects that consume it. These are:</p> <ul> <li><code>BUILD_TESTING</code> -- When <code>ON</code> and the project is not used as a subproject, Catch2's test binary will be built. Defaults to <code>ON</code>.</li> <li><code>CATCH_INSTALL_DOCS</code> -- When <code>ON</code>, Catch2's documentation will be included in the installation. Defaults to <code>ON</code>.</li> <li><code>CATCH_INSTALL_EXTRAS</code> -- When <code>ON</code>, Catch2's extras folder (the CMake scripts mentioned above, debugger helpers) will be included in the installation. Defaults to <code>ON</code>.</li> <li><code>CATCH_DEVELOPMENT_BUILD</code> -- When <code>ON</code>, configures the build for development of Catch2. This means enabling test projects, warnings and so on. Defaults to <code>OFF</code>.</li> </ul> <p>Enabling <code>CATCH_DEVELOPMENT_BUILD</code> also enables further configuration customization options:</p> <ul> <li><code>CATCH_BUILD_TESTING</code> -- When <code>ON</code>, Catch2's SelfTest project will be built. Defaults to <code>ON</code>. Note that Catch2 also obeys <code>BUILD_TESTING</code> CMake variable, so both of them need to be <code>ON</code> for the SelfTest to be built, and either of them can be set to <code>OFF</code> to disable building SelfTest.</li> <li><code>CATCH_BUILD_EXAMPLES</code> -- When <code>ON</code>, Catch2's usage examples will be built. Defaults to <code>OFF</code>.</li> <li><code>CATCH_BUILD_EXTRA_TESTS</code> -- When <code>ON</code>, Catch2's extra tests will be built. Defaults to <code>OFF</code>.</li> <li><code>CATCH_BUILD_FUZZERS</code> -- When <code>ON</code>, Catch2 fuzzing entry points will be built. Defaults to <code>OFF</code>.</li> <li><code>CATCH_ENABLE_WERROR</code> -- When <code>ON</code>, adds <code>-Werror</code> or equivalent flag to the compilation. Defaults to <code>ON</code>.</li> <li><code>CATCH_BUILD_SURROGATES</code> -- When <code>ON</code>, each header in Catch2 will be compiled separately to ensure that they are self-sufficient. Defaults to <code>OFF</code>.</li> </ul>"},{"location":"cmake-integration/#catch_config_-customization-options-in-cmake","title":"<code>CATCH_CONFIG_*</code> customization options in CMake","text":"<p>CMake support for <code>CATCH_CONFIG_*</code> options was introduced in Catch2 3.0.1</p> <p>Due to the new separate compilation model, all the options from the Compile-time configuration docs can also be set through Catch2's CMake. To set them, define the option you want as <code>ON</code>, e.g. <code>-DCATCH_CONFIG_NOSTDOUT=ON</code>.</p> <p>Note that setting the option to <code>OFF</code> doesn't disable it. To force disable an option, you need to set the <code>_NO_</code> form of it to <code>ON</code>, e.g. <code>-DCATCH_CONFIG_NO_COLOUR_WIN32=ON</code>.</p> <p>To summarize the configuration option behaviour with an example:</p> <code>-DCATCH_CONFIG_COLOUR_WIN32</code> <code>-DCATCH_CONFIG_NO_COLOUR_WIN32</code> Result <code>ON</code> <code>ON</code> error <code>ON</code> <code>OFF</code> force-on <code>OFF</code> <code>ON</code> force-off <code>OFF</code> <code>OFF</code> auto-detect"},{"location":"cmake-integration/#installing-catch2-from-git-repository","title":"Installing Catch2 from git repository","text":"<p>If you cannot install Catch2 from a package manager (e.g. Ubuntu 16.04 provides catch only in version 1.2.0) you might want to install it from the repository instead. Assuming you have enough rights, you can just install it to the default location, like so: <pre><code>$ git clone https://github.com/catchorg/Catch2.git\n$ cd Catch2\n$ cmake -Bbuild -H. -DBUILD_TESTING=OFF\n$ sudo cmake --build build/ --target install\n</code></pre></p> <p>If you do not have superuser rights, you will also need to specify CMAKE_INSTALL_PREFIX when configuring the build, and then modify your calls to find_package accordingly.</p>"},{"location":"cmake-integration/#installing-catch2-from-vcpkg","title":"Installing Catch2 from vcpkg","text":"<p>Alternatively, you can build and install Catch2 using vcpkg dependency manager: <pre><code>git clone https://github.com/Microsoft/vcpkg.git\ncd vcpkg\n./bootstrap-vcpkg.sh\n./vcpkg integrate install\n./vcpkg install catch2\n</code></pre></p> <p>The catch2 port in vcpkg is kept up to date by microsoft team members and community contributors. If the version is out of date, please create an issue or pull request on the vcpkg repository.</p>"},{"location":"command-line/","title":"Command line","text":""},{"location":"command-line/#command-line","title":"Command line","text":"<p>Contents Specifying which tests to run Choosing a reporter to use Breaking into the debugger Showing results for successful tests Aborting after a certain number of failures Listing available tests, tags or reporters Sending output to a file Naming a test run Eliding assertions expected to throw Make whitespace visible Warnings Reporting timings Load test names to run from a file Specify the order test cases are run Specify a seed for the Random Number Generator Identify framework and version according to the libIdentify standard Wait for key before continuing Skip all benchmarks Specify the number of benchmark samples to collect Specify the number of resamples for bootstrapping Specify the confidence-interval for bootstrapping Disable statistical analysis of collected benchmark samples Specify the amount of time in milliseconds spent on warming up each test Usage Specify the section to run Filenames as tags Override output colouring Test Sharding Allow running the binary without tests Output verbosity</p> <p>Catch works quite nicely without any command line options at all - but for those times when you want greater control the following options are available. Click one of the following links to take you straight to that option - or scroll on to browse the available options.</p> <p> <code>&lt;test-spec&gt; ...</code> <code>-h, -?, --help</code> <code>-s, --success</code> <code>-b, --break</code> <code>-e, --nothrow</code> <code>-i, --invisibles</code> <code>-o, --out</code> <code>-r, --reporter</code> <code>-n, --name</code> <code>-a, --abort</code> <code>-x, --abortx</code> <code>-w, --warn</code> <code>-d, --durations</code> <code>-f, --input-file</code> <code>-c, --section</code> <code>-#, --filenames-as-tags</code></p> <p></p> <p> <code>--list-tests</code> <code>--list-tags</code> <code>--list-reporters</code> <code>--list-listeners</code> <code>--order</code> <code>--rng-seed</code> <code>--libidentify</code> <code>--wait-for-keypress</code> <code>--skip-benchmarks</code> <code>--benchmark-samples</code> <code>--benchmark-resamples</code> <code>--benchmark-confidence-interval</code> <code>--benchmark-no-analysis</code> <code>--benchmark-warmup-time</code> <code>--colour-mode</code> <code>--shard-count</code> <code>--shard-index</code> <code>--allow-running-no-tests</code> <code>--verbosity</code></p> <p></p> <p></p>"},{"location":"command-line/#specifying-which-tests-to-run","title":"Specifying which tests to run","text":"<pre>&lt;test-spec&gt; ...</pre> <p>Test cases, wildcarded test cases, tags and tag expressions are all passed directly as arguments. Tags are distinguished by being enclosed in square brackets.</p> <p>If no test specs are supplied then all test cases, except \"hidden\" tests, are run. A test is hidden by giving it any tag starting with (or just) a period (<code>.</code>) - or, in the deprecated case, tagged <code>[hide]</code> or given name starting with <code>'./'</code>. To specify hidden tests from the command line <code>[.]</code> or <code>[hide]</code> can be used regardless of how they were declared.</p> <p>Specs must be enclosed in quotes if they contain spaces. If they do not contain spaces the quotes are optional.</p> <p>Wildcards consist of the <code>*</code> character at the beginning and/or end of test case names and can substitute for any number of any characters (including none).</p> <p>Test specs are case insensitive.</p> <p>If a spec is prefixed with <code>exclude:</code> or the <code>~</code> character then the pattern matches an exclusion. This means that tests matching the pattern are excluded from the set - even if a prior inclusion spec included them. Subsequent inclusion specs will take precedence, however. Inclusions and exclusions are evaluated in left-to-right order.</p> <p>Test case examples:</p> <pre><code>thisTestOnly            Matches the test case called, 'thisTestOnly'\n\"this test only\"        Matches the test case called, 'this test only'\nthese*                  Matches all cases starting with 'these'\nexclude:notThis         Matches all tests except, 'notThis'\n~notThis                Matches all tests except, 'notThis'\n~*private*              Matches all tests except those that contain 'private'\na* ~ab* abc             Matches all tests that start with 'a', except those that\n                        start with 'ab', except 'abc', which is included\n~[tag1]                 Matches all tests except those tagged with '[tag1]'\n-# [#somefile]          Matches all tests from the file 'somefile.cpp'\n</code></pre> <p>Names within square brackets are interpreted as tags. A series of tags form an AND expression whereas a comma-separated sequence forms an OR expression. e.g.:</p> <pre>[one][two],[three]</pre> <p>This matches all tests tagged <code>[one]</code> and <code>[two]</code>, as well as all tests tagged <code>[three]</code></p> <p>Test names containing special characters, such as <code>,</code> or <code>[</code> can specify them on the command line using <code>\\</code>. <code>\\</code> also escapes itself.</p> <p></p>"},{"location":"command-line/#choosing-a-reporter-to-use","title":"Choosing a reporter to use","text":"<pre>-r, --reporter &lt;reporter[::key=value]*&gt;</pre> <p>Reporters are how the output from Catch2 (results of assertions, tests, benchmarks and so on) is formatted and written out. The default reporter is called the \"Console\" reporter and is intended to provide relatively verbose and human-friendly output.</p> <p>Reporters are also individually configurable. To pass configuration options to the reporter, you append <code>::key=value</code> to the reporter specification as many times as you want, e.g. <code>--reporter xml::out=someFile.xml</code>.</p> <p>The keys must either be prefixed by \"X\", in which case they are not parsed by Catch2 and are only passed down to the reporter, or one of options hardcoded into Catch2. Currently there are only 2, \"out\", and \"colour-mode\".</p> <p>Note that the reporter might still check the X-prefixed options for validity, and throw an error if they are wrong.</p> <p>Support for passing arguments to reporters through the <code>-r</code>, <code>--reporter</code> flag was introduced in Catch2 3.0.1</p> <p>There are multiple built-in reporters, you can see what they do by using the <code>--list-reporters</code> flag. If you need a reporter providing custom format outside of the already provided ones, look at the \"write your own reporter\" part of the reporter documentation.</p> <p>This option may be passed multiple times to use multiple (different) reporters  at the same time. See the reporter documentation for details on what the resulting behaviour is. Also note that at most one reporter can be provided without the output-file part of reporter spec. This reporter will use the \"default\" output destination, based on the <code>-o</code>, <code>--out</code> option.</p> <p>Support for using multiple different reporters at the same time was introduced in Catch2 3.0.1</p> <p>Note: There is currently no way to escape <code>::</code> in the reporter spec, and thus the reporter names, or configuration keys and values, cannot contain <code>::</code>. As <code>::</code> in paths is relatively obscure (unlike ':'), we do not consider this an issue.</p> <p></p>"},{"location":"command-line/#breaking-into-the-debugger","title":"Breaking into the debugger","text":"<pre>-b, --break</pre> <p>Under most debuggers Catch2 is capable of automatically breaking on a test failure. This allows the user to see the current state of the test during failure.</p> <p></p>"},{"location":"command-line/#showing-results-for-successful-tests","title":"Showing results for successful tests","text":"<pre>-s, --success</pre> <p>Usually you only want to see reporting for failed tests. Sometimes it's useful to see all the output (especially when you don't trust that that test you just added worked first time!). To see successful, as well as failing, test results just pass this option. Note that each reporter may treat this option differently. The Junit reporter, for example, logs all results regardless.</p> <p></p>"},{"location":"command-line/#aborting-after-a-certain-number-of-failures","title":"Aborting after a certain number of failures","text":"<pre>-a, --abort\n-x, --abortx [&lt;failure threshold&gt;]\n</pre> <p>If a <code>REQUIRE</code> assertion fails the test case aborts, but subsequent test cases are still run. If a <code>CHECK</code> assertion fails even the current test case is not aborted.</p> <p>Sometimes this results in a flood of failure messages and you'd rather just see the first few. Specifying <code>-a</code> or <code>--abort</code> on its own will abort the whole test run on the first failed assertion of any kind. Use <code>-x</code> or <code>--abortx</code> followed by a number to abort after that number of assertion failures.</p> <p></p>"},{"location":"command-line/#listing-available-tests-tags-or-reporters","title":"Listing available tests, tags or reporters","text":"<pre><code>--list-tests\n--list-tags\n--list-reporters\n--list-listeners\n</code></pre> <p>The <code>--list*</code> options became customizable through reporters in Catch2 3.0.1</p> <p>The <code>--list-listeners</code> option was added in Catch2 3.0.1</p> <p><code>--list-tests</code> lists all registered tests matching specified test spec. Usually this listing also includes tags, and potentially also other information, like source location, based on verbosity and reporter's design.</p> <p><code>--list-tags</code> lists all tags from registered tests matching specified test spec. Usually this also includes number of tests cases they match and similar information.</p> <p><code>--list-reporters</code> lists all available reporters and their descriptions.</p> <p><code>--list-listeners</code> lists all registered listeners and their descriptions.</p> <p>The <code>--verbosity</code> argument modifies the level of detail provided by the default <code>--list*</code> options as follows:</p> Option <code>normal</code> (default) <code>quiet</code> <code>high</code> <code>--list-tests</code> Test names and tags Test names only Same as <code>normal</code>, plus source code line <code>--list-tags</code> Tags and counts Same as <code>normal</code> Same as <code>normal</code> <code>--list-reporters</code> Reporter names and descriptions Reporter names only Same as <code>normal</code> <code>--list-listeners</code> Listener names and descriptions Same as <code>normal</code> Same as <code>normal</code> <p></p>"},{"location":"command-line/#sending-output-to-a-file","title":"Sending output to a file","text":"<pre>-o, --out &lt;filename&gt;\n</pre> <p>Use this option to send all output to a file, instead of stdout. You can use <code>-</code> as the filename to explicitly send the output to stdout (this is useful e.g. when using multiple reporters).</p> <p>Support for <code>-</code> as the filename was introduced in Catch2 3.0.1</p> <p>Filenames starting with \"%\" (percent symbol) are reserved by Catch2 for meta purposes, e.g. using <code>%debug</code> as the filename opens stream that writes to platform specific debugging/logging mechanism.</p> <p>Catch2 currently recognizes 3 meta streams:</p> <ul> <li><code>%debug</code> - writes to platform specific debugging/logging output</li> <li><code>%stdout</code> - writes to stdout</li> <li><code>%stderr</code> - writes to stderr</li> </ul> <p>Support for <code>%stdout</code> and <code>%stderr</code> was introduced in Catch2 3.0.1</p> <p></p>"},{"location":"command-line/#naming-a-test-run","title":"Naming a test run","text":"<pre>-n, --name &lt;name for test run&gt;</pre> <p>If a name is supplied it will be used by the reporter to provide an overall name for the test run. This can be useful if you are sending to a file, for example, and need to distinguish different test runs - either from different Catch executables or runs of the same executable with different options. If not supplied the name is defaulted to the name of the executable.</p> <p></p>"},{"location":"command-line/#eliding-assertions-expected-to-throw","title":"Eliding assertions expected to throw","text":"<pre>-e, --nothrow</pre> <p>Skips all assertions that test that an exception is thrown, e.g. <code>REQUIRE_THROWS</code>.</p> <p>These can be a nuisance in certain debugging environments that may break when exceptions are thrown (while this is usually optional for handled exceptions, it can be useful to have enabled if you are trying to track down something unexpected).</p> <p>Sometimes exceptions are expected outside of one of the assertions that tests for them (perhaps thrown and caught within the code-under-test). The whole test case can be skipped when using <code>-e</code> by marking it with the <code>[!throws]</code> tag.</p> <p>When running with this option any throw checking assertions are skipped so as not to contribute additional noise. Be careful if this affects the behaviour of subsequent tests.</p> <p></p>"},{"location":"command-line/#make-whitespace-visible","title":"Make whitespace visible","text":"<pre>-i, --invisibles</pre> <p>If a string comparison fails due to differences in whitespace - especially leading or trailing whitespace - it can be hard to see what's going on. This option transforms tabs and newline characters into <code>\\t</code> and <code>\\n</code> respectively when printing.</p> <p></p>"},{"location":"command-line/#warnings","title":"Warnings","text":"<pre>-w, --warn &lt;warning name&gt;</pre> <p>You can think of Catch2's warnings as the equivalent of <code>-Werror</code> (<code>/WX</code>) flag for C++ compilers. It turns some suspicious occurrences, like a section without assertions, into errors. Because these might be intended, warnings are not enabled by default, but user can opt in.</p> <p>You can enable multiple warnings at the same time.</p> <p>There are currently two warnings implemented:</p> <pre><code>    NoAssertions        // Fail test case / leaf section if no assertions\n                        // (e.g. `REQUIRE`) is encountered.\n    UnmatchedTestSpec   // Fail test run if any of the CLI test specs did\n                        // not match any tests.\n</code></pre> <p><code>UnmatchedTestSpec</code> was introduced in Catch2 3.0.1.</p> <p></p>"},{"location":"command-line/#reporting-timings","title":"Reporting timings","text":"<pre>-d, --durations &lt;yes/no&gt;</pre> <p>When set to <code>yes</code> Catch will report the duration of each test case, in milliseconds. Note that it does this regardless of whether a test case passes or fails. Note, also, the certain reporters (e.g. Junit) always report test case durations regardless of this option being set or not.</p> <pre>-D, --min-duration &lt;value&gt;</pre> <p><code>--min-duration</code> was introduced in Catch2 2.13.0</p> <p>When set, Catch will report the duration of each test case that took more than &lt;value&gt; seconds, in milliseconds. This option is overridden by both <code>-d yes</code> and <code>-d no</code>, so that either all durations are reported, or none are.</p> <p></p>"},{"location":"command-line/#load-test-names-to-run-from-a-file","title":"Load test names to run from a file","text":"<pre>-f, --input-file &lt;filename&gt;</pre> <p>Provide the name of a file that contains a list of test case names, one per line. Blank lines are skipped.</p> <p>A useful way to generate an initial instance of this file is to combine the <code>--list-tests</code> flag with the <code>--verbosity quiet</code> option. You can also use test specs to filter this list down to what you want first.</p> <p></p>"},{"location":"command-line/#specify-the-order-test-cases-are-run","title":"Specify the order test cases are run","text":"<pre>--order &lt;decl|lex|rand&gt;</pre> <p>Test cases are ordered one of three ways:</p>"},{"location":"command-line/#decl","title":"decl","text":"<p>Declaration order (this is the default order if no --order argument is provided). Tests in the same translation unit are sorted using their declaration orders, different TUs are sorted in an implementation (linking) dependent order.</p>"},{"location":"command-line/#lex","title":"lex","text":"<p>Lexicographic order. Tests are sorted by their name, their tags are ignored.</p>"},{"location":"command-line/#rand","title":"rand","text":"<p>Randomly ordered. The order is dependent on Catch2's random seed (see <code>--rng-seed</code>), and is subset invariant. What this means is that as long as the random seed is fixed, running only some tests (e.g. via tag) does not change their relative order.</p> <p>The subset stability was introduced in Catch2 v2.12.0</p> <p>Since the random order was made subset stable, we promise that given the same random seed, the order of test cases will be the same across different platforms, as long as the tests were compiled against identical version of Catch2. We reserve the right to change the relative order of tests cases between Catch2 versions, but it is unlikely to happen often.</p> <p></p>"},{"location":"command-line/#specify-a-seed-for-the-random-number-generator","title":"Specify a seed for the Random Number Generator","text":"<pre>--rng-seed &lt;'time'|'random-device'|number&gt;</pre> <p>Sets the seed for random number generators used by Catch2. These are used e.g. to shuffle tests when user asks for tests to be in random order.</p> <p>Using <code>time</code> as the argument asks Catch2 generate the seed through call to <code>std::time(nullptr)</code>. This provides very weak randomness and multiple runs of the binary can generate the same seed if they are started close to each other.</p> <p>Using <code>random-device</code> asks for <code>std::random_device</code> to be used instead. If your implementation provides working <code>std::random_device</code>, it should be preferred to using <code>time</code>. Catch2 uses <code>std::random_device</code> by default.</p> <p></p>"},{"location":"command-line/#identify-framework-and-version-according-to-the-libidentify-standard","title":"Identify framework and version according to the libIdentify standard","text":"<pre>--libidentify</pre> <p>See The LibIdentify repo for more information and examples.</p> <p></p>"},{"location":"command-line/#wait-for-key-before-continuing","title":"Wait for key before continuing","text":"<pre>--wait-for-keypress &lt;never|start|exit|both&gt;</pre> <p>Will cause the executable to print a message and wait until the return/ enter key is pressed before continuing - either before running any tests, after running all tests - or both, depending on the argument.</p> <p></p>"},{"location":"command-line/#skip-all-benchmarks","title":"Skip all benchmarks","text":"<pre>--skip-benchmarks</pre> <p>Introduced in Catch2 3.0.1.</p> <p>This flag tells Catch2 to skip running all benchmarks. Benchmarks in this case mean code blocks in <code>BENCHMARK</code> and <code>BENCHMARK_ADVANCED</code> macros, not test cases with the <code>[!benchmark]</code> tag.</p> <p></p>"},{"location":"command-line/#specify-the-number-of-benchmark-samples-to-collect","title":"Specify the number of benchmark samples to collect","text":"<pre>--benchmark-samples &lt;# of samples&gt;</pre> <p>Introduced in Catch2 2.9.0.</p> <p>When running benchmarks a number of \"samples\" is collected. This is the base data for later statistical analysis. Per sample a clock resolution dependent number of iterations of the user code is run, which is independent of the number of samples. Defaults to 100.</p> <p></p>"},{"location":"command-line/#specify-the-number-of-resamples-for-bootstrapping","title":"Specify the number of resamples for bootstrapping","text":"<pre>--benchmark-resamples &lt;# of resamples&gt;</pre> <p>Introduced in Catch2 2.9.0.</p> <p>After the measurements are performed, statistical bootstrapping is performed on the samples. The number of resamples for that bootstrapping is configurable but defaults to 100000. Due to the bootstrapping it is possible to give estimates for the mean and standard deviation. The estimates come with a lower bound and an upper bound, and the confidence interval (which is configurable but defaults to 95%).</p> <p></p>"},{"location":"command-line/#specify-the-confidence-interval-for-bootstrapping","title":"Specify the confidence-interval for bootstrapping","text":"<pre>--benchmark-confidence-interval &lt;confidence-interval&gt;</pre> <p>Introduced in Catch2 2.9.0.</p> <p>The confidence-interval is used for statistical bootstrapping on the samples to calculate the upper and lower bounds of mean and standard deviation. Must be between 0 and 1 and defaults to 0.95.</p> <p></p>"},{"location":"command-line/#disable-statistical-analysis-of-collected-benchmark-samples","title":"Disable statistical analysis of collected benchmark samples","text":"<pre>--benchmark-no-analysis</pre> <p>Introduced in Catch2 2.9.0.</p> <p>When this flag is specified no bootstrapping or any other statistical analysis is performed. Instead the user code is only measured and the plain mean from the samples is reported.</p> <p></p>"},{"location":"command-line/#specify-the-amount-of-time-in-milliseconds-spent-on-warming-up-each-test","title":"Specify the amount of time in milliseconds spent on warming up each test","text":"<pre>--benchmark-warmup-time</pre> <p>Introduced in Catch2 2.11.2.</p> <p>Configure the amount of time spent warming up each test.</p> <p></p>"},{"location":"command-line/#usage","title":"Usage","text":"<pre>-h, -?, --help</pre> <p>Prints the command line arguments to stdout</p> <p></p>"},{"location":"command-line/#specify-the-section-to-run","title":"Specify the section to run","text":"<pre>-c, --section &lt;section name&gt;</pre> <p>To limit execution to a specific section within a test case, use this option one or more times. To narrow to sub-sections use multiple instances, where each subsequent instance specifies a deeper nesting level.</p> <p>E.g. if you have:</p> <pre>\nTEST_CASE( \"Test\" ) {\n  SECTION( \"sa\" ) {\n    SECTION( \"sb\" ) {\n      /*...*/\n    }\n    SECTION( \"sc\" ) {\n      /*...*/\n    }\n  }\n  SECTION( \"sd\" ) {\n    /*...*/\n  }\n}\n</pre> <p>Then you can run <code>sb</code> with:</p> <pre>./MyExe Test -c sa -c sb</pre> <p>Or run just <code>sd</code> with:</p> <pre>./MyExe Test -c sd</pre> <p>To run all of <code>sa</code>, including <code>sb</code> and <code>sc</code> use:</p> <pre>./MyExe Test -c sa</pre> <p>There are some limitations of this feature to be aware of: - Code outside of sections being skipped will still be executed - e.g. any set-up code in the TEST_CASE before the start of the first section. - At time of writing, wildcards are not supported in section names. - If you specify a section without narrowing to a test case first then all test cases will be executed (but only matching sections within them).</p> <p></p>"},{"location":"command-line/#filenames-as-tags","title":"Filenames as tags","text":"<pre>-#, --filenames-as-tags</pre> <p>This option adds an extra tag to all test cases. The tag is <code>#</code> followed by the unqualified filename the test case is defined in, with the last extension stripped out.</p> <p>For example, tests within the file <code>tests\\SelfTest\\UsageTests\\BDD.tests.cpp</code> will be given the <code>[#BDD.tests]</code> tag.</p> <p></p>"},{"location":"command-line/#override-output-colouring","title":"Override output colouring","text":"<pre>--colour-mode &lt;ansi|win32|none|default&gt;</pre> <p>The <code>--colour-mode</code> option replaced the old <code>--colour</code> option in Catch2 3.0.1</p> <p>Catch2 support two different ways of colouring terminal output, and by default it attempts to make a good guess on which implementation to use (and whether to even use it, e.g. Catch2 tries to avoid writing colour codes when writing the results into a file).</p> <p><code>--colour-mode</code> allows the user to explicitly select what happens.</p> <ul> <li><code>--colour-mode ansi</code> tells Catch2 to always use ANSI colour codes, even when writing to a file</li> <li><code>--colour-mode win32</code> tells Catch2 to use colour implementation based   on Win32 terminal API</li> <li><code>--colour-mode none</code> tells Catch2 to disable colours completely</li> <li><code>--colour-mode default</code> lets Catch2 decide</li> </ul> <p><code>--colour-mode default</code> is the default setting.</p> <p></p>"},{"location":"command-line/#test-sharding","title":"Test Sharding","text":"<pre>--shard-count &lt;#number of shards&gt;, --shard-index &lt;#shard index to run&gt;</pre> <p>Introduced in Catch2 3.0.1.</p> <p>When <code>--shard-count &lt;#number of shards&gt;</code> is used, the tests to execute will be split evenly in to the given number of sets, identified by indices starting at 0. The tests in the set given by <code>--shard-index &lt;#shard index to run&gt;</code> will be executed. The default shard count is <code>1</code>, and the default index to run is <code>0</code>.</p> <p>Shard index must be less than number of shards. As the name suggests, it is treated as an index of the shard to run.</p> <p>Sharding is useful when you want to split test execution across multiple processes, as is done with the Bazel test sharding.</p> <p></p>"},{"location":"command-line/#allow-running-the-binary-without-tests","title":"Allow running the binary without tests","text":"<pre>--allow-running-no-tests</pre> <p>Introduced in Catch2 3.0.1.</p> <p>By default, Catch2 test binaries return non-0 exit code if no tests were run, e.g. if the binary was compiled with no tests, the provided test spec matched no tests, or all tests were skipped at runtime. This flag overrides that, so a test run with no tests still returns 0.</p>"},{"location":"command-line/#output-verbosity","title":"Output verbosity","text":"<pre><code>-v, --verbosity &lt;quiet|normal|high&gt;\n</code></pre> <p>Changing verbosity might change how many details Catch2's reporters output. However, you should consider changing the verbosity level as a suggestion. Not all reporters support all verbosity levels, e.g. because the reporter's format cannot meaningfully change. In that case, the verbosity level is ignored.</p> <p>Verbosity defaults to normal.</p>"},{"location":"commercial-users/","title":"Commercial users","text":""},{"location":"commercial-users/#commercial-users-of-catch2","title":"Commercial users of Catch2","text":"<p>Catch2 is also widely used in proprietary code bases. This page contains some of them that are willing to share this information.</p> <p>If you want to add your organisation, please check that there is no issue with you sharing this fact.</p> <ul> <li>Bloomberg</li> <li>Bloomlife</li> <li>Inscopix Inc.</li> <li>Locksley.CZ</li> <li>Makimo</li> <li>NASA</li> <li>Nexus Software Systems</li> <li>UX3D</li> <li>King</li> </ul>"},{"location":"comparing-floating-point-numbers/","title":"Comparing floating point numbers","text":""},{"location":"comparing-floating-point-numbers/#comparing-floating-point-numbers-with-catch2","title":"Comparing floating point numbers with Catch2","text":"<p>If you are not deeply familiar with them, floating point numbers can be unintuitive. This also applies to comparing floating point numbers for (in)equality.</p> <p>This page assumes that you have some understanding of both FP, and the meaning of different kinds of comparisons, and only goes over what functionality Catch2 provides to help you with comparing floating point numbers. If you do not have this understanding, we recommend that you first study up on floating point numbers and their comparisons, e.g. by reading this blog post.</p>"},{"location":"comparing-floating-point-numbers/#floating-point-matchers","title":"Floating point matchers","text":"<pre><code>#include &lt;catch2/matchers/catch_matchers_floating_point.hpp&gt;\n</code></pre> <p>Matchers are the preferred way of comparing floating point numbers in Catch2. We provide 3 of them:</p> <ul> <li><code>WithinAbs(double target, double margin)</code>,</li> <li><code>WithinRel(FloatingPoint target, FloatingPoint eps)</code>, and</li> <li><code>WithinULP(FloatingPoint target, uint64_t maxUlpDiff)</code>.</li> </ul> <p><code>WithinRel</code> matcher was introduced in Catch2 2.10.0</p> <p>As with all matchers, you can combine multiple floating point matchers in a single assertion. For example, to check that some computation matches a known good value within 0.1% or is close enough (no different to 5 decimal places) to zero, we would write this assertion:</p> <pre><code>    REQUIRE_THAT( computation(input),\nCatch::Matchers::WithinRel(expected, 0.001)\n|| Catch::Matchers::WithinAbs(0, 0.000001) );\n</code></pre>"},{"location":"comparing-floating-point-numbers/#withinabs","title":"WithinAbs","text":"<p><code>WithinAbs</code> creates a matcher that accepts floating point numbers whose difference with <code>target</code> is less-or-equal to the <code>margin</code>. Since <code>float</code> can be converted to <code>double</code> without losing precision, only <code>double</code> overload exists.</p> <pre><code>REQUIRE_THAT(1.0, WithinAbs(1.2, 0.2));\nREQUIRE_THAT(0.f, !WithinAbs(1.0, 0.5));\n// Notice that infinity == infinity for WithinAbs\nREQUIRE_THAT(INFINITY, WithinAbs(INFINITY, 0));\n</code></pre>"},{"location":"comparing-floating-point-numbers/#withinrel","title":"WithinRel","text":"<p><code>WithinRel</code> creates a matcher that accepts floating point numbers that are approximately equal to the <code>target</code> with a tolerance of <code>eps.</code> Specifically, it matches if <code>|arg - target| &lt;= eps * max(|arg|, |target|)</code> holds. If you do not specify <code>eps</code>, <code>std::numeric_limits&lt;FloatingPoint&gt;::epsilon * 100</code> is used as the default.</p> <pre><code>// Notice that WithinRel comparison is symmetric, unlike Approx's.\nREQUIRE_THAT(1.0, WithinRel(1.1, 0.1));\nREQUIRE_THAT(1.1, WithinRel(1.0, 0.1));\n// Notice that inifnity == infinity for WithinRel\nREQUIRE_THAT(INFINITY, WithinRel(INFINITY));\n</code></pre>"},{"location":"comparing-floating-point-numbers/#withinulp","title":"WithinULP","text":"<p><code>WithinULP</code> creates a matcher that accepts floating point numbers that are no more than <code>maxUlpDiff</code> ULPs away from the <code>target</code> value. The short version of what this means is that there is no more than <code>maxUlpDiff - 1</code> representable floating point numbers between the argument for matching and the <code>target</code> value.</p> <p>When using the ULP matcher in Catch2, it is important to keep in mind that Catch2 interprets ULP distance slightly differently than e.g. <code>std::nextafter</code> does.</p> <p>Catch2's ULP calculation obeys these relations:   * <code>ulpDistance(-x, x) == 2 * ulpDistance(x, 0)</code>   * <code>ulpDistance(-0, 0) == 0</code> (due to the above)   * <code>ulpDistance(DBL_MAX, INFINITY) == 1</code>   * <code>ulpDistancE(NaN, x) == infinity</code></p> <p>Important: The WithinULP matcher requires the platform to use the IEEE-754 representation for floating point numbers.</p> <pre><code>REQUIRE_THAT( -0.f, WithinULP( 0.f, 0 ) );\n</code></pre>"},{"location":"comparing-floating-point-numbers/#approx","title":"<code>Approx</code>","text":"<pre><code>#include &lt;catch2/catch_approx.hpp&gt;\n</code></pre> <p>We strongly recommend against using <code>Approx</code> when writing new code. You should be using floating point matchers instead.</p> <p>Catch2 provides one more way to handle floating point comparisons. It is <code>Approx</code>, a special type with overloaded comparison operators, that can be used in standard assertions, e.g.</p> <pre><code>REQUIRE(0.99999 == Catch::Approx(1));\n</code></pre> <p><code>Approx</code> supports four comparison operators, <code>==</code>, <code>!=</code>, <code>&lt;=</code>, <code>&gt;=</code>, and can also be used with strong typedefs over <code>double</code>s. It can be used for both relative and margin comparisons by using its three customization points. Note that the semantics of this is always that of an or, so if either the relative or absolute margin comparison passes, then the whole comparison passes.</p> <p>The downside to <code>Approx</code> is that it has a couple of issues that we cannot fix without breaking backwards compatibility. Because Catch2 also provides complete set of matchers that implement different floating point comparison methods, <code>Approx</code> is left as-is, is considered deprecated, and should not be used in new code.</p> <p>The issues are   * All internal computation is done in <code>double</code>s, leading to slightly     different results if the inputs were floats.   * <code>Approx</code>'s relative margin comparison is not symmetric. This means     that <code>Approx( 10 ).epsilon(0.1) != 11.1</code> but <code>Approx( 11.1 ).epsilon(0.1) == 10</code>.   * By default, <code>Approx</code> only uses relative margin comparison. This means     that <code>Approx(0) == X</code> only passes for <code>X == 0</code>.</p>"},{"location":"comparing-floating-point-numbers/#approx-details","title":"Approx details","text":"<p>If you still want/need to know more about <code>Approx</code>, read on.</p> <p>Catch2 provides a UDL for <code>Approx</code>; <code>_a</code>. It resides in the <code>Catch::literals</code> namespace, and can be used like this:</p> <pre><code>using namespace Catch::literals;\nREQUIRE( performComputation() == 2.1_a );\n</code></pre> <p><code>Approx</code> has three customization points for the comparison:</p> <ul> <li>epsilon - epsilon sets the coefficient by which a result can differ from <code>Approx</code>'s value before it is rejected. Defaults to <code>std::numeric_limits&lt;float&gt;::epsilon()*100</code>.</li> </ul> <pre><code>Approx target = Approx(100).epsilon(0.01);\n100.0 == target; // Obviously true\n200.0 == target; // Obviously still false\n100.5 == target; // True, because we set target to allow up to 1% difference\n</code></pre> <ul> <li>margin - margin sets the absolute value by which a result can differ from <code>Approx</code>'s value before it is rejected. Defaults to <code>0.0</code>.</li> </ul> <pre><code>Approx target = Approx(100).margin(5);\n100.0 == target; // Obviously true\n200.0 == target; // Obviously still false\n104.0 == target; // True, because we set target to allow absolute difference of at most 5\n</code></pre> <ul> <li>scale - scale is used to change the magnitude of <code>Approx</code> for the relative check. By default, set to <code>0.0</code>.</li> </ul> <p>Scale could be useful if the computation leading to the result worked on a different scale than is used by the results. Approx's scale is added to Approx's value when computing the allowed relative margin from the Approx's value.</p>"},{"location":"configuration/","title":"Configuration","text":""},{"location":"configuration/#compile-time-configuration","title":"Compile-time configuration","text":"<p>Contents Prefixing Catch macros Terminal colour Console width stdout Fallback stringifier Default reporter Bazel support C++11 toggles C++17 toggles Other toggles Enabling stringification Disabling exceptions Overriding Catch's debug break (<code>-b</code>) Static analysis support</p> <p>Catch2 is designed to \"just work\" as much as possible, and most of the configuration options below are changed automatically during compilation, according to the detected environment. However, this detection can also be overridden by users, using macros documented below, and/or CMake options with the same name.</p>"},{"location":"configuration/#prefixing-catch-macros","title":"Prefixing Catch macros","text":"<pre><code>CATCH_CONFIG_PREFIX_ALL\n</code></pre> <p>To keep test code clean and uncluttered Catch uses short macro names (e.g. <code>TEST_CASE</code> and <code>REQUIRE</code>). Occasionally these may conflict with identifiers from platform headers or the system under test. In this case the above identifier can be defined. This will cause all the Catch user macros to be prefixed with <code>CATCH_</code> (e.g. <code>CATCH_TEST_CASE</code> and <code>CATCH_REQUIRE</code>).</p>"},{"location":"configuration/#terminal-colour","title":"Terminal colour","text":"<pre><code>CATCH_CONFIG_COLOUR_WIN32     // Force enables compiling colouring impl based on Win32 console API\nCATCH_CONFIG_NO_COLOUR_WIN32  // Force disables ...\n</code></pre> <p>Yes, Catch2 uses the british spelling of colour.</p> <p>Catch2 attempts to autodetect whether the Win32 console colouring API, <code>SetConsoleTextAttribute</code>, is available, and if it is available it compiles in a console colouring implementation that uses it.</p> <p>This option can be used to override Catch2's autodetection and force the compilation either ON or OFF.</p>"},{"location":"configuration/#console-width","title":"Console width","text":"<pre><code>CATCH_CONFIG_CONSOLE_WIDTH = x // where x is a number\n</code></pre> <p>Catch formats output intended for the console to fit within a fixed number of characters. This is especially important as indentation is used extensively and uncontrolled line wraps break this. By default a console width of 80 is assumed but this can be controlled by defining the above identifier to be a different value.</p>"},{"location":"configuration/#stdout","title":"stdout","text":"<pre><code>CATCH_CONFIG_NOSTDOUT\n</code></pre> <p>To support platforms that do not provide <code>std::cout</code>, <code>std::cerr</code> and <code>std::clog</code>, Catch does not use them directly, but rather calls <code>Catch::cout</code>, <code>Catch::cerr</code> and <code>Catch::clog</code>. You can replace their implementation by defining <code>CATCH_CONFIG_NOSTDOUT</code> and implementing them yourself, their signatures are:</p> <pre><code>std::ostream&amp; cout();\nstd::ostream&amp; cerr();\nstd::ostream&amp; clog();\n</code></pre> <p>You can see an example of replacing these functions here.</p>"},{"location":"configuration/#fallback-stringifier","title":"Fallback stringifier","text":"<p>By default, when Catch's stringification machinery has to stringify a type that does not specialize <code>StringMaker</code>, does not overload <code>operator&lt;&lt;</code>, is not an enumeration and is not a range, it uses <code>\"{?}\"</code>. This can be overridden by defining <code>CATCH_CONFIG_FALLBACK_STRINGIFIER</code> to name of a function that should perform the stringification instead.</p> <p>All types that do not provide <code>StringMaker</code> specialization or <code>operator&lt;&lt;</code> overload will be sent to this function (this includes enums and ranges). The provided function must return <code>std::string</code> and must accept any type, e.g. via overloading.</p> <p>Note that if the provided function does not handle a type and this type requires to be stringified, the compilation will fail.</p>"},{"location":"configuration/#default-reporter","title":"Default reporter","text":"<p>Catch's default reporter can be changed by defining macro <code>CATCH_CONFIG_DEFAULT_REPORTER</code> to string literal naming the desired default reporter.</p> <p>This means that defining <code>CATCH_CONFIG_DEFAULT_REPORTER</code> to <code>\"console\"</code> is equivalent with the out-of-the-box experience.</p>"},{"location":"configuration/#bazel-support","title":"Bazel support","text":"<p>Compiling Catch2 with <code>CATCH_CONFIG_BAZEL_SUPPORT</code> force-enables Catch2's support for Bazel's environment variables (normally Catch2 looks for <code>BAZEL_TEST=1</code> env var first).</p> <p>This can be useful if you are using older versions of Bazel, that do not yet have <code>BAZEL_TEST</code> env var support.</p> <p><code>CATCH_CONFIG_BAZEL_SUPPORT</code> was introduced in Catch2 3.0.1.</p> <p><code>CATCH_CONFIG_BAZEL_SUPPORT</code> was deprecated in Catch2 3.1.0.</p>"},{"location":"configuration/#c11-toggles","title":"C++11 toggles","text":"<pre><code>CATCH_CONFIG_CPP11_TO_STRING // Use `std::to_string`\n</code></pre> <p>Because we support platforms whose standard library does not contain <code>std::to_string</code>, it is possible to force Catch to use a workaround based on <code>std::stringstream</code>. On platforms other than Android, the default is to use <code>std::to_string</code>. On Android, the default is to use the <code>stringstream</code> workaround. As always, it is possible to override Catch's selection, by defining either <code>CATCH_CONFIG_CPP11_TO_STRING</code> or <code>CATCH_CONFIG_NO_CPP11_TO_STRING</code>.</p>"},{"location":"configuration/#c17-toggles","title":"C++17 toggles","text":"<pre><code>CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS  // Override std::uncaught_exceptions (instead of std::uncaught_exception) support detection\nCATCH_CONFIG_CPP17_STRING_VIEW          // Override std::string_view support detection (Catch provides a StringMaker specialization by default)\nCATCH_CONFIG_CPP17_VARIANT              // Override std::variant support detection (checked by CATCH_CONFIG_ENABLE_VARIANT_STRINGMAKER)\nCATCH_CONFIG_CPP17_OPTIONAL             // Override std::optional support detection (checked by CATCH_CONFIG_ENABLE_OPTIONAL_STRINGMAKER)\nCATCH_CONFIG_CPP17_BYTE                 // Override std::byte support detection (Catch provides a StringMaker specialization by default)\n</code></pre> <p><code>CATCH_CONFIG_CPP17_STRING_VIEW</code> was introduced in Catch2 2.4.1.</p> <p>Catch contains basic compiler/standard detection and attempts to use some C++17 features whenever appropriate. This automatic detection can be manually overridden in both directions, that is, a feature can be enabled by defining the macro in the table above, and disabled by using <code>_NO_</code> in the macro, e.g. <code>CATCH_CONFIG_NO_CPP17_UNCAUGHT_EXCEPTIONS</code>.</p>"},{"location":"configuration/#other-toggles","title":"Other toggles","text":"<pre><code>CATCH_CONFIG_COUNTER                    // Use __COUNTER__ to generate unique names for test cases\nCATCH_CONFIG_WINDOWS_SEH                // Enable SEH handling on Windows\nCATCH_CONFIG_FAST_COMPILE               // Sacrifices some (rather minor) features for compilation speed\nCATCH_CONFIG_POSIX_SIGNALS              // Enable handling POSIX signals\nCATCH_CONFIG_WINDOWS_CRTDBG             // Enable leak checking using Windows's CRT Debug Heap\nCATCH_CONFIG_DISABLE_STRINGIFICATION    // Disable stringifying the original expression\nCATCH_CONFIG_DISABLE                    // Disables assertions and test case registration\nCATCH_CONFIG_WCHAR                      // Enables use of wchart_t\nCATCH_CONFIG_EXPERIMENTAL_REDIRECT      // Enables the new (experimental) way of capturing stdout/stderr\nCATCH_CONFIG_USE_ASYNC                  // Force parallel statistical processing of samples during benchmarking\nCATCH_CONFIG_ANDROID_LOGWRITE           // Use android's logging system for debug output\nCATCH_CONFIG_GLOBAL_NEXTAFTER           // Use nextafter{,f,l} instead of std::nextafter\nCATCH_CONFIG_GETENV                     // System has a working `getenv`\n</code></pre> <p><code>CATCH_CONFIG_ANDROID_LOGWRITE</code> and <code>CATCH_CONFIG_GLOBAL_NEXTAFTER</code> were introduced in Catch2 2.10.0</p> <p><code>CATCH_CONFIG_GETENV</code> was introduced in Catch2 3.2.0</p> <p>Currently Catch enables <code>CATCH_CONFIG_WINDOWS_SEH</code> only when compiled with MSVC, because some versions of MinGW do not have the necessary Win32 API support.</p> <p><code>CATCH_CONFIG_POSIX_SIGNALS</code> is on by default, except when Catch is compiled under <code>Cygwin</code>, where it is disabled by default (but can be force-enabled by defining <code>CATCH_CONFIG_POSIX_SIGNALS</code>).</p> <p><code>CATCH_CONFIG_GETENV</code> is on by default, except when Catch2 is compiled for platforms that lacks working <code>std::getenv</code> (currently Windows UWP and Playstation).</p> <p><code>CATCH_CONFIG_WINDOWS_CRTDBG</code> is off by default. If enabled, Windows's CRT is used to check for memory leaks, and displays them after the tests finish running. This option only works when linking against the default main, and must be defined for the whole library build.</p> <p><code>CATCH_CONFIG_WCHAR</code> is on by default, but can be disabled. Currently it is only used in support for DJGPP cross-compiler.</p> <p>With the exception of <code>CATCH_CONFIG_EXPERIMENTAL_REDIRECT</code>, these toggles can be disabled by using <code>_NO_</code> form of the toggle, e.g. <code>CATCH_CONFIG_NO_WINDOWS_SEH</code>.</p>"},{"location":"configuration/#catch_config_fast_compile","title":"<code>CATCH_CONFIG_FAST_COMPILE</code>","text":"<p>This compile-time flag speeds up compilation of assertion macros by ~20%, by disabling the generation of assertion-local try-catch blocks for non-exception family of assertion macros ({<code>REQUIRE</code>,<code>CHECK</code>}{<code>`,</code>_FALSE<code>,</code>_THAT`}). This disables translation of exceptions thrown under these assertions, but should not lead to false negatives.</p> <p><code>CATCH_CONFIG_FAST_COMPILE</code> has to be either defined, or not defined, in all translation units that are linked into single test binary.</p>"},{"location":"configuration/#catch_config_disable_stringification","title":"<code>CATCH_CONFIG_DISABLE_STRINGIFICATION</code>","text":"<p>This toggle enables a workaround for VS 2017 bug. For details see known limitations.</p>"},{"location":"configuration/#catch_config_disable","title":"<code>CATCH_CONFIG_DISABLE</code>","text":"<p>This toggle removes most of Catch from given file. This means that <code>TEST_CASE</code>s are not registered and assertions are turned into no-ops. Useful for keeping tests within implementation files (ie for functions with internal linkage), instead of in external files.</p> <p>This feature is considered experimental and might change at any point.</p> <p>Inspired by Doctest's <code>DOCTEST_CONFIG_DISABLE</code></p>"},{"location":"configuration/#enabling-stringification","title":"Enabling stringification","text":"<p>By default, Catch does not stringify some types from the standard library. This is done to avoid dragging in various standard library headers by default. However, Catch does contain these and can be configured to provide them, using these macros:</p> <pre><code>CATCH_CONFIG_ENABLE_PAIR_STRINGMAKER     // Provide StringMaker specialization for std::pair\nCATCH_CONFIG_ENABLE_TUPLE_STRINGMAKER    // Provide StringMaker specialization for std::tuple\nCATCH_CONFIG_ENABLE_VARIANT_STRINGMAKER  // Provide StringMaker specialization for std::variant, std::monostate (on C++17)\nCATCH_CONFIG_ENABLE_OPTIONAL_STRINGMAKER // Provide StringMaker specialization for std::optional (on C++17)\nCATCH_CONFIG_ENABLE_ALL_STRINGMAKERS     // Defines all of the above\n</code></pre> <p><code>CATCH_CONFIG_ENABLE_VARIANT_STRINGMAKER</code> was introduced in Catch2 2.4.1.</p> <p><code>CATCH_CONFIG_ENABLE_OPTIONAL_STRINGMAKER</code> was introduced in Catch2 2.6.0.</p>"},{"location":"configuration/#disabling-exceptions","title":"Disabling exceptions","text":"<p>Introduced in Catch2 2.4.0.</p> <p>By default, Catch2 uses exceptions to signal errors and to abort tests when an assertion from the <code>REQUIRE</code> family of assertions fails. We also provide an experimental support for disabling exceptions. Catch2 should automatically detect when it is compiled with exceptions disabled, but it can be forced to compile without exceptions by defining</p> <pre><code>CATCH_CONFIG_DISABLE_EXCEPTIONS\n</code></pre> <p>Note that when using Catch2 without exceptions, there are 2 major limitations:</p> <p>1) If there is an error that would normally be signalled by an exception, the exception's message will instead be written to <code>Catch::cerr</code> and <code>std::terminate</code> will be called. 2) If an assertion from the <code>REQUIRE</code> family of macros fails, <code>std::terminate</code> will be called after the active reporter returns.</p> <p>There is also a customization point for the exact behaviour of what happens instead of exception being thrown. To use it, define</p> <pre><code>CATCH_CONFIG_DISABLE_EXCEPTIONS_CUSTOM_HANDLER\n</code></pre> <p>and provide a definition for this function:</p> <pre><code>namespace Catch {\n[[noreturn]]\nvoid throw_exception(std::exception const&amp;);\n}\n</code></pre>"},{"location":"configuration/#overriding-catchs-debug-break-b","title":"Overriding Catch's debug break (<code>-b</code>)","text":"<p>Introduced in Catch2 2.11.2.</p> <p>You can override Catch2's break-into-debugger code by defining the <code>CATCH_BREAK_INTO_DEBUGGER()</code> macro. This can be used if e.g. Catch2 does not know your platform, or your platform is misdetected.</p> <p>The macro will be used as is, that is, <code>CATCH_BREAK_INTO_DEBUGGER();</code> must compile and must break into debugger.</p>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#contributing-to-catch2","title":"Contributing to Catch2","text":"<p>Contents Using Git(Hub) Testing your changes Writing documentation Writing code CoC</p> <p>So you want to contribute something to Catch2? That's great! Whether it's a bug fix, a new feature, support for additional compilers - or just a fix to the documentation - all contributions are very welcome and very much appreciated. Of course so are bug reports, other comments, and questions, but generally it is a better idea to ask questions in our Discord, than in the issue tracker.</p> <p>This page covers some guidelines and helpful tips for contributing to the codebase itself.</p>"},{"location":"contributing/#using-github","title":"Using Git(Hub)","text":"<p>Ongoing development happens in the <code>devel</code> branch for Catch2 v3, and in <code>v2.x</code> for maintenance updates to the v2 versions.</p> <p>Commits should be small and atomic. A commit is atomic when, after it is applied, the codebase, tests and all, still works as expected. Small commits are also preferred, as they make later operations with git history, whether it is bisecting, reverting, or something else, easier.</p> <p>When submitting a pull request please do not include changes to the amalgamated distribution files. This means do not include them in your git commits!</p> <p>When addressing review comments in a MR, please do not rebase/squash the commits immediately. Doing so makes it harder to review the new changes, slowing down the process of merging a MR. Instead, when addressing review comments, you should append new commits to the branch and only squash them into other commits when the MR is ready to be merged. We recommend creating new commits with <code>git commit --fixup</code> (or <code>--squash</code>) and then later squashing them with <code>git rebase --autosquash</code> to make things easier.</p>"},{"location":"contributing/#testing-your-changes","title":"Testing your changes","text":"<p>Note: Running Catch2's tests requires Python3</p> <p>Catch2 has multiple layers of tests that are then run as part of our CI. The most obvious one are the unit tests compiled into the <code>SelfTest</code> binary. These are then used in \"Approval tests\", which run (almost) all tests from <code>SelfTest</code> through a specific reporter and then compare the generated output with a known good output (\"Baseline\"). By default, new tests should be placed here.</p> <p>To configure a Catch2 build with just the basic tests, use the <code>basic-tests</code> preset, like so:</p> <pre><code># Assuming you are in Catch2's root folder\n\ncmake -B basic-test-build -S . -DCMAKE_BUILD_TYPE=Debug --preset basic-tests\n</code></pre> <p>However, not all tests can be written as plain unit tests. For example, checking that Catch2 orders tests randomly when asked to, and that this random ordering is subset-invariant, is better done as an integration test using an external check script. Catch2 integration tests are written using CTest, either as a direct command invocation + pass/fail regex, or by delegating the check to a Python script.</p> <p>Catch2 is slowly gaining more and more types of tests, currently Catch2 project also has buildable examples, \"ExtraTests\", and CMake config tests. Examples present a small and self-contained snippets of code that use Catch2's facilities for specific purpose. Currently they are assumed passing if they compile.</p> <p>ExtraTests then are expensive tests, that we do not want to run all the time. This can be either because they take a long time to run, or because they take a long time to compile, e.g. because they test compile time configuration and require separate compilation.</p> <p>Finally, CMake config tests test that you set Catch2's compile-time configuration options through CMake, using CMake options of the same name.</p> <p>These test categories can be enabled one by one, by passing <code>-DCATCH_BUILD_EXAMPLES=ON</code>, <code>-DCATCH_BUILD_EXTRA_TESTS=ON</code>, and <code>-DCATCH_ENABLE_CONFIGURE_TESTS=ON</code> when configuring the build.</p> <p>Catch2 also provides a preset that promises to enable all test types, <code>all-tests</code>.</p> <p>The snippet below will build &amp; run all tests, in <code>Debug</code> compilation mode.</p> <p> <pre><code># 1. Regenerate the amalgamated distribution (some tests are built against it)\n./tools/scripts/generateAmalgamatedFiles.py\n\n# 2. Configure the full test build\ncmake -B debug-build -S . -DCMAKE_BUILD_TYPE=Debug --preset all-tests\n\n# 3. Run the actual build\ncmake --build debug-build\n\n# 4. Run the tests using CTest\ncd debug-build\nctest -j 4 --output-on-failure -C Debug\n</code></pre> snippet source | anchor</p> <p>For convenience, the above commands are in the script <code>tools/scripts/buildAndTest.sh</code>, and can be run like this:</p> <pre><code>cd Catch2\n./tools/scripts/buildAndTest.sh\n</code></pre> <p>A Windows version of the script is available at <code>tools\\scripts\\buildAndTest.cmd</code>.</p> <p>If you added new tests, you will likely see <code>ApprovalTests</code> failure. After you check that the output difference is expected, you should run <code>tools/scripts/approve.py</code> to confirm them, and include these changes in your commit.</p>"},{"location":"contributing/#writing-documentation","title":"Writing documentation","text":"<p>If you have added new feature to Catch2, it needs documentation, so that other people can use it as well. This section collects some technical information that you will need for updating Catch2's documentation, and possibly some generic advise as well.</p> <p>We use mkdocs for documentation and poetry for python environment. first install poetry (you'll need python...) <pre><code>pip install poetry\n</code></pre> Poetry will install our docs dependencies <pre><code>poetry install\n</code></pre> serve the docs locally to see your changes <pre><code>poetry run mkdocs serve\n</code></pre></p>"},{"location":"contributing/#technicalities","title":"Technicalities","text":"<p>First, the technicalities:</p> <ul> <li> <p>If you have introduced a new document, there is a simple template you should use. It provides you with the top anchor mentioned to link to (more below), and also with a backlink to the top of the documentation: <pre><code>&lt;a id=\"top\"&gt;&lt;/a&gt;\n# Cool feature\n&gt; [Introduced](https://github.com/catchorg/Catch2/pull/123456) in Catch2 X.Y.Z\nText that explains how to use the cool feature.\n</code></pre></p> </li> <li> <p>Crosslinks to different pages should target the <code>top</code> anchor, like this <code>[link to contributing](contributing.md#top)</code>.</p> </li> <li> <p>We introduced version tags to the documentation, which show users in which version a specific feature was introduced. This means that newly written documentation should be tagged with a placeholder, that will be replaced with the actual version upon release. There are 2 styles of placeholders used through the documentation, you should pick one that fits your text better (if in doubt, take a look at the existing version tags for other features).</p> </li> <li><code>&gt; [Introduced](link-to-issue-or-PR) in Catch2 X.Y.Z</code> - this   placeholder is usually used after a section heading</li> <li><code>&gt; X (Y and Z) was [introduced](link-to-issue-or-PR) in Catch2 X.Y.Z</code></li> <li> <p>this placeholder is used when you need to tag a subpart of something,   e.g. a list</p> </li> <li> <p>For pages with more than 4 subheadings, we provide a table of contents (ToC) at the top of the page. Because GitHub markdown does not support automatic generation of ToC, it has to be handled semi-manually. Thus, if you've added a new subheading to some page, you should add it to the ToC. This can be done either manually, or by running the <code>updateDocumentToC.py</code> script in the <code>scripts/</code> folder.</p> </li> </ul>"},{"location":"contributing/#contents","title":"Contents","text":"<p>Now, for some content tips:</p> <ul> <li> <p>Usage examples are good. However, having large code snippets inline can make the documentation less readable, and so the inline snippets should be kept reasonably short. To provide more complex compilable examples, consider adding new .cpp file to <code>examples/</code>.</p> </li> <li> <p>Don't be afraid to introduce new pages. The current documentation tends towards long pages, but a lot of that is caused by legacy, and we know that some of the pages are overly big and unfocused.</p> </li> <li> <p>When adding information to an existing page, please try to keep your formatting, style and changes consistent with the rest of the page.</p> </li> <li> <p>Any documentation has multiple different audiences, that desire different information from the text. The 3 basic user-types to try and cover are:</p> </li> <li>A beginner to Catch2, who requires closer guidance for the usage of Catch2.</li> <li>Advanced user of Catch2, who want to customize their usage.</li> <li>Experts, looking for full reference of Catch2's capabilities.</li> </ul>"},{"location":"contributing/#writing-code","title":"Writing code","text":"<p>If want to contribute code, this section contains some simple rules and tips on things like code formatting, code constructions to avoid, and so on.</p>"},{"location":"contributing/#c-standard-version","title":"C++ standard version","text":"<p>Catch2 currently targets C++14 as the minimum supported C++ version. Features from higher language versions should be used only sparingly, when the benefits from using them outweigh the maintenance overhead.</p> <p>Example of good use of polyfilling features is our use of <code>conjunction</code>, where if available we use <code>std::conjunction</code> and otherwise provide our own implementation. The reason it is good is that the surface area for maintenance is quite small, and <code>std::conjunction</code> can directly use compiler built-ins, thus providing significant compilation benefits.</p> <p>Example of bad use of polyfilling features would be to keep around two sets of metaprogramming in the stringification implementation, once using C++14 compliant TMP and once using C++17's <code>if constexpr</code>. While the C++17 would provide significant compilation speedups, the maintenance cost would be too high.</p>"},{"location":"contributing/#formatting","title":"Formatting","text":"<p>To make code formatting simpler for the contributors, Catch2 provides its own config for <code>clang-format</code>. However, because it is currently impossible to replicate existing Catch2's formatting in clang-format, using it to reformat a whole file would cause massive diffs. To keep the size of your diffs reasonable, you should only use clang-format on the newly changed code.</p>"},{"location":"contributing/#code-constructs-to-watch-out-for","title":"Code constructs to watch out for","text":"<p>This section is a (sadly incomplete) listing of various constructs that are problematic and are not always caught by our CI infrastructure.</p>"},{"location":"contributing/#naked-exceptions-and-exceptions-related-function","title":"Naked exceptions and exceptions-related function","text":"<p>If you are throwing an exception, it should be done via <code>CATCH_ERROR</code> or <code>CATCH_RUNTIME_ERROR</code> in <code>internal/catch_enforce.hpp</code>. These macros will handle the differences between compilation with or without exceptions for you. However, some platforms (IAR) also have problems with exceptions-related functions, such as <code>std::current_exceptions</code>. We do not have IAR in our CI, but luckily there should not be too many reasons to use these. However, if you do, they should be kept behind a <code>CATCH_CONFIG_DISABLE_EXCEPTIONS</code> macro.</p>"},{"location":"contributing/#avoid-stdmove-and-stdforward","title":"Avoid <code>std::move</code> and <code>std::forward</code>","text":"<p><code>std::move</code> and <code>std::forward</code> provide nice semantic name for a specific <code>static_cast</code>. However, being function templates they have surprisingly high cost during compilation, and can also have a negative performance impact for low-optimization builds.</p> <p>You should be using <code>CATCH_MOVE</code> and <code>CATCH_FORWARD</code> macros from <code>internal/catch_move_and_forward.hpp</code> instead. They expand into the proper <code>static_cast</code>, and avoid the overhead of <code>std::move</code> and <code>std::forward</code>.</p>"},{"location":"contributing/#unqualified-usage-of-functions-from-cs-stdlib","title":"Unqualified usage of functions from C's stdlib","text":"<p>If you are using a function from C's stdlib, please include the header as <code>&lt;cfoo&gt;</code> and call the function qualified. The common knowledge that there is no difference is wrong, QNX and VxWorks won't compile if you include the header as <code>&lt;cfoo&gt;</code> and call the function unqualified.</p>"},{"location":"contributing/#user-defined-literals-udl-for-catch2-types","title":"User-Defined Literals (UDL) for Catch2' types","text":"<p>Due to messy standardese and ... not great ... implementation of <code>-Wreserved-identifier</code> in Clang, avoid declaring UDLs as <pre><code>Approx operator \"\" _a(long double);\n</code></pre> and instead declare them as <pre><code>Approx operator \"\"_a(long double);\n</code></pre></p> <p>Notice that the second version does not have a space between the <code>\"\"</code> and the literal suffix.</p>"},{"location":"contributing/#new-source-file-template","title":"New source file template","text":"<p>If you are adding new source file, there is a template you should use. Specifically, every source file should start with the licence header: <pre><code>    //              Copyright Catch2 Authors\n// Distributed under the Boost Software License, Version 1.0.\n//   (See accompanying file LICENSE.txt or copy at\n//        https://www.boost.org/LICENSE_1_0.txt)\n// SPDX-License-Identifier: BSL-1.0\n</code></pre></p> <p>The include guards for header files should follow the pattern <code>{FILENAME}_INCLUDED</code>. This means that for file <code>catch_matchers_foo.hpp</code>, the include guard should be <code>CATCH_MATCHERS_FOO_HPP_INCLUDED</code>, for <code>catch_generators_bar.hpp</code>, the include guard should be <code>CATCH_GENERATORS_BAR_HPP_INCLUDED</code>, and so on.</p>"},{"location":"contributing/#adding-new-catch_config-option","title":"Adding new <code>CATCH_CONFIG</code> option","text":"<p>When adding new <code>CATCH_CONFIG</code> option, there are multiple places to edit:   * <code>CMake/CatchConfigOptions.cmake</code> - this is used to generate the     configuration options in CMake, so that CMake frontends know about them.   * <code>docs/configuration.md</code> - this is where the options are documented   * <code>src/catch2/catch_user_config.hpp.in</code> - this is template for generating     <code>catch_user_config.hpp</code> which contains the materialized configuration   * <code>BUILD.bazel</code> - Bazel does not have configuration support like CMake,     and all expansions need to be done manually   * other files as needed, e.g. <code>catch2/internal/catch_config_foo.hpp</code>     for the logic that guards the configuration</p>"},{"location":"contributing/#coc","title":"CoC","text":"<p>This project has a CoC. Please adhere to it while contributing to Catch2.</p> <p>This documentation will always be in-progress as new information comes up, but we are trying to keep it as up to date as possible.</p>"},{"location":"deprecations/","title":"Deprecations","text":""},{"location":"deprecations/#deprecations-and-incoming-changes","title":"Deprecations and incoming changes","text":"<p>This page documents current deprecations and upcoming planned changes inside Catch2. The difference between these is that a deprecated feature will be removed, while a planned change to a feature means that the feature will behave differently, but will still be present. Obviously, either of these is a breaking change, and thus will not happen until at least the next major release.</p>"},{"location":"deprecations/#parseandaddcatchtestscmake","title":"<code>ParseAndAddCatchTests.cmake</code>","text":"<p>The CMake/CTest integration using <code>ParseAndAddCatchTests.cmake</code> is deprecated, as it can be replaced by <code>Catch.cmake</code> that provides the function <code>catch_discover_tests</code> to get tests directly from a CMake target via the command line interface instead of parsing C++ code with regular expressions.</p>"},{"location":"deprecations/#catch_config_bazel_support","title":"<code>CATCH_CONFIG_BAZEL_SUPPORT</code>","text":"<p>Catch2 supports writing the Bazel JUnit XML output file when it is aware that is within a bazel testing environment. Originally there was no way to accurately probe the environment for this information so the flag <code>CATCH_CONFIG_BAZEL_SUPPORT</code> was added. This now deprecated. Bazel has now had a change where it will export <code>BAZEL_TEST=1</code> for purposes like the above. Catch2 will now instead inspect the environment instead of relying on build configuration.</p>"},{"location":"deprecations/#ieventlisterskiptest-testcaseinfo-const-testinfo","title":"<code>IEventLister::skipTest( TestCaseInfo const&amp; testInfo )</code>","text":"<p>This event (including implementations in derived classes such as <code>ReporterBase</code>) is deprecated and will be removed in the next major release. It is currently invoked for all test cases that are not going to be executed due to the test run being aborted (when using <code>--abort</code> or <code>--abortx</code>). It is however NOT invoked for test cases that are explicitly skipped using the <code>SKIP</code> macro.</p>"},{"location":"event-listeners/","title":"Event listeners","text":""},{"location":"event-listeners/#event-listeners","title":"Event Listeners","text":"<p>An event listener is a bit like a reporter, in that it responds to various reporter events in Catch2, but it is not expected to write any output. Instead, an event listener performs actions within the test process, such as performing global initialization (e.g. of a C library), or cleaning out in-memory logs if they are not needed (the test case passed).</p> <p>Unlike reporters, each registered event listener is always active. Event listeners are always notified before reporter(s).</p> <p>To write your own event listener, you should derive from <code>Catch::TestEventListenerBase</code>, as it provides empty stubs for all reporter events, allowing you to only override events you care for. Afterwards you have to register it with Catch2 using <code>CATCH_REGISTER_LISTENER</code> macro, so that Catch2 knows about it and instantiates it before running tests.</p> <p>Example event listener: <pre><code>#include &lt;catch2/reporters/catch_reporter_event_listener.hpp&gt;\n#include &lt;catch2/reporters/catch_reporter_registrars.hpp&gt;\nclass testRunListener : public Catch::EventListenerBase {\npublic:\nusing Catch::EventListenerBase::EventListenerBase;\nvoid testRunStarting(Catch::TestRunInfo const&amp;) override {\nlib_foo_init();\n}\n};\nCATCH_REGISTER_LISTENER(testRunListener)\n</code></pre></p> <p>Note that you should not use any assertion macros within a Listener!</p> <p>You can find the list of events that the listeners can react to on its own page.</p>"},{"location":"faq/","title":"Faq","text":""},{"location":"faq/#frequently-asked-questions-faq","title":"Frequently Asked Questions (FAQ)","text":"<p>Contents How do I run global setup/teardown only if tests will be run? How do I clean up global state between running different tests? Why cannot I derive from the built-in reporters? What is Catch2's ABI stability policy? What is Catch2's API stability policy? Does Catch2 support running tests in parallel? Can I compile Catch2 into a dynamic library? What repeatability guarantees does Catch2 provide?</p>"},{"location":"faq/#how-do-i-run-global-setupteardown-only-if-tests-will-be-run","title":"How do I run global setup/teardown only if tests will be run?","text":"<p>Write a custom event listener and place the global setup/teardown code into the <code>testRun*</code> events.</p>"},{"location":"faq/#how-do-i-clean-up-global-state-between-running-different-tests","title":"How do I clean up global state between running different tests?","text":"<p>Write a custom event listener and place the cleanup code into either <code>testCase*</code> or <code>testCasePartial*</code> events, depending on how often the cleanup needs to happen.</p>"},{"location":"faq/#why-cannot-i-derive-from-the-built-in-reporters","title":"Why cannot I derive from the built-in reporters?","text":"<p>They are not made to be overridden, in that we do not attempt to maintain a consistent internal state if a member function is overridden, and by forbidding users from using them as a base class, we can refactor them as needed later.</p>"},{"location":"faq/#what-is-catch2s-abi-stability-policy","title":"What is Catch2's ABI stability policy?","text":"<p>Catch2 provides no ABI stability guarantees whatsoever. Catch2 provides rich C++ interface, and trying to freeze its ABI would take a lot of pointless work.</p> <p>Catch2 is not designed to be distributed as dynamic library, and you should really be able to compile everything with the same compiler binary.</p>"},{"location":"faq/#what-is-catch2s-api-stability-policy","title":"What is Catch2's API stability policy?","text":"<p>Catch2 follows semver to the best of our ability. This means that we will not knowingly make backwards-incompatible changes without incrementing the major version number.</p>"},{"location":"faq/#does-catch2-support-running-tests-in-parallel","title":"Does Catch2 support running tests in parallel?","text":"<p>Not natively, no. We see running tests in parallel as the job of an external test runner, that can also run them in separate processes, support test execution timeouts and so on.</p> <p>However, Catch2 provides some tools that make the job of external test runners easier. See the relevant section in our page on best practices.</p>"},{"location":"faq/#can-i-compile-catch2-into-a-dynamic-library","title":"Can I compile Catch2 into a dynamic library?","text":"<p>Yes, Catch2 supports the standard CMake <code>BUILD_SHARED_LIBS</code> option. However, the dynamic library support is provided as-is. Catch2 does not provide API export annotations, and so you can only use it as a dynamic library on platforms that default to public visibility, or with tooling support to force export Catch2's API.</p>"},{"location":"faq/#what-repeatability-guarantees-does-catch2-provide","title":"What repeatability guarantees does Catch2 provide?","text":"<p>There are two places where it is meaningful to talk about Catch2's repeatability guarantees without taking into account user-provided code. First one is in the test case shuffling, and the second one is the output from random generators.</p> <p>Test case shuffling is repeatable across different platforms since v2.12.0, and it is also generally repeatable across versions, but we might break it from time to time. E.g. we broke repeatability with previous versions in v2.13.4 so that test cases with similar names are shuffled better.</p> <p>Random generators currently rely on platform's stdlib, specifically the distributions from <code>&lt;random&gt;</code>. We thus provide no extra guarantee above what your platform does. Important: <code>&lt;random&gt;</code>'s distributions are not specified to be repeatable across different platforms.</p>"},{"location":"generators/","title":"Generators","text":""},{"location":"generators/#data-generators","title":"Data Generators","text":"<p>Introduced in Catch2 2.6.0.</p> <p>Data generators (also known as data driven/parametrized test cases) let you reuse the same set of assertions across different input values. In Catch2, this means that they respect the ordering and nesting of the <code>TEST_CASE</code> and <code>SECTION</code> macros, and their nested sections are run once per each value in a generator.</p> <p>This is best explained with an example: <pre><code>TEST_CASE(\"Generators\") {\nauto i = GENERATE(1, 3, 5);\nREQUIRE(is_odd(i));\n}\n</code></pre></p> <p>The \"Generators\" <code>TEST_CASE</code> will be entered 3 times, and the value of <code>i</code> will be 1, 3, and 5 in turn. <code>GENERATE</code>s can also be used multiple times at the same scope, in which case the result will be a cartesian product of all elements in the generators. This means that in the snippet below, the test case will be run 6 (2*3) times.</p> <pre><code>TEST_CASE(\"Generators\") {\nauto i = GENERATE(1, 2);\nauto j = GENERATE(3, 4, 5);\n}\n</code></pre> <p>There are 2 parts to generators in Catch2, the <code>GENERATE</code> macro together with the already provided generators, and the <code>IGenerator&lt;T&gt;</code> interface that allows users to implement their own generators.</p>"},{"location":"generators/#combining-generate-and-section","title":"Combining <code>GENERATE</code> and <code>SECTION</code>.","text":"<p><code>GENERATE</code> can be seen as an implicit <code>SECTION</code>, that goes from the place <code>GENERATE</code> is used, to the end of the scope. This can be used for various effects. The simplest usage is shown below, where the <code>SECTION</code> \"one\" runs 4 (2*2) times, and <code>SECTION</code> \"two\" is run 6 times (2*3).</p> <pre><code>TEST_CASE(\"Generators\") {\nauto i = GENERATE(1, 2);\nSECTION(\"one\") {\nauto j = GENERATE(-3, -2);\nREQUIRE(j &lt; i);\n}\nSECTION(\"two\") {\nauto k = GENERATE(4, 5, 6);\nREQUIRE(i != k);\n}\n}\n</code></pre> <p>The specific order of the <code>SECTION</code>s will be \"one\", \"one\", \"two\", \"two\", \"two\", \"one\"...</p> <p>The fact that <code>GENERATE</code> introduces a virtual <code>SECTION</code> can also be used to make a generator replay only some <code>SECTION</code>s, without having to explicitly add a <code>SECTION</code>. As an example, the code below reports 3 assertions, because the \"first\" section is run once, but the \"second\" section is run twice.</p> <pre><code>TEST_CASE(\"GENERATE between SECTIONs\") {\nSECTION(\"first\") { REQUIRE(true); }\nauto _ = GENERATE(1, 2);\nSECTION(\"second\") { REQUIRE(true); }\n}\n</code></pre> <p>This can lead to surprisingly complex test flows. As an example, the test below will report 14 assertions:</p> <pre><code>TEST_CASE(\"Complex mix of sections and generates\") {\nauto i = GENERATE(1, 2);\nSECTION(\"A\") {\nSUCCEED(\"A\");\n}\nauto j = GENERATE(3, 4);\nSECTION(\"B\") {\nSUCCEED(\"B\");\n}\nauto k = GENERATE(5, 6);\nSUCCEED();\n}\n</code></pre> <p>The ability to place <code>GENERATE</code> between two <code>SECTION</code>s was introduced in Catch2 2.13.0.</p>"},{"location":"generators/#provided-generators","title":"Provided generators","text":"<p>Catch2's provided generator functionality consists of three parts,</p> <ul> <li><code>GENERATE</code> macro,  that serves to integrate generator expression with a test case,</li> <li>2 fundamental generators</li> <li><code>SingleValueGenerator&lt;T&gt;</code> -- contains only single element</li> <li><code>FixedValuesGenerator&lt;T&gt;</code> -- contains multiple elements</li> <li>5 generic generators that modify other generators</li> <li><code>FilterGenerator&lt;T, Predicate&gt;</code> -- filters out elements from a generator   for which the predicate returns \"false\"</li> <li><code>TakeGenerator&lt;T&gt;</code> -- takes first <code>n</code> elements from a generator</li> <li><code>RepeatGenerator&lt;T&gt;</code> -- repeats output from a generator <code>n</code> times</li> <li><code>MapGenerator&lt;T, U, Func&gt;</code> -- returns the result of applying <code>Func</code>   on elements from a different generator</li> <li><code>ChunkGenerator&lt;T&gt;</code> -- returns chunks (inside <code>std::vector</code>) of n elements from a generator</li> <li>4 specific purpose generators</li> <li><code>RandomIntegerGenerator&lt;Integral&gt;</code> -- generates random Integrals from range</li> <li><code>RandomFloatGenerator&lt;Float&gt;</code> -- generates random Floats from range</li> <li><code>RangeGenerator&lt;T&gt;(first, last)</code> -- generates all values inside a <code>[first, last)</code> arithmetic range</li> <li><code>IteratorGenerator&lt;T&gt;</code> -- copies and returns values from an iterator range</li> </ul> <p><code>ChunkGenerator&lt;T&gt;</code>, <code>RandomIntegerGenerator&lt;Integral&gt;</code>, <code>RandomFloatGenerator&lt;Float&gt;</code> and <code>RangeGenerator&lt;T&gt;</code> were introduced in Catch2 2.7.0.</p> <p><code>IteratorGenerator&lt;T&gt;</code> was introduced in Catch2 2.10.0.</p> <p>The generators also have associated helper functions that infer their type, making their usage much nicer. These are</p> <ul> <li><code>value(T&amp;&amp;)</code> for <code>SingleValueGenerator&lt;T&gt;</code></li> <li><code>values(std::initializer_list&lt;T&gt;)</code> for <code>FixedValuesGenerator&lt;T&gt;</code></li> <li><code>table&lt;Ts...&gt;(std::initializer_list&lt;std::tuple&lt;Ts...&gt;&gt;)</code> for <code>FixedValuesGenerator&lt;std::tuple&lt;Ts...&gt;&gt;</code></li> <li><code>filter(predicate, GeneratorWrapper&lt;T&gt;&amp;&amp;)</code> for <code>FilterGenerator&lt;T, Predicate&gt;</code></li> <li><code>take(count, GeneratorWrapper&lt;T&gt;&amp;&amp;)</code> for <code>TakeGenerator&lt;T&gt;</code></li> <li><code>repeat(repeats, GeneratorWrapper&lt;T&gt;&amp;&amp;)</code> for <code>RepeatGenerator&lt;T&gt;</code></li> <li><code>map(func, GeneratorWrapper&lt;T&gt;&amp;&amp;)</code> for <code>MapGenerator&lt;T, U, Func&gt;</code> (map <code>U</code> to <code>T</code>, deduced from <code>Func</code>)</li> <li><code>map&lt;T&gt;(func, GeneratorWrapper&lt;U&gt;&amp;&amp;)</code> for <code>MapGenerator&lt;T, U, Func&gt;</code> (map <code>U</code> to <code>T</code>)</li> <li><code>chunk(chunk-size, GeneratorWrapper&lt;T&gt;&amp;&amp;)</code> for <code>ChunkGenerator&lt;T&gt;</code></li> <li><code>random(IntegerOrFloat a, IntegerOrFloat b)</code> for <code>RandomIntegerGenerator</code> or <code>RandomFloatGenerator</code></li> <li><code>range(Arithmetic start, Arithmetic end)</code> for <code>RangeGenerator&lt;Arithmetic&gt;</code> with a step size of <code>1</code></li> <li><code>range(Arithmetic start, Arithmetic end, Arithmetic step)</code> for <code>RangeGenerator&lt;Arithmetic&gt;</code> with a custom step size</li> <li><code>from_range(InputIterator from, InputIterator to)</code> for <code>IteratorGenerator&lt;T&gt;</code></li> <li><code>from_range(Container const&amp;)</code> for <code>IteratorGenerator&lt;T&gt;</code></li> </ul> <p><code>chunk()</code>, <code>random()</code> and both <code>range()</code> functions were introduced in Catch2 2.7.0.</p> <p><code>from_range</code> has been introduced in Catch2 2.10.0</p> <p><code>range()</code> for floating point numbers has been introduced in Catch2 2.11.0</p> <p>And can be used as shown in the example below to create a generator that returns 100 odd random number:</p> <pre><code>TEST_CASE(\"Generating random ints\", \"[example][generator]\") {\nSECTION(\"Deducing functions\") {\nauto i = GENERATE(take(100, filter([](int i) { return i % 2 == 1; }, random(-100, 100))));\nREQUIRE(i &gt; -100);\nREQUIRE(i &lt; 100);\nREQUIRE(i % 2 == 1);\n}\n}\n</code></pre> <p>Apart from registering generators with Catch2, the <code>GENERATE</code> macro has one more purpose, and that is to provide simple way of generating trivial generators, as seen in the first example on this page, where we used it as <code>auto i = GENERATE(1, 2, 3);</code>. This usage converted each of the three literals into a single <code>SingleValueGenerator&lt;int&gt;</code> and then placed them all in a special generator that concatenates other generators. It can also be used with other generators as arguments, such as <code>auto i = GENERATE(0, 2, take(100, random(300, 3000)));</code>. This is useful e.g. if you know that specific inputs are problematic and want to test them separately/first.</p> <p>For safety reasons, you cannot use variables inside the <code>GENERATE</code> macro. This is done because the generator expression will outlive the outside scope and thus capturing references is dangerous. If you need to use variables inside the generator expression, make sure you thought through the lifetime implications and use <code>GENERATE_COPY</code> or <code>GENERATE_REF</code>.</p> <p><code>GENERATE_COPY</code> and <code>GENERATE_REF</code> were introduced in Catch2 2.7.1.</p> <p>You can also override the inferred type by using <code>as&lt;type&gt;</code> as the first argument to the macro. This can be useful when dealing with string literals, if you want them to come out as <code>std::string</code>:</p> <pre><code>TEST_CASE(\"type conversion\", \"[generators]\") {\nauto str = GENERATE(as&lt;std::string&gt;{}, \"a\", \"bb\", \"ccc\");\nREQUIRE(str.size() &gt; 0);\n}\n</code></pre>"},{"location":"generators/#generator-interface","title":"Generator interface","text":"<p>You can also implement your own generators, by deriving from the <code>IGenerator&lt;T&gt;</code> interface:</p> <pre><code>template&lt;typename T&gt;\nstruct IGenerator : GeneratorUntypedBase {\n// via GeneratorUntypedBase:\n// Attempts to move the generator to the next element.\n// Returns true if successful (and thus has another element that can be read)\nvirtual bool next() = 0;\n// Precondition:\n// The generator is either freshly constructed or the last call to next() returned true\nvirtual T const&amp; get() const = 0;\n// Returns user-friendly string showing the current generator element\n// Does not have to be overridden, IGenerator provides default implementation\nvirtual std::string stringifyImpl() const;\n};\n</code></pre> <p>However, to be able to use your custom generator inside <code>GENERATE</code>, it will need to be wrapped inside a <code>GeneratorWrapper&lt;T&gt;</code>. <code>GeneratorWrapper&lt;T&gt;</code> is a value wrapper around a <code>Catch::Detail::unique_ptr&lt;IGenerator&lt;T&gt;&gt;</code>.</p> <p>For full example of implementing your own generator, look into Catch2's examples, specifically Generators: Create your own generator.</p>"},{"location":"generators/#handling-empty-generators","title":"Handling empty generators","text":"<p>The generator interface assumes that a generator always has at least one element. This is not always true, e.g. if the generator depends on an external datafile, the file might be missing.</p> <p>There are two ways to handle this, depending on whether you want this to be an error or not.</p> <ul> <li>If empty generator is an error, throw an exception in constructor.</li> <li>If empty generator is not an error, use the <code>SKIP</code> in constructor.</li> </ul> <p>Home</p>"},{"location":"limitations/","title":"Limitations","text":""},{"location":"limitations/#known-limitations","title":"Known limitations","text":"<p>Over time, some limitations of Catch2 emerged. Some of these are due to implementation details that cannot be easily changed, some of these are due to lack of development resources on our part, and some of these are due to plain old 3rd party bugs.</p>"},{"location":"limitations/#implementation-limits","title":"Implementation limits","text":""},{"location":"limitations/#sections-nested-in-loops","title":"Sections nested in loops","text":"<p>If you are using <code>SECTION</code>s inside loops, you have to create them with different name per loop's iteration. The recommended way to do so is to incorporate the loop's counter into section's name, like so:</p> <pre><code>TEST_CASE( \"Looped section\" ) {\nfor (char i = '0'; i &lt; '5'; ++i) {\nSECTION(std::string(\"Looped section \") + i) {\nSUCCEED( \"Everything is OK\" );\n}\n}\n}\n</code></pre> <p>or with a <code>DYNAMIC_SECTION</code> macro (that was made for exactly this purpose):</p> <pre><code>TEST_CASE( \"Looped section\" ) {\nfor (char i = '0'; i &lt; '5'; ++i) {\nDYNAMIC_SECTION( \"Looped section \" &lt;&lt; i) {\nSUCCEED( \"Everything is OK\" );\n}\n}\n}\n</code></pre>"},{"location":"limitations/#tests-might-be-run-again-if-last-section-fails","title":"Tests might be run again if last section fails","text":"<p>If the last section in a test fails, it might be run again. This is because Catch2 discovers <code>SECTION</code>s dynamically, as they are about to run, and if the last section in test case is aborted during execution (e.g. via the <code>REQUIRE</code> family of macros), Catch2 does not know that there are no more sections in that test case and must run the test case again.</p>"},{"location":"limitations/#mingwcygwin-compilation-linking-is-extremely-slow","title":"MinGW/CygWin compilation (linking) is extremely slow","text":"<p>Compiling Catch2 with MinGW can be exceedingly slow, especially during the linking step. As far as we can tell, this is caused by deficiencies in its default linker. If you can tell MinGW to instead use lld, via <code>-fuse-ld=lld</code>, the link time should drop down to reasonable length again.</p>"},{"location":"limitations/#features","title":"Features","text":"<p>This section outlines some missing features, what is their status and their possible workarounds.</p>"},{"location":"limitations/#thread-safe-assertions","title":"Thread safe assertions","text":"<p>Catch2's assertion macros are not thread safe. This does not mean that you cannot use threads inside Catch's test, but that only single thread can interact with Catch's assertions and other macros.</p> <p>This means that this is ok <pre><code>    std::vector&lt;std::thread&gt; threads;\nstd::atomic&lt;int&gt; cnt{ 0 };\nfor (int i = 0; i &lt; 4; ++i) {\nthreads.emplace_back([&amp;]() {\n++cnt; ++cnt; ++cnt; ++cnt;\n});\n}\nfor (auto&amp; t : threads) { t.join(); }\nREQUIRE(cnt == 16);\n</code></pre> because only one thread passes the <code>REQUIRE</code> macro and this is not <pre><code>    std::vector&lt;std::thread&gt; threads;\nstd::atomic&lt;int&gt; cnt{ 0 };\nfor (int i = 0; i &lt; 4; ++i) {\nthreads.emplace_back([&amp;]() {\n++cnt; ++cnt; ++cnt; ++cnt;\nCHECK(cnt == 16);\n});\n}\nfor (auto&amp; t : threads) { t.join(); }\nREQUIRE(cnt == 16);\n</code></pre></p> <p>We currently do not plan to support thread-safe assertions.</p>"},{"location":"limitations/#process-isolation-in-a-test","title":"Process isolation in a test","text":"<p>Catch does not support running tests in isolated (forked) processes. While this might in the future, the fact that Windows does not support forking and only allows full-on process creation and the desire to keep code as similar as possible across platforms, mean that this is likely to take significant development time, that is not currently available.</p>"},{"location":"limitations/#running-multiple-tests-in-parallel","title":"Running multiple tests in parallel","text":"<p>Catch2 keeps test execution in one process strictly serial, and there are no plans to change this. If you find yourself with a test suite that takes too long to run and you want to make it parallel, you have to run multiple processes side by side.</p> <p>There are 2 basic ways to do that, * you can split your tests into multiple binaries, and run those binaries   in parallel * you can run the same test binary multiple times, but run a different   subset of the tests in each process</p> <p>There are multiple ways to achieve the latter, the easiest way is to use test sharding.</p>"},{"location":"limitations/#3rd-party-bugs","title":"3rd party bugs","text":"<p>This section outlines known bugs in 3rd party components (this means compilers, standard libraries, standard runtimes).</p>"},{"location":"limitations/#visual-studio-2017-raw-string-literal-in-assert-fails-to-compile","title":"Visual Studio 2017 -- raw string literal in assert fails to compile","text":"<p>There is a known bug in Visual Studio 2017 (VC 15), that causes compilation error when preprocessor attempts to stringize a raw string literal (<code>#</code> preprocessor directive is applied to it). This snippet is sufficient to trigger the compilation error:</p> <pre><code>#include &lt;catch2/catch_test_macros.hpp&gt;\nTEST_CASE(\"test\") {\nCHECK(std::string(R\"(\"\\)\") == \"\\\"\\\\\");\n}\n</code></pre> <p>Catch2 provides a workaround, by letting the user disable stringification of the original expression by defining <code>CATCH_CONFIG_DISABLE_STRINGIFICATION</code>, like so: <pre><code>#define CATCH_CONFIG_DISABLE_STRINGIFICATION\n#include &lt;catch2/catch_test_macros.hpp&gt;\nTEST_CASE(\"test\") {\nCHECK(std::string(R\"(\"\\)\") == \"\\\"\\\\\");\n}\n</code></pre></p> <p>Do note that this changes the output: <pre><code>catchwork\\test1.cpp(6):\nPASSED:\n  CHECK( Disabled by CATCH_CONFIG_DISABLE_STRINGIFICATION )\nwith expansion:\n  \"\"\\\" == \"\"\\\"\n</code></pre></p>"},{"location":"limitations/#clangg-skipping-leaf-sections-after-an-exception","title":"Clang/G++ -- skipping leaf sections after an exception","text":"<p>Some versions of <code>libc++</code> and <code>libstdc++</code> (or their runtimes) have a bug with <code>std::uncaught_exception()</code> getting stuck returning <code>true</code> after rethrow, even if there are no active exceptions. One such case is this snippet, which skipped the sections \"a\" and \"b\", when compiled against <code>libcxxrt</code> from the master branch <pre><code>#include &lt;catch2/catch_test_macros.hpp&gt;\nTEST_CASE(\"a\") {\nCHECK_THROWS(throw 3);\n}\nTEST_CASE(\"b\") {\nint i = 0;\nSECTION(\"a\") { i = 1; }\nSECTION(\"b\") { i = 2; }\nCHECK(i &gt; 0);\n}\n</code></pre></p> <p>If you are seeing a problem like this, i.e. weird test paths that trigger only under Clang with <code>libc++</code>, or only under very specific version of <code>libstdc++</code>, it is very likely you are seeing this. The only known workaround is to use a fixed version of your standard library.</p>"},{"location":"limitations/#libstdc-_glibcxx_debug-macro-and-random-ordering-of-tests","title":"libstdc++, <code>_GLIBCXX_DEBUG</code> macro and random ordering of tests","text":"<p>Running a Catch2 binary compiled against libstdc++ with <code>_GLIBCXX_DEBUG</code> macro defined with <code>--order rand</code> will cause a debug check to trigger and abort the run due to self-assignment. This is a known bug inside libstdc++</p> <p>Workaround: Don't use <code>--order rand</code> when compiling against debug-enabled libstdc++.</p>"},{"location":"list-of-examples/","title":"List of examples","text":""},{"location":"list-of-examples/#list-of-examples","title":"List of examples","text":""},{"location":"list-of-examples/#already-available","title":"Already available","text":""},{"location":"list-of-examples/#test-case-single-file","title":"Test Case: Single-file","text":"<pre><code>// 010-TestCase.cpp\n// And write tests in the same file:\n#include &lt;catch2/catch_test_macros.hpp&gt;\nstatic int Factorial( int number ) {\nreturn number &lt;= 1 ? number : Factorial( number - 1 ) * number;  // fail\n// return number &lt;= 1 ? 1      : Factorial( number - 1 ) * number;  // pass\n}\nTEST_CASE( \"Factorial of 0 is 1 (fail)\", \"[single-file]\" ) {\nREQUIRE( Factorial(0) == 1 );\n}\nTEST_CASE( \"Factorials of 1 and higher are computed (pass)\", \"[single-file]\" ) {\nREQUIRE( Factorial(1) == 1 );\nREQUIRE( Factorial(2) == 2 );\nREQUIRE( Factorial(3) == 6 );\nREQUIRE( Factorial(10) == 3628800 );\n}\n// Compile &amp; run:\n// - g++ -std=c++14 -Wall -I$(CATCH_SINGLE_INCLUDE) -o 010-TestCase 010-TestCase.cpp &amp;&amp; 010-TestCase --success\n// - cl -EHsc -I%CATCH_SINGLE_INCLUDE% 010-TestCase.cpp &amp;&amp; 010-TestCase --success\n// Expected compact output (all assertions):\n//\n// prompt&gt; 010-TestCase --reporter compact --success\n// 010-TestCase.cpp:14: failed: Factorial(0) == 1 for: 0 == 1\n// 010-TestCase.cpp:18: passed: Factorial(1) == 1 for: 1 == 1\n// 010-TestCase.cpp:19: passed: Factorial(2) == 2 for: 2 == 2\n// 010-TestCase.cpp:20: passed: Factorial(3) == 6 for: 6 == 6\n// 010-TestCase.cpp:21: passed: Factorial(10) == 3628800 for: 3628800 (0x375f00) == 3628800 (0x375f00)\n// Failed 1 test case, failed 1 assertion.\n</code></pre>"},{"location":"list-of-examples/#test-case-multiple-files","title":"Test Case: Multiple-files","text":"File 1File 2 <pre><code>// 020-TestCase-1.cpp\n#include &lt;catch2/catch_test_macros.hpp&gt;\nTEST_CASE( \"1: All test cases reside in other .cpp files (empty)\", \"[multi-file:1]\" ) {\n}\n// ^^^\n// Normally no TEST_CASEs in this file.\n// Here just to show there are two source files via option --list-tests.\n// Compile &amp; run:\n// - g++ -std=c++14 -Wall -I$(CATCH_SINGLE_INCLUDE) -c 020-TestCase-1.cpp\n// - g++ -std=c++14 -Wall -I$(CATCH_SINGLE_INCLUDE) -o 020-TestCase TestCase-1.o 020-TestCase-2.cpp &amp;&amp; 020-TestCase --success\n//\n// - cl -EHsc -I%CATCH_SINGLE_INCLUDE% -c 020-TestCase-1.cpp\n// - cl -EHsc -I%CATCH_SINGLE_INCLUDE% -Fe020-TestCase.exe 020-TestCase-1.obj 020-TestCase-2.cpp &amp;&amp; 020-TestCase --success\n// Expected test case listing:\n//\n// prompt&gt; 020-TestCase --list-tests *\n// Matching test cases:\n//   1: All test cases reside in other .cpp files (empty)\n//       [multi-file:1]\n//   2: Factorial of 0 is computed (fail)\n//       [multi-file:2]\n//   2: Factorials of 1 and higher are computed (pass)\n//       [multi-file:2]\n// 3 matching test cases\n</code></pre> <pre><code>// 020-TestCase-2.cpp\n// main() provided by Catch in file 020-TestCase-1.cpp.\n#include &lt;catch2/catch_test_macros.hpp&gt;\nstatic int Factorial( int number ) {\nreturn number &lt;= 1 ? number : Factorial( number - 1 ) * number;  // fail\n// return number &lt;= 1 ? 1      : Factorial( number - 1 ) * number;  // pass\n}\nTEST_CASE( \"2: Factorial of 0 is 1 (fail)\", \"[multi-file:2]\" ) {\nREQUIRE( Factorial(0) == 1 );\n}\nTEST_CASE( \"2: Factorials of 1 and higher are computed (pass)\", \"[multi-file:2]\" ) {\nREQUIRE( Factorial(1) == 1 );\nREQUIRE( Factorial(2) == 2 );\nREQUIRE( Factorial(3) == 6 );\nREQUIRE( Factorial(10) == 3628800 );\n}\n// Compile: see 020-TestCase-1.cpp\n// Expected compact output (all assertions):\n//\n// prompt&gt; 020-TestCase --reporter compact --success\n// 020-TestCase-2.cpp:13: failed: Factorial(0) == 1 for: 0 == 1\n// 020-TestCase-2.cpp:17: passed: Factorial(1) == 1 for: 1 == 1\n// 020-TestCase-2.cpp:18: passed: Factorial(2) == 2 for: 2 == 2\n// 020-TestCase-2.cpp:19: passed: Factorial(3) == 6 for: 6 == 6\n// 020-TestCase-2.cpp:20: passed: Factorial(10) == 3628800 for: 3628800 (0x375f00) == 3628800 (0x375f00)\n// Failed 1 test case, failed 1 assertion.\n</code></pre>"},{"location":"list-of-examples/#assertion-require-check","title":"Assertion (REQUIRE, CHECK)","text":"<pre><code>// 030-Asn-Require-Check.cpp\n// Catch has two natural expression assertion macro's:\n// - REQUIRE() stops at first failure.\n// - CHECK() continues after failure.\n// There are two variants to support decomposing negated expressions:\n// - REQUIRE_FALSE() stops at first failure.\n// - CHECK_FALSE() continues after failure.\n// main() provided by linkage to Catch2WithMain\n#include &lt;catch2/catch_test_macros.hpp&gt;\nstatic std::string one() {\nreturn \"1\";\n}\nTEST_CASE( \"Assert that something is true (pass)\", \"[require]\" ) {\nREQUIRE( one() == \"1\" );\n}\nTEST_CASE( \"Assert that something is true (fail)\", \"[require]\" ) {\nREQUIRE( one() == \"x\" );\n}\nTEST_CASE( \"Assert that something is true (stop at first failure)\", \"[require]\" ) {\nWARN( \"REQUIRE stops at first failure:\" );\nREQUIRE( one() == \"x\" );\nREQUIRE( one() == \"1\" );\n}\nTEST_CASE( \"Assert that something is true (continue after failure)\", \"[check]\" ) {\nWARN( \"CHECK continues after failure:\" );\nCHECK(   one() == \"x\" );\nREQUIRE( one() == \"1\" );\n}\nTEST_CASE( \"Assert that something is false (stops at first failure)\", \"[require-false]\" ) {\nWARN( \"REQUIRE_FALSE stops at first failure:\" );\nREQUIRE_FALSE( one() == \"1\" );\nREQUIRE_FALSE( one() != \"1\" );\n}\nTEST_CASE( \"Assert that something is false (continue after failure)\", \"[check-false]\" ) {\nWARN( \"CHECK_FALSE continues after failure:\" );\nCHECK_FALSE(   one() == \"1\" );\nREQUIRE_FALSE( one() != \"1\" );\n}\n// Compile &amp; run:\n// - g++ -std=c++14 -Wall -I$(CATCH_SINGLE_INCLUDE) -o 030-Asn-Require-Check 030-Asn-Require-Check.cpp &amp;&amp; 030-Asn-Require-Check --success\n// - cl -EHsc -I%CATCH_SINGLE_INCLUDE% 030-Asn-Require-Check.cpp &amp;&amp; 030-Asn-Require-Check --success\n// Expected compact output (all assertions):\n//\n// prompt&gt; 030-Asn-Require-Check.exe --reporter compact --success\n// 030-Asn-Require-Check.cpp:20: passed: one() == \"1\" for: \"1\" == \"1\"\n// 030-Asn-Require-Check.cpp:24: failed: one() == \"x\" for: \"1\" == \"x\"\n// 030-Asn-Require-Check.cpp:28: warning: 'REQUIRE stops at first failure:'\n// 030-Asn-Require-Check.cpp:30: failed: one() == \"x\" for: \"1\" == \"x\"\n// 030-Asn-Require-Check.cpp:35: warning: 'CHECK continues after failure:'\n// 030-Asn-Require-Check.cpp:37: failed: one() == \"x\" for: \"1\" == \"x\"\n// 030-Asn-Require-Check.cpp:38: passed: one() == \"1\" for: \"1\" == \"1\"\n// 030-Asn-Require-Check.cpp:42: warning: 'REQUIRE_FALSE stops at first failure:'\n// 030-Asn-Require-Check.cpp:44: failed: !(one() == \"1\") for: !(\"1\" == \"1\")\n// 030-Asn-Require-Check.cpp:49: warning: 'CHECK_FALSE continues after failure:'\n// 030-Asn-Require-Check.cpp:51: failed: !(one() == \"1\") for: !(\"1\" == \"1\")\n// 030-Asn-Require-Check.cpp:52: passed: !(one() != \"1\") for: !(\"1\" != \"1\")\n// Failed 5 test cases, failed 5 assertions.\n</code></pre>"},{"location":"list-of-examples/#fixtures","title":"Fixtures","text":""},{"location":"list-of-examples/#sections","title":"Sections","text":"<pre><code>// 100-Fix-Section.cpp\n// Catch has two ways to express fixtures:\n// - Sections (this file)\n// - Traditional class-based fixtures\n// main() provided by linkage to Catch2WithMain\n#include &lt;catch2/catch_test_macros.hpp&gt;\n#include &lt;vector&gt;\nTEST_CASE( \"vectors can be sized and resized\", \"[vector]\" ) {\n// For each section, vector v is anew:\nstd::vector&lt;int&gt; v( 5 );\nREQUIRE( v.size() == 5 );\nREQUIRE( v.capacity() &gt;= 5 );\nSECTION( \"resizing bigger changes size and capacity\" ) {\nv.resize( 10 );\nREQUIRE( v.size() == 10 );\nREQUIRE( v.capacity() &gt;= 10 );\n}\nSECTION( \"resizing smaller changes size but not capacity\" ) {\nv.resize( 0 );\nREQUIRE( v.size() == 0 );\nREQUIRE( v.capacity() &gt;= 5 );\n}\nSECTION( \"reserving bigger changes capacity but not size\" ) {\nv.reserve( 10 );\nREQUIRE( v.size() == 5 );\nREQUIRE( v.capacity() &gt;= 10 );\n}\nSECTION( \"reserving smaller does not change size or capacity\" ) {\nv.reserve( 0 );\nREQUIRE( v.size() == 5 );\nREQUIRE( v.capacity() &gt;= 5 );\n}\n}\n// Compile &amp; run:\n// - g++ -std=c++14 -Wall -I$(CATCH_SINGLE_INCLUDE) -o 100-Fix-Section 100-Fix-Section.cpp &amp;&amp; 100-Fix-Section --success\n// - cl -EHsc -I%CATCH_SINGLE_INCLUDE% 100-Fix-Section.cpp &amp;&amp; 100-Fix-Section --success\n// Expected compact output (all assertions):\n//\n// prompt&gt; 100-Fix-Section.exe --reporter compact --success\n// 100-Fix-Section.cpp:17: passed: v.size() == 5 for: 5 == 5\n// 100-Fix-Section.cpp:18: passed: v.capacity() &gt;= 5 for: 5 &gt;= 5\n// 100-Fix-Section.cpp:23: passed: v.size() == 10 for: 10 == 10\n// 100-Fix-Section.cpp:24: passed: v.capacity() &gt;= 10 for: 10 &gt;= 10\n// 100-Fix-Section.cpp:17: passed: v.size() == 5 for: 5 == 5\n// 100-Fix-Section.cpp:18: passed: v.capacity() &gt;= 5 for: 5 &gt;= 5\n// 100-Fix-Section.cpp:29: passed: v.size() == 0 for: 0 == 0\n// 100-Fix-Section.cpp:30: passed: v.capacity() &gt;= 5 for: 5 &gt;= 5\n// 100-Fix-Section.cpp:17: passed: v.size() == 5 for: 5 == 5\n// 100-Fix-Section.cpp:18: passed: v.capacity() &gt;= 5 for: 5 &gt;= 5\n// 100-Fix-Section.cpp:35: passed: v.size() == 5 for: 5 == 5\n// 100-Fix-Section.cpp:36: passed: v.capacity() &gt;= 10 for: 10 &gt;= 10\n// 100-Fix-Section.cpp:17: passed: v.size() == 5 for: 5 == 5\n// 100-Fix-Section.cpp:18: passed: v.capacity() &gt;= 5 for: 5 &gt;= 5\n// 100-Fix-Section.cpp:41: passed: v.size() == 5 for: 5 == 5\n// 100-Fix-Section.cpp:42: passed: v.capacity() &gt;= 5 for: 5 &gt;= 5\n// Passed 1 test case with 16 assertions.\n</code></pre>"},{"location":"list-of-examples/#class-based-fixtures","title":"Class-based fixtures","text":"<pre><code>// 110-Fix-ClassFixture.cpp\n// Catch has two ways to express fixtures:\n// - Sections\n// - Traditional class-based fixtures (this file)\n// main() provided by linkage to Catch2WithMain\n#include &lt;catch2/catch_test_macros.hpp&gt;\nclass DBConnection\n{\npublic:\nstatic DBConnection createConnection( std::string const &amp; /*dbName*/ ) {\nreturn DBConnection();\n}\nbool executeSQL( std::string const &amp; /*query*/, int const /*id*/, std::string const &amp; arg ) {\nif ( arg.length() == 0 ) {\nthrow std::logic_error(\"empty SQL query argument\");\n}\nreturn true; // ok\n}\n};\nclass UniqueTestsFixture\n{\nprotected:\nUniqueTestsFixture()\n: conn( DBConnection::createConnection( \"myDB\" ) )\n{}\nint getID() {\nreturn ++uniqueID;\n}\nprotected:\nDBConnection conn;\nprivate:\nstatic int uniqueID;\n};\nint UniqueTestsFixture::uniqueID = 0;\nTEST_CASE_METHOD( UniqueTestsFixture, \"Create Employee/No Name\", \"[create]\" ) {\nREQUIRE_THROWS( conn.executeSQL( \"INSERT INTO employee (id, name) VALUES (?, ?)\", getID(), \"\") );\n}\nTEST_CASE_METHOD( UniqueTestsFixture, \"Create Employee/Normal\", \"[create]\" ) {\nREQUIRE( conn.executeSQL( \"INSERT INTO employee (id, name) VALUES (?, ?)\", getID(), \"Joe Bloggs\" ) );\n}\n// Compile &amp; run:\n// - g++ -std=c++14 -Wall -I$(CATCH_SINGLE_INCLUDE) -o 110-Fix-ClassFixture 110-Fix-ClassFixture.cpp &amp;&amp; 110-Fix-ClassFixture --success\n// - cl -EHsc -I%CATCH_SINGLE_INCLUDE% 110-Fix-ClassFixture.cpp &amp;&amp; 110-Fix-ClassFixture --success\n//\n// Compile with pkg-config:\n// - g++ -std=c++14 -Wall $(pkg-config catch2-with-main --cflags)  -o 110-Fix-ClassFixture 110-Fix-ClassFixture.cpp $(pkg-config catch2-with-main --libs)\n// Expected compact output (all assertions):\n//\n// prompt&gt; 110-Fix-ClassFixture.exe --reporter compact --success\n// 110-Fix-ClassFixture.cpp:47: passed: conn.executeSQL( \"INSERT INTO employee (id, name) VALUES (?, ?)\", getID(), \"\")\n// 110-Fix-ClassFixture.cpp:51: passed: conn.executeSQL( \"INSERT INTO employee (id, name) VALUES (?, ?)\", getID(), \"Joe Bloggs\" ) for: true\n// Passed both 2 test cases with 2 assertions.\n</code></pre>"},{"location":"list-of-examples/#bdd-scenario-given-when-then","title":"BDD (SCENARIO, GIVEN, WHEN, THEN)","text":"<pre><code>// 120-Bdd-ScenarioGivenWhenThen.cpp\n// main() provided by linkage with Catch2WithMain\n#include &lt;catch2/catch_test_macros.hpp&gt;\nSCENARIO( \"vectors can be sized and resized\", \"[vector]\" ) {\nGIVEN( \"A vector with some items\" ) {\nstd::vector&lt;int&gt; v( 5 );\nREQUIRE( v.size() == 5 );\nREQUIRE( v.capacity() &gt;= 5 );\nWHEN( \"the size is increased\" ) {\nv.resize( 10 );\nTHEN( \"the size and capacity change\" ) {\nREQUIRE( v.size() == 10 );\nREQUIRE( v.capacity() &gt;= 10 );\n}\n}\nWHEN( \"the size is reduced\" ) {\nv.resize( 0 );\nTHEN( \"the size changes but not capacity\" ) {\nREQUIRE( v.size() == 0 );\nREQUIRE( v.capacity() &gt;= 5 );\n}\n}\nWHEN( \"more capacity is reserved\" ) {\nv.reserve( 10 );\nTHEN( \"the capacity changes but not the size\" ) {\nREQUIRE( v.size() == 5 );\nREQUIRE( v.capacity() &gt;= 10 );\n}\n}\nWHEN( \"less capacity is reserved\" ) {\nv.reserve( 0 );\nTHEN( \"neither size nor capacity are changed\" ) {\nREQUIRE( v.size() == 5 );\nREQUIRE( v.capacity() &gt;= 5 );\n}\n}\n}\n}\n// Compile &amp; run:\n// - g++ -std=c++14 -Wall -I$(CATCH_SINGLE_INCLUDE) -o 120-Bdd-ScenarioGivenWhenThen 120-Bdd-ScenarioGivenWhenThen.cpp &amp;&amp; 120-Bdd-ScenarioGivenWhenThen --success\n// - cl -EHsc -I%CATCH_SINGLE_INCLUDE% 120-Bdd-ScenarioGivenWhenThen.cpp &amp;&amp; 120-Bdd-ScenarioGivenWhenThen --success\n// Expected compact output (all assertions):\n//\n// prompt&gt; 120-Bdd-ScenarioGivenWhenThen.exe --reporter compact --success\n// 120-Bdd-ScenarioGivenWhenThen.cpp:12: passed: v.size() == 5 for: 5 == 5\n// 120-Bdd-ScenarioGivenWhenThen.cpp:13: passed: v.capacity() &gt;= 5 for: 5 &gt;= 5\n// 120-Bdd-ScenarioGivenWhenThen.cpp:19: passed: v.size() == 10 for: 10 == 10\n// 120-Bdd-ScenarioGivenWhenThen.cpp:20: passed: v.capacity() &gt;= 10 for: 10 &gt;= 10\n// 120-Bdd-ScenarioGivenWhenThen.cpp:12: passed: v.size() == 5 for: 5 == 5\n// 120-Bdd-ScenarioGivenWhenThen.cpp:13: passed: v.capacity() &gt;= 5 for: 5 &gt;= 5\n// 120-Bdd-ScenarioGivenWhenThen.cpp:27: passed: v.size() == 0 for: 0 == 0\n// 120-Bdd-ScenarioGivenWhenThen.cpp:28: passed: v.capacity() &gt;= 5 for: 5 &gt;= 5\n// 120-Bdd-ScenarioGivenWhenThen.cpp:12: passed: v.size() == 5 for: 5 == 5\n// 120-Bdd-ScenarioGivenWhenThen.cpp:13: passed: v.capacity() &gt;= 5 for: 5 &gt;= 5\n// 120-Bdd-ScenarioGivenWhenThen.cpp:35: passed: v.size() == 5 for: 5 == 5\n// 120-Bdd-ScenarioGivenWhenThen.cpp:36: passed: v.capacity() &gt;= 10 for: 10 &gt;= 10\n// 120-Bdd-ScenarioGivenWhenThen.cpp:12: passed: v.size() == 5 for: 5 == 5\n// 120-Bdd-ScenarioGivenWhenThen.cpp:13: passed: v.capacity() &gt;= 5 for: 5 &gt;= 5\n// 120-Bdd-ScenarioGivenWhenThen.cpp:43: passed: v.size() == 5 for: 5 == 5\n// 120-Bdd-ScenarioGivenWhenThen.cpp:44: passed: v.capacity() &gt;= 5 for: 5 &gt;= 5\n// Passed 1 test case with 16 assertions.\n</code></pre>"},{"location":"list-of-examples/#listener","title":"Listener","text":"<pre><code>// 210-Evt-EventListeners.cpp\n// Contents:\n// 1. Printing of listener data\n// 2. My listener and registration\n// 3. Test cases\n#include &lt;catch2/catch_test_macros.hpp&gt;\n#include &lt;catch2/reporters/catch_reporter_event_listener.hpp&gt;\n#include &lt;catch2/reporters/catch_reporter_registrars.hpp&gt;\n#include &lt;catch2/catch_test_case_info.hpp&gt;\n#include &lt;iostream&gt;\n// -----------------------------------------------------------------------\n// 1. Printing of listener data:\n//\nnamespace {\nstd::string ws(int const level) {\nreturn std::string( 2 * level, ' ' );\n}\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, Catch::Tag t) {\nreturn out &lt;&lt; \"original: \" &lt;&lt; t.original;\n}\ntemplate&lt; typename T &gt;\nstd::ostream&amp; operator&lt;&lt;( std::ostream&amp; os, std::vector&lt;T&gt; const&amp; v ) {\nos &lt;&lt; \"{ \";\nfor ( const auto&amp; x : v )\nos &lt;&lt; x &lt;&lt; \", \";\nreturn os &lt;&lt; \"}\";\n}\n// struct SourceLineInfo {\n//     char const* file;\n//     std::size_t line;\n// };\nvoid print( std::ostream&amp; os, int const level, std::string const&amp; title, Catch::SourceLineInfo const&amp; info ) {\nos &lt;&lt; ws(level  ) &lt;&lt; title &lt;&lt; \":\\n\"\n&lt;&lt; ws(level+1) &lt;&lt; \"- file: \" &lt;&lt; info.file &lt;&lt; \"\\n\"\n&lt;&lt; ws(level+1) &lt;&lt; \"- line: \" &lt;&lt; info.line &lt;&lt; \"\\n\";\n}\n//struct MessageInfo {\n//    std::string macroName;\n//    std::string message;\n//    SourceLineInfo lineInfo;\n//    ResultWas::OfType type;\n//    unsigned int sequence;\n//};\nvoid print( std::ostream&amp; os, int const level, Catch::MessageInfo const&amp; info ) {\nos &lt;&lt; ws(level+1) &lt;&lt; \"- macroName: '\" &lt;&lt; info.macroName &lt;&lt; \"'\\n\"\n&lt;&lt; ws(level+1) &lt;&lt; \"- message '\"    &lt;&lt; info.message   &lt;&lt; \"'\\n\";\nprint( os,level+1  , \"- lineInfo\", info.lineInfo );\nos &lt;&lt; ws(level+1) &lt;&lt; \"- sequence \"    &lt;&lt; info.sequence  &lt;&lt; \"\\n\";\n}\nvoid print( std::ostream&amp; os, int const level, std::string const&amp; title, std::vector&lt;Catch::MessageInfo&gt; const&amp; v ) {\nos &lt;&lt; ws(level  ) &lt;&lt; title &lt;&lt; \":\\n\";\nfor ( const auto&amp; x : v )\n{\nos &lt;&lt; ws(level+1) &lt;&lt; \"{\\n\";\nprint( os, level+2, x );\nos &lt;&lt; ws(level+1) &lt;&lt; \"}\\n\";\n}\n//    os &lt;&lt; ws(level+1) &lt;&lt; \"\\n\";\n}\n// struct TestRunInfo {\n//     std::string name;\n// };\nvoid print( std::ostream&amp; os, int const level, std::string const&amp; title, Catch::TestRunInfo const&amp; info ) {\nos &lt;&lt; ws(level  ) &lt;&lt; title &lt;&lt; \":\\n\"\n&lt;&lt; ws(level+1) &lt;&lt; \"- name: \" &lt;&lt; info.name &lt;&lt; \"\\n\";\n}\n// struct Counts {\n//     std::size_t total() const;\n//     bool allPassed() const;\n//     bool allOk() const;\n//\n//     std::size_t passed = 0;\n//     std::size_t failed = 0;\n//     std::size_t failedButOk = 0;\n// };\nvoid print( std::ostream&amp; os, int const level, std::string const&amp; title, Catch::Counts const&amp; info ) {\nos &lt;&lt; ws(level  ) &lt;&lt; title &lt;&lt; \":\\n\"\n&lt;&lt; ws(level+1) &lt;&lt; \"- total(): \"     &lt;&lt; info.total()     &lt;&lt; \"\\n\"\n&lt;&lt; ws(level+1) &lt;&lt; \"- allPassed(): \" &lt;&lt; info.allPassed() &lt;&lt; \"\\n\"\n&lt;&lt; ws(level+1) &lt;&lt; \"- allOk(): \"     &lt;&lt; info.allOk()     &lt;&lt; \"\\n\"\n&lt;&lt; ws(level+1) &lt;&lt; \"- passed: \"      &lt;&lt; info.passed      &lt;&lt; \"\\n\"\n&lt;&lt; ws(level+1) &lt;&lt; \"- failed: \"      &lt;&lt; info.failed      &lt;&lt; \"\\n\"\n&lt;&lt; ws(level+1) &lt;&lt; \"- failedButOk: \" &lt;&lt; info.failedButOk &lt;&lt; \"\\n\";\n}\n// struct Totals {\n//     Counts assertions;\n//     Counts testCases;\n// };\nvoid print( std::ostream&amp; os, int const level, std::string const&amp; title, Catch::Totals const&amp; info ) {\nos &lt;&lt; ws(level) &lt;&lt; title &lt;&lt; \":\\n\";\nprint( os, level+1, \"- assertions\", info.assertions );\nprint( os, level+1, \"- testCases\" , info.testCases  );\n}\n// struct TestRunStats {\n//     TestRunInfo runInfo;\n//     Totals totals;\n//     bool aborting;\n// };\nvoid print( std::ostream&amp; os, int const level, std::string const&amp; title, Catch::TestRunStats const&amp; info ) {\nos &lt;&lt; ws(level) &lt;&lt; title &lt;&lt; \":\\n\";\nprint( os, level+1 , \"- runInfo\", info.runInfo );\nprint( os, level+1 , \"- totals\" , info.totals  );\nos &lt;&lt; ws(level+1) &lt;&lt; \"- aborting: \" &lt;&lt; info.aborting &lt;&lt; \"\\n\";\n}\n//    struct Tag {\n//        StringRef original, lowerCased;\n//    };\n//\n//\n//    enum class TestCaseProperties : uint8_t {\n//        None = 0,\n//        IsHidden = 1 &lt;&lt; 1,\n//        ShouldFail = 1 &lt;&lt; 2,\n//        MayFail = 1 &lt;&lt; 3,\n//        Throws = 1 &lt;&lt; 4,\n//        NonPortable = 1 &lt;&lt; 5,\n//        Benchmark = 1 &lt;&lt; 6\n//    };\n//\n//\n//    struct TestCaseInfo : NonCopyable {\n//\n//        bool isHidden() const;\n//        bool throws() const;\n//        bool okToFail() const;\n//        bool expectedToFail() const;\n//\n//\n//        std::string name;\n//        std::string className;\n//        std::vector&lt;Tag&gt; tags;\n//        SourceLineInfo lineInfo;\n//        TestCaseProperties properties = TestCaseProperties::None;\n//    };\nvoid print( std::ostream&amp; os, int const level, std::string const&amp; title, Catch::TestCaseInfo const&amp; info ) {\nos &lt;&lt; ws(level  ) &lt;&lt; title &lt;&lt; \":\\n\"\n&lt;&lt; ws(level+1) &lt;&lt; \"- isHidden(): \"       &lt;&lt; info.isHidden() &lt;&lt; \"\\n\"\n&lt;&lt; ws(level+1) &lt;&lt; \"- throws(): \"         &lt;&lt; info.throws() &lt;&lt; \"\\n\"\n&lt;&lt; ws(level+1) &lt;&lt; \"- okToFail(): \"       &lt;&lt; info.okToFail() &lt;&lt; \"\\n\"\n&lt;&lt; ws(level+1) &lt;&lt; \"- expectedToFail(): \" &lt;&lt; info.expectedToFail() &lt;&lt; \"\\n\"\n&lt;&lt; ws(level+1) &lt;&lt; \"- tagsAsString(): '\"  &lt;&lt; info.tagsAsString() &lt;&lt; \"'\\n\"\n&lt;&lt; ws(level+1) &lt;&lt; \"- name: '\"            &lt;&lt; info.name &lt;&lt; \"'\\n\"\n&lt;&lt; ws(level+1) &lt;&lt; \"- className: '\"       &lt;&lt; info.className &lt;&lt; \"'\\n\"\n&lt;&lt; ws(level+1) &lt;&lt; \"- tags: \"             &lt;&lt; info.tags &lt;&lt; \"\\n\";\nprint( os, level+1 , \"- lineInfo\", info.lineInfo );\nos &lt;&lt; ws(level+1) &lt;&lt; \"- properties (flags): 0x\" &lt;&lt; std::hex &lt;&lt; static_cast&lt;uint32_t&gt;(info.properties) &lt;&lt; std::dec &lt;&lt; \"\\n\";\n}\n// struct TestCaseStats {\n//     TestCaseInfo testInfo;\n//     Totals totals;\n//     std::string stdOut;\n//     std::string stdErr;\n//     bool aborting;\n// };\nvoid print( std::ostream&amp; os, int const level, std::string const&amp; title, Catch::TestCaseStats const&amp; info ) {\nos &lt;&lt; ws(level  ) &lt;&lt; title &lt;&lt; \":\\n\";\nprint( os, level+1 , \"- testInfo\", *info.testInfo );\nprint( os, level+1 , \"- totals\"  , info.totals   );\nos &lt;&lt; ws(level+1) &lt;&lt; \"- stdOut: \"   &lt;&lt; info.stdOut &lt;&lt; \"\\n\"\n&lt;&lt; ws(level+1) &lt;&lt; \"- stdErr: \"   &lt;&lt; info.stdErr &lt;&lt; \"\\n\"\n&lt;&lt; ws(level+1) &lt;&lt; \"- aborting: \" &lt;&lt; info.aborting &lt;&lt; \"\\n\";\n}\n// struct SectionInfo {\n//     std::string name;\n//     std::string description;\n//     SourceLineInfo lineInfo;\n// };\nvoid print( std::ostream&amp; os, int const level, std::string const&amp; title, Catch::SectionInfo const&amp; info ) {\nos &lt;&lt; ws(level  ) &lt;&lt; title &lt;&lt; \":\\n\"\n&lt;&lt; ws(level+1) &lt;&lt; \"- name: \"         &lt;&lt; info.name &lt;&lt; \"\\n\";\nprint( os, level+1 , \"- lineInfo\", info.lineInfo );\n}\n// struct SectionStats {\n//     SectionInfo sectionInfo;\n//     Counts assertions;\n//     double durationInSeconds;\n//     bool missingAssertions;\n// };\nvoid print( std::ostream&amp; os, int const level, std::string const&amp; title, Catch::SectionStats const&amp; info ) {\nos &lt;&lt; ws(level  ) &lt;&lt; title &lt;&lt; \":\\n\";\nprint( os, level+1 , \"- sectionInfo\", info.sectionInfo );\nprint( os, level+1 , \"- assertions\" , info.assertions );\nos &lt;&lt; ws(level+1) &lt;&lt; \"- durationInSeconds: \" &lt;&lt; info.durationInSeconds &lt;&lt; \"\\n\"\n&lt;&lt; ws(level+1) &lt;&lt; \"- missingAssertions: \" &lt;&lt; info.missingAssertions &lt;&lt; \"\\n\";\n}\n// struct AssertionInfo\n// {\n//     StringRef macroName;\n//     SourceLineInfo lineInfo;\n//     StringRef capturedExpression;\n//     ResultDisposition::Flags resultDisposition;\n// };\nvoid print( std::ostream&amp; os, int const level, std::string const&amp; title, Catch::AssertionInfo const&amp; info ) {\nos &lt;&lt; ws(level  ) &lt;&lt; title &lt;&lt; \":\\n\"\n&lt;&lt; ws(level+1) &lt;&lt; \"- macroName: '\"  &lt;&lt; info.macroName &lt;&lt; \"'\\n\";\nprint( os, level+1 , \"- lineInfo\" , info.lineInfo );\nos &lt;&lt; ws(level+1) &lt;&lt; \"- capturedExpression: '\" &lt;&lt; info.capturedExpression &lt;&lt; \"'\\n\"\n&lt;&lt; ws(level+1) &lt;&lt; \"- resultDisposition (flags): 0x\" &lt;&lt; std::hex &lt;&lt; info.resultDisposition  &lt;&lt; std::dec &lt;&lt; \"\\n\";\n}\n//struct AssertionResultData\n//{\n//    std::string reconstructExpression() const;\n//\n//    std::string message;\n//    mutable std::string reconstructedExpression;\n//    LazyExpression lazyExpression;\n//    ResultWas::OfType resultType;\n//};\nvoid print( std::ostream&amp; os, int const level, std::string const&amp; title, Catch::AssertionResultData const&amp; info ) {\nos &lt;&lt; ws(level  ) &lt;&lt; title &lt;&lt; \":\\n\"\n&lt;&lt; ws(level+1) &lt;&lt; \"- reconstructExpression(): '\" &lt;&lt;   info.reconstructExpression() &lt;&lt; \"'\\n\"\n&lt;&lt; ws(level+1) &lt;&lt; \"- message: '\"                 &lt;&lt;   info.message &lt;&lt; \"'\\n\"\n&lt;&lt; ws(level+1) &lt;&lt; \"- lazyExpression: '\"          &lt;&lt; \"(info.lazyExpression)\" &lt;&lt; \"'\\n\"\n&lt;&lt; ws(level+1) &lt;&lt; \"- resultType: '\"              &lt;&lt;   info.resultType &lt;&lt; \"'\\n\";\n}\n//class AssertionResult {\n//    bool isOk() const;\n//    bool succeeded() const;\n//    ResultWas::OfType getResultType() const;\n//    bool hasExpression() const;\n//    bool hasMessage() const;\n//    std::string getExpression() const;\n//    std::string getExpressionInMacro() const;\n//    bool hasExpandedExpression() const;\n//    std::string getExpandedExpression() const;\n//    std::string getMessage() const;\n//    SourceLineInfo getSourceInfo() const;\n//    std::string getTestMacroName() const;\n//\n//    AssertionInfo m_info;\n//    AssertionResultData m_resultData;\n//};\nvoid print( std::ostream&amp; os, int const level, std::string const&amp; title, Catch::AssertionResult const&amp; info ) {\nos &lt;&lt; ws(level  ) &lt;&lt; title &lt;&lt; \":\\n\"\n&lt;&lt; ws(level+1) &lt;&lt; \"- isOk(): \"  &lt;&lt; info.isOk() &lt;&lt; \"\\n\"\n&lt;&lt; ws(level+1) &lt;&lt; \"- succeeded(): \"  &lt;&lt; info.succeeded() &lt;&lt; \"\\n\"\n&lt;&lt; ws(level+1) &lt;&lt; \"- getResultType(): \"  &lt;&lt; info.getResultType() &lt;&lt; \"\\n\"\n&lt;&lt; ws(level+1) &lt;&lt; \"- hasExpression(): \"  &lt;&lt; info.hasExpression() &lt;&lt; \"\\n\"\n&lt;&lt; ws(level+1) &lt;&lt; \"- hasMessage(): \"  &lt;&lt; info.hasMessage() &lt;&lt; \"\\n\"\n&lt;&lt; ws(level+1) &lt;&lt; \"- getExpression(): '\"  &lt;&lt; info.getExpression() &lt;&lt; \"'\\n\"\n&lt;&lt; ws(level+1) &lt;&lt; \"- getExpressionInMacro(): '\"  &lt;&lt; info.getExpressionInMacro()  &lt;&lt; \"'\\n\"\n&lt;&lt; ws(level+1) &lt;&lt; \"- hasExpandedExpression(): \"  &lt;&lt; info.hasExpandedExpression() &lt;&lt; \"\\n\"\n&lt;&lt; ws(level+1) &lt;&lt; \"- getExpandedExpression(): \"  &lt;&lt; info.getExpandedExpression() &lt;&lt; \"'\\n\"\n&lt;&lt; ws(level+1) &lt;&lt; \"- getMessage(): '\"  &lt;&lt; info.getMessage() &lt;&lt; \"'\\n\";\nprint( os, level+1 , \"- getSourceInfo(): \", info.getSourceInfo() );\nos &lt;&lt; ws(level+1) &lt;&lt; \"- getTestMacroName(): '\"  &lt;&lt; info.getTestMacroName() &lt;&lt; \"'\\n\";\nprint( os, level+1 , \"- *** m_info (AssertionInfo)\", info.m_info );\nprint( os, level+1 , \"- *** m_resultData (AssertionResultData)\", info.m_resultData );\n}\n// struct AssertionStats {\n//     AssertionResult assertionResult;\n//     std::vector&lt;MessageInfo&gt; infoMessages;\n//     Totals totals;\n// };\nvoid print( std::ostream&amp; os, int const level, std::string const&amp; title, Catch::AssertionStats const&amp; info ) {\nos &lt;&lt; ws(level  ) &lt;&lt; title &lt;&lt; \":\\n\";\nprint( os, level+1 , \"- assertionResult\", info.assertionResult );\nprint( os, level+1 , \"- infoMessages\", info.infoMessages );\nprint( os, level+1 , \"- totals\", info.totals );\n}\n// -----------------------------------------------------------------------\n// 2. My listener and registration:\n//\nchar const * dashed_line =\n\"--------------------------------------------------------------------------\";\nstruct MyListener : Catch::EventListenerBase {\nusing EventListenerBase::EventListenerBase; // inherit constructor\n// Get rid of Wweak-tables\n~MyListener() override;\n// The whole test run starting\nvoid testRunStarting( Catch::TestRunInfo const&amp; testRunInfo ) override {\nstd::cout\n&lt;&lt; std::boolalpha\n&lt;&lt; \"\\nEvent: testRunStarting:\\n\";\nprint( std::cout, 1, \"- testRunInfo\", testRunInfo );\n}\n// The whole test run ending\nvoid testRunEnded( Catch::TestRunStats const&amp; testRunStats ) override {\nstd::cout\n&lt;&lt; dashed_line\n&lt;&lt; \"\\nEvent: testRunEnded:\\n\";\nprint( std::cout, 1, \"- testRunStats\", testRunStats );\n}\n// A test is being skipped (because it is \"hidden\")\nvoid skipTest( Catch::TestCaseInfo const&amp; testInfo ) override {\nstd::cout\n&lt;&lt; dashed_line\n&lt;&lt; \"\\nEvent: skipTest:\\n\";\nprint( std::cout, 1, \"- testInfo\", testInfo );\n}\n// Test cases starting\nvoid testCaseStarting( Catch::TestCaseInfo const&amp; testInfo ) override {\nstd::cout\n&lt;&lt; dashed_line\n&lt;&lt; \"\\nEvent: testCaseStarting:\\n\";\nprint( std::cout, 1, \"- testInfo\", testInfo );\n}\n// Test cases ending\nvoid testCaseEnded( Catch::TestCaseStats const&amp; testCaseStats ) override {\nstd::cout &lt;&lt; \"\\nEvent: testCaseEnded:\\n\";\nprint( std::cout, 1, \"testCaseStats\", testCaseStats );\n}\n// Sections starting\nvoid sectionStarting( Catch::SectionInfo const&amp; sectionInfo ) override {\nstd::cout &lt;&lt; \"\\nEvent: sectionStarting:\\n\";\nprint( std::cout, 1, \"- sectionInfo\", sectionInfo );\n}\n// Sections ending\nvoid sectionEnded( Catch::SectionStats const&amp; sectionStats ) override {\nstd::cout &lt;&lt; \"\\nEvent: sectionEnded:\\n\";\nprint( std::cout, 1, \"- sectionStats\", sectionStats );\n}\n// Assertions before/ after\nvoid assertionStarting( Catch::AssertionInfo const&amp; assertionInfo ) override {\nstd::cout &lt;&lt; \"\\nEvent: assertionStarting:\\n\";\nprint( std::cout, 1, \"- assertionInfo\", assertionInfo );\n}\nvoid assertionEnded( Catch::AssertionStats const&amp; assertionStats ) override {\nstd::cout &lt;&lt; \"\\nEvent: assertionEnded:\\n\";\nprint( std::cout, 1, \"- assertionStats\", assertionStats );\n}\n};\n} // end anonymous namespace\nCATCH_REGISTER_LISTENER( MyListener )\n// Get rid of Wweak-tables\nMyListener::~MyListener() {}\n// -----------------------------------------------------------------------\n// 3. Test cases:\n//\nTEST_CASE( \"1: Hidden testcase\", \"[.hidden]\" ) {\n}\nTEST_CASE( \"2: Testcase with sections\", \"[tag-A][tag-B]\" ) {\nint i = 42;\nREQUIRE( i == 42 );\nSECTION(\"Section 1\") {\nINFO(\"Section 1\");\ni = 7;\nSECTION(\"Section 1.1\") {\nINFO(\"Section 1.1\");\nREQUIRE( i == 42 );\n}\n}\nSECTION(\"Section 2\") {\nINFO(\"Section 2\");\nREQUIRE( i == 42 );\n}\nWARN(\"At end of test case\");\n}\nstruct Fixture {\nint fortytwo() const {\nreturn 42;\n}\n};\nTEST_CASE_METHOD( Fixture, \"3: Testcase with class-based fixture\", \"[tag-C][tag-D]\" ) {\nREQUIRE( fortytwo() == 42 );\n}\n// Compile &amp; run:\n// - g++ -std=c++14 -Wall -I$(CATCH_SINGLE_INCLUDE) -o 210-Evt-EventListeners 210-Evt-EventListeners.cpp &amp;&amp; 210-Evt-EventListeners --success\n// - cl -EHsc -I%CATCH_SINGLE_INCLUDE% 210-Evt-EventListeners.cpp &amp;&amp; 210-Evt-EventListeners --success\n// Expected compact output (all assertions):\n//\n// prompt&gt; 210-Evt-EventListeners --reporter compact --success\n// result omitted for brevity.\n</code></pre>"},{"location":"list-of-examples/#configuration-provide-your-own-output-streams","title":"Configuration - Provide your own output streams","text":"<pre><code>// 231-Cfg-OutputStreams.cpp\n// Show how to replace the streams with a simple custom made streambuf.\n// Note that this reimplementation _does not_ follow `std::cerr`\n// semantic, because it buffers the output. For most uses however,\n// there is no important difference between having `std::cerr` buffered\n// or unbuffered.\n#include &lt;catch2/catch_test_macros.hpp&gt;\n#include &lt;sstream&gt;\n#include &lt;cstdio&gt;\nclass out_buff : public std::stringbuf {\nstd::FILE* m_stream;\npublic:\nout_buff(std::FILE* stream):m_stream(stream) {}\n~out_buff();\nint sync() override {\nint ret = 0;\nfor (unsigned char c : str()) {\nif (putc(c, m_stream) == EOF) {\nret = -1;\nbreak;\n}\n}\n// Reset the buffer to avoid printing it multiple times\nstr(\"\");\nreturn ret;\n}\n};\nout_buff::~out_buff() { pubsync(); }\n#if defined(__clang__)\n#pragma clang diagnostic ignored \"-Wexit-time-destructors\" // static variables in cout/cerr/clog\n#endif\nnamespace Catch {\nstd::ostream&amp; cout() {\nstatic std::ostream ret(new out_buff(stdout));\nreturn ret;\n}\nstd::ostream&amp; clog() {\nstatic std::ostream ret(new out_buff(stderr));\nreturn ret;\n}\nstd::ostream&amp; cerr() {\nreturn clog();\n}\n}\nTEST_CASE(\"This binary uses putc to write out output\", \"[compilation-only]\") {\nSUCCEED(\"Nothing to test.\");\n}\n</code></pre>"},{"location":"list-of-examples/#generators","title":"Generators","text":""},{"location":"list-of-examples/#create-your-own-generator","title":"Create your own generator","text":"<pre><code>// 300-Gen-OwnGenerator.cpp\n// Shows how to define a custom generator.\n// Specifically we will implement a random number generator for integers\n// It will have infinite capacity and settable lower/upper bound\n#include &lt;catch2/catch_test_macros.hpp&gt;\n#include &lt;catch2/generators/catch_generators.hpp&gt;\n#include &lt;catch2/generators/catch_generators_adapters.hpp&gt;\n#include &lt;random&gt;\nnamespace {\n// This class shows how to implement a simple generator for Catch tests\nclass RandomIntGenerator : public Catch::Generators::IGenerator&lt;int&gt; {\nstd::minstd_rand m_rand;\nstd::uniform_int_distribution&lt;&gt; m_dist;\nint current_number;\npublic:\nRandomIntGenerator(int low, int high):\nm_rand(std::random_device{}()),\nm_dist(low, high)\n{\nstatic_cast&lt;void&gt;(next());\n}\nint const&amp; get() const override;\nbool next() override {\ncurrent_number = m_dist(m_rand);\nreturn true;\n}\n};\n// Avoids -Wweak-vtables\nint const&amp; RandomIntGenerator::get() const {\nreturn current_number;\n}\n// This helper function provides a nicer UX when instantiating the generator\n// Notice that it returns an instance of GeneratorWrapper&lt;int&gt;, which\n// is a value-wrapper around std::unique_ptr&lt;IGenerator&lt;int&gt;&gt;.\nCatch::Generators::GeneratorWrapper&lt;int&gt; random(int low, int high) {\nreturn Catch::Generators::GeneratorWrapper&lt;int&gt;(\nnew RandomIntGenerator(low, high)\n// Another possibility:\n// Catch::Detail::make_unique&lt;RandomIntGenerator&gt;(low, high)\n);\n}\n} // end anonymous namespaces\n// The two sections in this test case are equivalent, but the first one\n// is much more readable/nicer to use\nTEST_CASE(\"Generating random ints\", \"[example][generator]\") {\nSECTION(\"Nice UX\") {\nauto i = GENERATE(take(100, random(-100, 100)));\nREQUIRE(i &gt;= -100);\nREQUIRE(i &lt;= 100);\n}\nSECTION(\"Creating the random generator directly\") {\nauto i = GENERATE(take(100, GeneratorWrapper&lt;int&gt;(Catch::Detail::make_unique&lt;RandomIntGenerator&gt;(-100, 100))));\nREQUIRE(i &gt;= -100);\nREQUIRE(i &lt;= 100);\n}\n}\n// Compiling and running this file will result in 400 successful assertions\n</code></pre>"},{"location":"list-of-examples/#use-map-to-convert-types-in-generate-expression","title":"Use map to convert types in GENERATE expression","text":"<pre><code>// 301-Gen-MapTypeConversion.cpp\n// Shows how to use map to modify generator's return type.\n// Specifically we wrap a std::string returning generator with a generator\n// that converts the strings using stoi, so the returned type is actually\n// an int.\n#include &lt;catch2/catch_test_macros.hpp&gt;\n#include &lt;catch2/generators/catch_generators_adapters.hpp&gt;\n#include &lt;string&gt;\n#include &lt;sstream&gt;\nnamespace {\n// Returns a line from a stream. You could have it e.g. read lines from\n// a file, but to avoid problems with paths in examples, we will use\n// a fixed stringstream.\nclass LineGenerator : public Catch::Generators::IGenerator&lt;std::string&gt; {\nstd::string m_line;\nstd::stringstream m_stream;\npublic:\nLineGenerator() {\nm_stream.str(\"1\\n2\\n3\\n4\\n\");\nif (!next()) {\nCatch::Generators::Detail::throw_generator_exception(\"Couldn't read a single line\");\n}\n}\nstd::string const&amp; get() const override;\nbool next() override {\nreturn !!std::getline(m_stream, m_line);\n}\n};\nstd::string const&amp; LineGenerator::get() const {\nreturn m_line;\n}\n// This helper function provides a nicer UX when instantiating the generator\n// Notice that it returns an instance of GeneratorWrapper&lt;std::string&gt;, which\n// is a value-wrapper around std::unique_ptr&lt;IGenerator&lt;std::string&gt;&gt;.\nCatch::Generators::GeneratorWrapper&lt;std::string&gt; lines(std::string /* ignored for example */) {\nreturn Catch::Generators::GeneratorWrapper&lt;std::string&gt;(\nnew LineGenerator()\n);\n}\n} // end anonymous namespace\nTEST_CASE(\"filter can convert types inside the generator expression\", \"[example][generator]\") {\nauto num = GENERATE(map&lt;int&gt;([](std::string const&amp; line) { return std::stoi(line); },\nlines(\"fake-file\")));\nREQUIRE(num &gt; 0);\n}\n// Compiling and running this file will result in 4 successful assertions\n</code></pre>"},{"location":"list-of-examples/#run-test-with-a-table-of-input-values","title":"Run test with a table of input values","text":"<pre><code>// 302-Gen-Table.cpp\n// Shows how to use table to run a test many times with different inputs. Lifted from examples on\n// issue #850.\n#include &lt;catch2/catch_test_macros.hpp&gt;\n#include &lt;catch2/generators/catch_generators.hpp&gt;\n#include &lt;string&gt;\nstruct TestSubject {\n// this is the method we are going to test. It returns the length of the\n// input string.\nsize_t GetLength( const std::string&amp; input ) const { return input.size(); }\n};\nTEST_CASE(\"Table allows pre-computed test inputs and outputs\", \"[example][generator]\") {\nusing std::make_tuple;\n// do setup here as normal\nTestSubject subj;\nSECTION(\"This section is run for each row in the table\") {\nstd::string test_input;\nsize_t expected_output;\nstd::tie( test_input, expected_output ) =\nGENERATE( table&lt;std::string, size_t&gt;(\n{ /* In this case one of the parameters to our test case is the\n                   * expected output, but this is not required. There could be\n                   * multiple expected values in the table, which can have any\n                   * (fixed) number of columns.\n                   */\nmake_tuple( \"one\", 3 ),\nmake_tuple( \"two\", 3 ),\nmake_tuple( \"three\", 5 ),\nmake_tuple( \"four\", 4 ) } ) );\n// run the test\nauto result = subj.GetLength(test_input);\n// capture the input data to go with the outputs.\nCAPTURE(test_input);\n// check it matches the pre-calculated data\nREQUIRE(result == expected_output);\n}   // end section\n}\n/* Possible simplifications where less legacy toolchain support is needed:\n *\n * - With libstdc++6 or newer, the make_tuple() calls can be omitted\n * (technically C++17 but does not require -std in GCC/Clang). See\n *   https://stackoverflow.com/questions/12436586/tuple-vector-and-initializer-list\n *\n * - In C++17 mode std::tie() and the preceding variable declarations can be\n * replaced by structured bindings: auto [test_input, expected] = GENERATE(\n * table&lt;std::string, size_t&gt;({ ...\n */\n// Compiling and running this file will result in 4 successful assertions\n</code></pre>"},{"location":"list-of-examples/#use-variables-in-generator-expressions","title":"Use variables in generator expressions","text":"<pre><code>// 310-Gen-VariablesInGenerator.cpp\n// Shows how to use variables when creating generators.\n// Note that using variables inside generators is dangerous and should\n// be done only if you know what you are doing, because the generators\n// _WILL_ outlive the variables -- thus they should be either captured\n// by value directly, or copied by the generators during construction.\n#include &lt;catch2/catch_test_macros.hpp&gt;\n#include &lt;catch2/generators/catch_generators_adapters.hpp&gt;\n#include &lt;catch2/generators/catch_generators_random.hpp&gt;\nTEST_CASE(\"Generate random doubles across different ranges\",\n\"[generator][example][advanced]\") {\n// Workaround for old libstdc++\nusing record = std::tuple&lt;double, double&gt;;\n// Set up 3 ranges to generate numbers from\nauto r = GENERATE(table&lt;double, double&gt;({\nrecord{3, 4},\nrecord{-4, -3},\nrecord{10, 1000}\n}));\n// This will not compile (intentionally), because it accesses a variable\n// auto number = GENERATE(take(50, random(std::get&lt;0&gt;(r), std::get&lt;1&gt;(r))));\n// GENERATE_COPY copies all variables mentioned inside the expression\n// thus this will work.\nauto number = GENERATE_COPY(take(50, random(std::get&lt;0&gt;(r), std::get&lt;1&gt;(r))));\nREQUIRE(std::abs(number) &gt; 0);\n}\n// Compiling and running this file will result in 150 successful assertions\n</code></pre>"},{"location":"list-of-examples/#use-custom-variable-capture-in-generator-expressions","title":"Use custom variable capture in generator expressions","text":"<pre><code>// 311-Gen-CustomCapture.cpp\n// Shows how to provide custom capture list to the generator expression\n// Note that using variables inside generators is dangerous and should\n// be done only if you know what you are doing, because the generators\n// _WILL_ outlive the variables. Also, even if you know what you are\n// doing, you should probably use GENERATE_COPY or GENERATE_REF macros\n// instead. However, if your use case requires having a\n// per-variable custom capture list, this example shows how to achieve\n// that.\n#include &lt;catch2/catch_test_macros.hpp&gt;\n#include &lt;catch2/generators/catch_generators_adapters.hpp&gt;\n#include &lt;catch2/generators/catch_generators_random.hpp&gt;\nTEST_CASE(\"Generate random doubles across different ranges\",\n\"[generator][example][advanced]\") {\n// Workaround for old libstdc++\nusing record = std::tuple&lt;double, double&gt;;\n// Set up 3 ranges to generate numbers from\nauto r1 = GENERATE(table&lt;double, double&gt;({\nrecord{3, 4},\nrecord{-4, -3},\nrecord{10, 1000}\n}));\nauto r2(r1);\n// This will take r1 by reference and r2 by value.\n// Note that there are no advantages for doing so in this example,\n// it is done only for expository purposes.\nauto number = Catch::Generators::generate( \"custom capture generator\", CATCH_INTERNAL_LINEINFO,\n[&amp;r1, r2]{\nusing namespace Catch::Generators;\nreturn makeGenerators(take(50, random(std::get&lt;0&gt;(r1), std::get&lt;1&gt;(r2))));\n}\n);\nREQUIRE(std::abs(number) &gt; 0);\n}\n// Compiling and running this file will result in 150 successful assertions\n</code></pre> Planned (TBD) <ul> <li>Assertion: REQUIRE_THAT and Matchers</li> <li>Assertion: REQUIRE_NO_THROW</li> <li>Assertion: REQUIRE_THROWS</li> <li>Assertion: REQUIRE_THROWS_AS</li> <li>Assertion: REQUIRE_THROWS_WITH</li> <li>Assertion: REQUIRE_THROWS_MATCHES</li> <li>Floating point: Approx - Comparisons</li> <li>Logging: CAPTURE - Capture expression</li> <li>Logging: INFO - Provide information with failure</li> <li>Logging: WARN - Issue warning</li> <li>Logging: FAIL, FAIL_CHECK - Issue message and force failure/continue</li> <li>Logging: SUCCEED - Issue message and continue</li> <li>Report: User-defined type</li> <li>Report: User-defined reporter</li> <li>Report: Automake reporter</li> <li>Report: TAP reporter</li> <li>Report: Multiple reporter</li> <li>Configuration: Provide your own main()</li> <li>Configuration: Compile-time configuration</li> <li>Configuration: Run-time configuration</li> </ul>"},{"location":"logging/","title":"Logging","text":""},{"location":"logging/#logging-macros","title":"Logging macros","text":"<p>Additional messages can be logged during a test case. Note that the messages logged with <code>INFO</code> are scoped and thus will not be reported if failure occurs in scope preceding the message declaration. An example:</p> <p><pre><code>TEST_CASE(\"Foo\") {\nINFO(\"Test case start\");\nfor (int i = 0; i &lt; 2; ++i) {\nINFO(\"The number is \" &lt;&lt; i);\nCHECK(i == 0);\n}\n}\nTEST_CASE(\"Bar\") {\nINFO(\"Test case start\");\nfor (int i = 0; i &lt; 2; ++i) {\nINFO(\"The number is \" &lt;&lt; i);\nCHECK(i == i);\n}\nCHECK(false);\n}\n</code></pre> When the <code>CHECK</code> fails in the \"Foo\" test case, then two messages will be printed. <pre><code>Test case start\nThe number is 1\n</code></pre> When the last <code>CHECK</code> fails in the \"Bar\" test case, then only one message will be printed: <code>Test case start</code>.</p>"},{"location":"logging/#logging-without-local-scope","title":"Logging without local scope","text":"<p>Introduced in Catch2 2.7.0.</p> <p><code>UNSCOPED_INFO</code> is similar to <code>INFO</code> with two key differences:</p> <ul> <li>Lifetime of an unscoped message is not tied to its own scope.</li> <li>An unscoped message can be reported by the first following assertion only, regardless of the result of that assertion.</li> </ul> <p>In other words, lifetime of <code>UNSCOPED_INFO</code> is limited by the following assertion (or by the end of test case/section, whichever comes first) whereas lifetime of <code>INFO</code> is limited by its own scope.</p> <p>These differences make this macro useful for reporting information from helper functions or inner scopes. An example:</p> <pre><code>void print_some_info() {\nUNSCOPED_INFO(\"Info from helper\");\n}\nTEST_CASE(\"Baz\") {\nprint_some_info();\nfor (int i = 0; i &lt; 2; ++i) {\nUNSCOPED_INFO(\"The number is \" &lt;&lt; i);\n}\nCHECK(false);\n}\nTEST_CASE(\"Qux\") {\nINFO(\"First info\");\nUNSCOPED_INFO(\"First unscoped info\");\nCHECK(false);\nINFO(\"Second info\");\nUNSCOPED_INFO(\"Second unscoped info\");\nCHECK(false);\n}\n</code></pre> <p>\"Baz\" test case prints: <pre><code>Info from helper\nThe number is 0\nThe number is 1\n</code></pre></p> <p>With \"Qux\" test case, two messages will be printed when the first <code>CHECK</code> fails: <pre><code>First info\nFirst unscoped info\n</code></pre></p> <p>\"First unscoped info\" message will be cleared after the first <code>CHECK</code>, while \"First info\" message will persist until the end of the test case. Therefore, when the second <code>CHECK</code> fails, three messages will be printed: <pre><code>First info\nSecond info\nSecond unscoped info\n</code></pre></p>"},{"location":"logging/#streaming-macros","title":"Streaming macros","text":"<p>All these macros allow heterogeneous sequences of values to be streaming using the insertion operator (<code>&lt;&lt;</code>) in the same way that std::ostream, std::cout, etc support it.</p> <p>E.g.: <pre><code>INFO( \"The number is \" &lt;&lt; i );\n</code></pre></p> <p>(Note that there is no initial <code>&lt;&lt;</code> - instead the insertion sequence is placed in parentheses.) These macros come in three forms:</p> <p>INFO( message expression )</p> <p>The message is logged to a buffer, but only reported with next assertions that are logged. This allows you to log contextual information in case of failures which is not shown during a successful test run (for the console reporter, without -s). Messages are removed from the buffer at the end of their scope, so may be used, for example, in loops.</p> <p>Note that in Catch2 2.x.x <code>INFO</code> can be used without a trailing semicolon as there is a trailing semicolon inside macro. This semicolon will be removed with next major version. It is highly advised to use a trailing semicolon after <code>INFO</code> macro.</p> <p>UNSCOPED_INFO( message expression )</p> <p>Introduced in Catch2 2.7.0.</p> <p>Similar to <code>INFO</code>, but messages are not limited to their own scope: They are removed from the buffer after each assertion, section or test case, whichever comes first.</p> <p>WARN( message expression )</p> <p>The message is always reported but does not fail the test.</p> <p>FAIL( message expression )</p> <p>The message is reported and the test case fails.</p> <p>FAIL_CHECK( message expression )</p> <p>AS <code>FAIL</code>, but does not abort the test</p>"},{"location":"logging/#quickly-capture-value-of-variables-or-expressions","title":"Quickly capture value of variables or expressions","text":"<p>CAPTURE( expression1, expression2, ... )</p> <p>Sometimes you just want to log a value of variable, or expression. For convenience, we provide the <code>CAPTURE</code> macro, that can take a variable, or an expression, and prints out that variable/expression and its value at the time of capture.</p> <p>e.g. <code>CAPTURE( theAnswer );</code> will log message \"theAnswer := 42\", while <pre><code>int a = 1, b = 2, c = 3;\nCAPTURE( a, b, c, a + b, c &gt; b, a == 1);\n</code></pre> will log a total of 6 messages: <pre><code>a := 1\nb := 2\nc := 3\na + b := 3\nc &gt; b := true\na == 1 := true\n</code></pre></p> <p>You can also capture expressions that use commas inside parentheses (e.g. function calls), brackets, or braces (e.g. initializers). To properly capture expression that contains template parameters list (in other words, it contains commas between angle brackets), you need to enclose the expression inside parentheses: <code>CAPTURE( (std::pair&lt;int, int&gt;{1, 2}) );</code></p>"},{"location":"matchers/","title":"Matchers","text":""},{"location":"matchers/#matchers","title":"Matchers","text":"<p>Contents Using Matchers Built-in matchers Writing custom matchers (old style) Writing custom matchers (new style)</p> <p>Matchers, as popularized by the Hamcrest framework are an alternative way to write assertions, useful for tests where you work with complex types or need to assert more complex properties. Matchers are easily composable and users can write their own and combine them with the Catch2-provided matchers seamlessly.</p>"},{"location":"matchers/#using-matchers","title":"Using Matchers","text":"<p>Matchers are most commonly used in tandem with the <code>REQUIRE_THAT</code> or <code>CHECK_THAT</code> macros. The <code>REQUIRE_THAT</code> macro takes two arguments, the first one is the input (object/value) to test, the second argument is the matcher itself.</p> <p>For example, to assert that a string ends with the \"as a service\" substring, you can write the following assertion</p> <pre><code>using Catch::Matchers::EndsWith;\nREQUIRE_THAT( getSomeString(), EndsWith(\"as a service\") );\n</code></pre> <p>Individual matchers can also be combined using the C++ logical operators, that is <code>&amp;&amp;</code>, <code>||</code>, and <code>!</code>, like so:</p> <pre><code>using Catch::Matchers::EndsWith;\nusing Catch::Matchers::ContainsSubstring;\nREQUIRE_THAT( getSomeString(),\nEndsWith(\"as a service\") &amp;&amp; ContainsSubstring(\"web scale\"));\n</code></pre> <p>The example above asserts that the string returned from <code>getSomeString</code> both ends with the suffix \"as a service\" and contains the string \"web scale\" somewhere.</p> <p>Both of the string matchers used in the examples above live in the <code>catch_matchers_string.hpp</code> header, so to compile the code above also requires <code>#include &lt;catch2/matchers/catch_matchers_string.hpp&gt;</code>.</p> <p>IMPORTANT: The combining operators do not take ownership of the matcher objects being combined. This means that if you store combined matcher object, you have to ensure that the matchers being combined outlive its last use. What this means is that the following code leads to a use-after-free (UAF):</p> <pre><code>#include &lt;catch2/catch_test_macros.hpp&gt;\n#include &lt;catch2/matchers/catch_matchers_string.hpp&gt;\nTEST_CASE(\"Bugs, bugs, bugs\", \"[Bug]\"){\nstd::string str = \"Bugs as a service\";\nauto match_expression = Catch::Matchers::EndsWith( \"as a service\" ) ||\n(Catch::Matchers::StartsWith( \"Big data\" ) &amp;&amp; !Catch::Matchers::ContainsSubstring( \"web scale\" ) );\nREQUIRE_THAT(str, match_expression);\n}\n</code></pre>"},{"location":"matchers/#built-in-matchers","title":"Built-in matchers","text":"<p>Every matcher provided by Catch2 is split into 2 parts, a factory function that lives in the <code>Catch::Matchers</code> namespace, and the actual matcher type that is in some deeper namespace and should not be used by the user. In the examples above, we used <code>Catch::Matchers::Contains</code>. This is the factory function for the <code>Catch::Matchers::StdString::ContainsMatcher</code> type that does the actual matching.</p> <p>Out of the box, Catch2 provides the following matchers:</p>"},{"location":"matchers/#stdstring-matchers","title":"<code>std::string</code> matchers","text":"<p>Catch2 provides 5 different matchers that work with <code>std::string</code>, * <code>StartsWith(std::string str, CaseSensitive)</code>, * <code>EndsWith(std::string str, CaseSensitive)</code>, * <code>ContainsSubstring(std::string str, CaseSensitive)</code>, * <code>Equals(std::string str, CaseSensitive)</code>, and * <code>Matches(std::string str, CaseSensitive)</code>.</p> <p>The first three should be fairly self-explanatory, they succeed if the argument starts with <code>str</code>, ends with <code>str</code>, or contains <code>str</code> somewhere inside it.</p> <p>The <code>Equals</code> matcher matches a string if (and only if) the argument string is equal to <code>str</code>.</p> <p>Finally, the <code>Matches</code> matcher performs an ECMAScript regex match using <code>str</code> against the argument string. It is important to know that the match is performed against the string as a whole, meaning that the regex <code>\"abc\"</code> will not match input string <code>\"abcd\"</code>. To match <code>\"abcd\"</code>, you need to use e.g. <code>\"abc.*\"</code> as your regex.</p> <p>The second argument sets whether the matching should be case-sensitive or not. By default, it is case-sensitive.</p> <p><code>std::string</code> matchers live in <code>catch2/matchers/catch_matchers_string.hpp</code></p>"},{"location":"matchers/#vector-matchers","title":"Vector matchers","text":"<p>Vector matchers have been deprecated in favour of the generic range matchers with the same functionality.</p> <p>Catch2 provides 5 built-in matchers that work on <code>std::vector</code>.</p> <p>These are</p> <ul> <li><code>Contains</code> which checks whether a specified vector is present in the result</li> <li><code>VectorContains</code> which checks whether a specified element is present in the result</li> <li><code>Equals</code> which checks whether the result is exactly equal (order matters) to a specific vector</li> <li><code>UnorderedEquals</code> which checks whether the result is equal to a specific vector under a permutation</li> <li><code>Approx</code> which checks whether the result is \"approx-equal\" (order matters, but comparison is done via <code>Approx</code>) to a specific vector <p>Approx matcher was introduced in Catch2 2.7.2.</p> </li> </ul> <p>An example usage: <pre><code>    std::vector&lt;int&gt; some_vec{ 1, 2, 3 };\nREQUIRE_THAT(some_vec, Catch::Matchers::UnorderedEquals(std::vector&lt;int&gt;{ 3, 2, 1 }));\n</code></pre></p> <p>This assertions will pass, because the elements given to the matchers are a permutation of the ones in <code>some_vec</code>.</p> <p>vector matchers live in <code>catch2/matchers/catch_matchers_vector.hpp</code></p>"},{"location":"matchers/#floating-point-matchers","title":"Floating point matchers","text":"<p>Catch2 provides 4 matchers that target floating point numbers. These are:</p> <ul> <li><code>WithinAbs(double target, double margin)</code>,</li> <li><code>WithinULP(FloatingPoint target, uint64_t maxUlpDiff)</code>, and</li> <li><code>WithinRel(FloatingPoint target, FloatingPoint eps)</code>.</li> <li><code>IsNaN()</code></li> </ul> <p><code>WithinRel</code> matcher was introduced in Catch2 2.10.0</p> <p><code>IsNaN</code> matcher was introduced in Catch2 3.3.2.</p> <p>The first three serve to compare two floating pointe numbers. For more details about how they work, read the docs on comparing floating point numbers.</p> <p><code>IsNaN</code> then does exactly what it says on the tin. It matches the input if it is a NaN (Not a Number). The advantage of using it over just plain <code>REQUIRE(std::isnan(x))</code>, is that if the check fails, with <code>REQUIRE</code> you won't see the value of <code>x</code>, but with <code>REQUIRE_THAT(x, IsNaN())</code>, you will.</p>"},{"location":"matchers/#miscellaneous-matchers","title":"Miscellaneous matchers","text":"<p>Catch2 also provides some matchers and matcher utilities that do not quite fit into other categories.</p> <p>The first one of them is the <code>Predicate(Callable pred, std::string description)</code> matcher. It creates a matcher object that calls <code>pred</code> for the provided argument. The <code>description</code> argument allows users to set what the resulting matcher should self-describe as if required.</p> <p>Do note that you will need to explicitly specify the type of the argument, like in this example:</p> <pre><code>REQUIRE_THAT(\"Hello olleH\",\nPredicate&lt;std::string&gt;(\n[] (std::string const&amp; str) -&gt; bool { return str.front() == str.back(); },\n\"First and last character should be equal\")\n);\n</code></pre> <p>the predicate matcher lives in <code>catch2/matchers/catch_matchers_predicate.hpp</code></p> <p>The other miscellaneous matcher utility is exception matching.</p>"},{"location":"matchers/#matching-exceptions","title":"Matching exceptions","text":"<p>Catch2 provides a utility macro for asserting that an expression throws exception of specific type, and that the exception has desired properties. The macro is <code>REQUIRE_THROWS_MATCHES(expr, ExceptionType, Matcher)</code>.</p> <p><code>REQUIRE_THROWS_MATCHES</code> macro lives in <code>catch2/matchers/catch_matchers.hpp</code></p> <p>Catch2 currently provides two matchers for exceptions. These are: * <code>Message(std::string message)</code>. * <code>MessageMatches(Matcher matcher)</code>.</p> <p><code>MessageMatches</code> was introduced in Catch2 3.3.0</p> <p><code>Message</code> checks that the exception's message, as returned from <code>what</code> is exactly equal to <code>message</code>.</p> <p><code>MessageMatches</code> applies the provided matcher on the exception's message, as returned from <code>what</code>. This is useful in conjunctions with the <code>std::string</code> matchers (e.g. <code>StartsWith</code>)</p> <p>Example use: <pre><code>REQUIRE_THROWS_MATCHES(throwsDerivedException(),  DerivedException,  Message(\"DerivedException::what\"));\nREQUIRE_THROWS_MATCHES(throwsDerivedException(),  DerivedException,  MessageMatches(StartsWith(\"DerivedException\")));\n</code></pre></p> <p>Note that <code>DerivedException</code> in the example above has to derive from <code>std::exception</code> for the example to work.</p> <p>the exception message matcher lives in <code>catch2/matchers/catch_matchers_exception.hpp</code></p>"},{"location":"matchers/#generic-range-matchers","title":"Generic range Matchers","text":"<p>Generic range matchers were introduced in Catch2 3.0.1</p> <p>Catch2 also provides some matchers that use the new style matchers definitions to handle generic range-like types. These are:</p> <ul> <li><code>IsEmpty()</code></li> <li><code>SizeIs(size_t target_size)</code></li> <li><code>SizeIs(Matcher size_matcher)</code></li> <li><code>Contains(T&amp;&amp; target_element, Comparator = std::equal_to&lt;&gt;{})</code></li> <li><code>Contains(Matcher element_matcher)</code></li> <li><code>AllMatch(Matcher element_matcher)</code></li> <li><code>AnyMatch(Matcher element_matcher)</code></li> <li><code>NoneMatch(Matcher element_matcher)</code></li> <li><code>AllTrue()</code>, <code>AnyTrue()</code>, <code>NoneTrue()</code></li> <li><code>RangeEquals(TargetRangeLike&amp;&amp;, Comparator = std::equal_to&lt;&gt;{})</code></li> <li><code>UnorderedRangeEquals(TargetRangeLike&amp;&amp;, Comparator = std::equal_to&lt;&gt;{})</code></li> </ul> <p><code>IsEmpty</code>, <code>SizeIs</code>, <code>Contains</code> were introduced in Catch2 3.0.1</p> <p><code>All/Any/NoneMatch</code> were introduced in Catch2 3.0.1</p> <p><code>All/Any/NoneTrue</code> were introduced in Catch2 3.1.0</p> <p><code>RangeEquals</code> and <code>UnorderedRangeEquals</code> matchers were introduced in Catch2 3.3.0</p> <p><code>IsEmpty</code> should be self-explanatory. It successfully matches objects that are empty according to either <code>std::empty</code>, or ADL-found <code>empty</code> free function.</p> <p><code>SizeIs</code> checks range's size. If constructed with <code>size_t</code> arg, the matchers accepts ranges whose size is exactly equal to the arg. If constructed from another matcher, then the resulting matcher accepts ranges whose size is accepted by the provided matcher.</p> <p><code>Contains</code> accepts ranges that contain specific element. There are again two variants, one that accepts the desired element directly, in which case a range is accepted if any of its elements is equal to the target element. The other variant is constructed from a matcher, in which case a range is accepted if any of its elements is accepted by the provided matcher.</p> <p><code>AllMatch</code>, <code>NoneMatch</code>, and <code>AnyMatch</code> match ranges for which either all, none, or any of the contained elements matches the given matcher, respectively.</p> <p><code>AllTrue</code>, <code>NoneTrue</code>, and <code>AnyTrue</code> match ranges for which either all, none, or any of the contained elements are <code>true</code>, respectively. It works for ranges of <code>bool</code>s and ranges of elements (explicitly) convertible to <code>bool</code>.</p> <p><code>RangeEquals</code> compares the range that the matcher is constructed with (the \"target range\") against the range to be tested, element-wise. The match succeeds if all elements from the two ranges compare equal (using <code>operator==</code> by default). The ranges do not need to be the same type, and the element types do not need to be the same, as long as they are comparable. (e.g. you may compare <code>std::vector&lt;int&gt;</code> to <code>std::array&lt;char&gt;</code>).</p> <p><code>UnorderedRangeEquals</code> is similar to <code>RangeEquals</code>, but the order does not matter. For example \"1, 2, 3\" would match \"3, 2, 1\", but not \"1, 1, 2, 3\" As with <code>RangeEquals</code>, <code>UnorderedRangeEquals</code> compares the individual elements using using <code>operator==</code> by default.</p> <p>Both <code>RangeEquals</code> and <code>UnorderedRangeEquals</code> optionally accept a predicate which can be used to compare the containers element-wise.</p> <p>To check a container elementwise against a given matcher, use <code>AllMatch</code>.</p>"},{"location":"matchers/#writing-custom-matchers-old-style","title":"Writing custom matchers (old style)","text":"<p>The old style of writing matchers has been introduced back in Catch Classic. To create an old-style matcher, you have to create your own type that derives from <code>Catch::Matchers::MatcherBase&lt;ArgT&gt;</code>, where <code>ArgT</code> is the type your matcher works for. Your type has to override two methods, <code>bool match(ArgT const&amp;) const</code>, and <code>std::string describe() const</code>.</p> <p>As the name suggests, <code>match</code> decides whether the provided argument is matched (accepted) by the matcher. <code>describe</code> then provides a human-oriented description of what the matcher does.</p> <p>We also recommend that you create factory function, just like Catch2 does, but that is mostly useful for template argument deduction for templated matchers (assuming you do not have CTAD available).</p> <p>To combine these into an example, let's say that you want to write a matcher that decides whether the provided argument is a number within certain range. We will call it <code>IsBetweenMatcher&lt;T&gt;</code>:</p> <pre><code>#include &lt;catch2/catch_test_macros.hpp&gt;\n#include &lt;catch2/matchers/catch_matchers.hpp&gt;\n// ...\ntemplate &lt;typename T&gt;\nclass IsBetweenMatcher : public Catch::Matchers::MatcherBase&lt;T&gt; {\nT m_begin, m_end;\npublic:\nIsBetweenMatcher(T begin, T end) : m_begin(begin), m_end(end) {}\nbool match(T const&amp; in) const override {\nreturn in &gt;= m_begin &amp;&amp; in &lt;= m_end;\n}\nstd::string describe() const override {\nstd::ostringstream ss;\nss &lt;&lt; \"is between \" &lt;&lt; m_begin &lt;&lt; \" and \" &lt;&lt; m_end;\nreturn ss.str();\n}\n};\ntemplate &lt;typename T&gt;\nIsBetweenMatcher&lt;T&gt; IsBetween(T begin, T end) {\nreturn { begin, end };\n}\n// ...\nTEST_CASE(\"Numbers are within range\") {\n// infers `double` for the argument type of the matcher\nCHECK_THAT(3., IsBetween(1., 10.));\n// infers `int` for the argument type of the matcher\nCHECK_THAT(100, IsBetween(1, 10));\n}\n</code></pre> <p>Obviously, the code above can be improved somewhat, for example you might want to <code>static_assert</code> over the fact that <code>T</code> is an arithmetic type... or generalize the matcher to cover any type for which the user can provide a comparison function object.</p> <p>Note that while any matcher written using the old style can also be written using the new style, combining old style matchers should generally compile faster. Also note that you can combine old and new style matchers arbitrarily.</p> <p><code>MatcherBase</code> lives in <code>catch2/matchers/catch_matchers.hpp</code></p>"},{"location":"matchers/#writing-custom-matchers-new-style","title":"Writing custom matchers (new style)","text":"<p>New style matchers were introduced in Catch2 3.0.1</p> <p>To create a new-style matcher, you have to create your own type that derives from <code>Catch::Matchers::MatcherGenericBase</code>. Your type has to also provide two methods, <code>bool match( ... ) const</code> and overridden <code>std::string describe() const</code>.</p> <p>Unlike with old-style matchers, there are no requirements on how the <code>match</code> member function takes its argument. This means that the argument can be taken by value or by mutating reference, but also that the matcher's <code>match</code> member function can be templated.</p> <p>This allows you to write more complex matcher, such as a matcher that can compare one range-like (something that responds to <code>begin</code> and <code>end</code>) object to another, like in the following example:</p> <pre><code>#include &lt;catch2/catch_test_macros.hpp&gt;\n#include &lt;catch2/matchers/catch_matchers_templated.hpp&gt;\n// ...\ntemplate&lt;typename Range&gt;\nstruct EqualsRangeMatcher : Catch::Matchers::MatcherGenericBase {\nEqualsRangeMatcher(Range const&amp; range):\nrange{ range }\n{}\ntemplate&lt;typename OtherRange&gt;\nbool match(OtherRange const&amp; other) const {\nusing std::begin; using std::end;\nreturn std::equal(begin(range), end(range), begin(other), end(other));\n}\nstd::string describe() const override {\nreturn \"Equals: \" + Catch::rangeToString(range);\n}\nprivate:\nRange const&amp; range;\n};\ntemplate&lt;typename Range&gt;\nauto EqualsRange(const Range&amp; range) -&gt; EqualsRangeMatcher&lt;Range&gt; {\nreturn EqualsRangeMatcher&lt;Range&gt;{range};\n}\nTEST_CASE(\"Combining templated matchers\", \"[matchers][templated]\") {\nstd::array&lt;int, 3&gt; container{{ 1,2,3 }};\nstd::array&lt;int, 3&gt; a{{ 1,2,3 }};\nstd::vector&lt;int&gt; b{ 0,1,2 };\nstd::list&lt;int&gt; c{ 4,5,6 };\nREQUIRE_THAT(container, EqualsRange(a) || EqualsRange(b) || EqualsRange(c));\n}\n</code></pre> <p>Do note that while you can rewrite any matcher from the old style to a new style matcher, combining new style matchers is more expensive in terms of compilation time. Also note that you can combine old style and new style matchers arbitrarily.</p> <p><code>MatcherGenericBase</code> lives in <code>catch2/matchers/catch_matchers_templated.hpp</code></p>"},{"location":"migrate-v2-to-v3/","title":"Migrate v2 to v3","text":""},{"location":"migrate-v2-to-v3/#migrating-from-v2-to-v3","title":"Migrating from v2 to v3","text":"<p>v3 is the next major version of Catch2 and brings three significant changes:  * Catch2 is now split into multiple headers  * Catch2 is now compiled as a static library  * C++14 is the minimum required C++ version</p> <p>There are many reasons why we decided to go from the old single-header distribution model to a more standard library distribution model. The big one is compile-time performance, but moving over to a split header distribution model also improves the future maintainability and extendability of the codebase. For example v3 adds a new kind of matchers without impacting the compilation times of users that do not use matchers in their tests. The new model is also more friendly towards package managers, such as vcpkg and Conan.</p> <p>The result of this move is a significant improvement in compilation times, e.g. the inclusion overhead of Catch2 in the common case has been reduced by roughly 80%. The improved ease of maintenance also led to various runtime performance improvements and the introduction of new features. For details, look at the release notes of 3.0.1.</p> <p>Note that we still provide one header + one translation unit (TU) distribution but do not consider it the primarily supported option. You should also expect that the compilation times will be worse if you use this option.</p>"},{"location":"migrate-v2-to-v3/#how-to-migrate-projects-from-v2-to-v3","title":"How to migrate projects from v2 to v3","text":"<p>To migrate to v3, there are two basic approaches to do so.</p> <ol> <li>Use <code>catch_amalgamated.hpp</code> and <code>catch_amalgamated.cpp</code>.</li> <li>Build Catch2 as a proper (static) library, and move to piecewise headers</li> </ol> <p>Doing 1 means downloading the amalgamated header and the amalgamated sources from <code>extras</code>, dropping them into your test project, and rewriting your includes from <code>&lt;catch2/catch.hpp&gt;</code> to <code>\"catch_amalgamated.hpp\"</code> (or something similar, based on how you set up your paths).</p> <p>The disadvantage of using this approach are increased compilation times, at least compared to the second approach, but it does let you avoid dealing with consuming libraries in your build system of choice.</p> <p>However, we recommend doing 2, and taking extra time to migrate to v3 properly. This lets you reap the benefits of significantly improved compilation times in the v3 version. The basic steps to do so are:</p> <ol> <li>Change your CMakeLists.txt to link against <code>Catch2WithMain</code> target if you use Catch2's default main. (If you do not, keep linking against the <code>Catch2</code> target.). If you use pkg-config, change <code>pkg-config catch2</code> to <code>pkg-config catch2-with-main</code>.</li> <li>Delete TU with <code>CATCH_CONFIG_RUNNER</code> or <code>CATCH_CONFIG_MAIN</code> defined, as it is no longer needed.</li> <li>Change <code>#include &lt;catch2/catch.hpp&gt;</code> to <code>#include &lt;catch2/catch_all.hpp&gt;</code></li> <li>Check that everything compiles. You might have to modify namespaces, or perform some other changes (see the Things that can break during porting section for the most common things).</li> <li>Start migrating your test TUs from including <code>&lt;catch2/catch_all.hpp&gt;</code> to piecemeal includes. You will likely want to start by including <code>&lt;catch2/catch_test_macros.hpp&gt;</code>, and then go from there. (see other notes for further ideas)</li> </ol>"},{"location":"migrate-v2-to-v3/#other-notes","title":"Other notes","text":"<ul> <li> <p>The main test include is now <code>&lt;catch2/catch_test_macros.hpp&gt;</code></p> </li> <li> <p>Big \"subparts\" like Matchers, or Generators, have their own folder, and also their own \"big header\", so if you just want to include all matchers, you can include <code>&lt;catch2/matchers/catch_matchers_all.hpp&gt;</code>, or <code>&lt;catch2/generators/catch_generators_all.hpp&gt;</code></p> </li> </ul>"},{"location":"migrate-v2-to-v3/#things-that-can-break-during-porting","title":"Things that can break during porting","text":"<ul> <li>The namespaces of Matchers were flattened and cleaned up.</li> </ul> <p>Matchers are no longer declared deep within an internal namespace and then brought up into <code>Catch</code> namespace. All Matchers now live in the <code>Catch::Matchers</code> namespace.</p> <ul> <li> <p>The <code>Contains</code> string matcher was renamed to <code>ContainsSubstring</code>.</p> </li> <li> <p>The reporter interfaces changed in a breaking manner.</p> </li> </ul> <p>If you are using a custom reporter or listener, you will likely need to modify them to conform to the new interfaces. Unlike before in v2, the interfaces and the events are now documented.</p>"},{"location":"opensource-users/","title":"Opensource users","text":""},{"location":"opensource-users/#open-source-projects-using-catch2","title":"Open Source projects using Catch2","text":"<p>Catch2 is great for open source. It is licensed under the Boost Software License (BSL), has no further dependencies and supports two file distribution.</p> <p>As a result, Catch2 is used for testing in many different Open Source projects. This page lists at least some of them, even though it will obviously never be complete (and does not have the ambition to be complete). Note that the list below is intended to be in alphabetical order, to avoid implications of relative importance of the projects.</p> <p>Please only add projects here if you are their maintainer, or have the maintainer's explicit consent.</p>"},{"location":"opensource-users/#libraries-frameworks","title":"Libraries &amp; Frameworks","text":""},{"location":"opensource-users/#accessorpp","title":"accessorpp","text":"<p>C++ library for implementing property and data binding.</p>"},{"location":"opensource-users/#alpaka","title":"alpaka","text":"<p>A header-only C++14 abstraction library for accelerator development.</p>"},{"location":"opensource-users/#approvaltestscpp","title":"ApprovalTests.cpp","text":"<p>C++11 implementation of Approval Tests, for quick, convenient testing of legacy code.</p>"},{"location":"opensource-users/#args","title":"args","text":"<p>A simple header-only C++ argument parser library.</p>"},{"location":"opensource-users/#azmq","title":"Azmq","text":"<p>Boost Asio style bindings for ZeroMQ.</p>"},{"location":"opensource-users/#cataclysm-dark-days-ahead","title":"Cataclysm: Dark Days Ahead","text":"<p>Post-apocalyptic survival RPG.</p>"},{"location":"opensource-users/#chaiscript","title":"ChaiScript","text":"<p>A, header-only, embedded scripting language designed from the ground up to directly target C++ and take advantage of modern C++ development techniques.</p>"},{"location":"opensource-users/#chakracore","title":"ChakraCore","text":"<p>The core part of the Chakra JavaScript engine that powers Microsoft Edge.</p>"},{"location":"opensource-users/#clara","title":"Clara","text":"<p>A, single-header-only, type-safe, command line parser - which also prints formatted usage strings.</p>"},{"location":"opensource-users/#couchbase-lite-core","title":"Couchbase-lite-core","text":"<p>The next-generation core storage and query engine for Couchbase Lite.</p>"},{"location":"opensource-users/#cppcodec","title":"cppcodec","text":"<p>Header-only C++11 library to encode/decode base64, base64url, base32, base32hex and hex (a.k.a. base16) as specified in RFC 4648, plus Crockford's base32.</p>"},{"location":"opensource-users/#dtcraft","title":"DtCraft","text":"<p>A High-performance Cluster Computing Engine.</p>"},{"location":"opensource-users/#eventpp","title":"eventpp","text":"<p>C++ event library for callbacks, event dispatcher, and event queue. With eventpp you can easily implement signal and slot mechanism, publisher and subscriber pattern, or observer pattern.</p>"},{"location":"opensource-users/#forest","title":"forest","text":"<p>Template Library of Tree Data Structures.</p>"},{"location":"opensource-users/#fuxedo","title":"Fuxedo","text":"<p>Open source Oracle Tuxedo-like XATMI middleware for C and C++.</p>"},{"location":"opensource-users/#hip-cpu-runtime","title":"HIP CPU Runtime","text":"<p>A header-only library that allows CPUs to execute unmodified HIP code. It is generic and does not assume a particular CPU vendor or architecture.</p>"},{"location":"opensource-users/#inja","title":"Inja","text":"<p>A header-only template engine for modern C++.</p>"},{"location":"opensource-users/#llama","title":"LLAMA","text":"<p>A C++17 template header-only library for the abstraction of memory access patterns.</p>"},{"location":"opensource-users/#libcluon","title":"libcluon","text":"<p>A single-header-only library written in C++14 to glue distributed software components (UDP, TCP, shared memory) supporting natively Protobuf, LCM/ZCM, MsgPack, and JSON for dynamic message transformations in-between.</p>"},{"location":"opensource-users/#mnmlstc-core","title":"MNMLSTC Core","text":"<p>A small and easy to use C++11 library that adds a functionality set that will be available in C++14 and later, as well as some useful additions.</p>"},{"location":"opensource-users/#nanodbc","title":"nanodbc","text":"<p>A small C++ library wrapper for the native C ODBC API.</p>"},{"location":"opensource-users/#nonius","title":"Nonius","text":"<p>A header-only framework for benchmarking small snippets of C++ code.</p>"},{"location":"opensource-users/#openalpp","title":"OpenALpp","text":"<p>A modern OOP C++14 audio library built on OpenAL for Windows, Linux and web (emscripten).</p>"},{"location":"opensource-users/#polymorphic_value","title":"polymorphic_value","text":"<p>A polymorphic value-type for C++.</p>"},{"location":"opensource-users/#ppconsul","title":"Ppconsul","text":"<p>A C++ client library for Consul. Consul is a distributed tool for discovering and configuring services in your infrastructure.</p>"},{"location":"opensource-users/#reactive-extensions-rxcpp","title":"Reactive-Extensions/ RxCpp","text":"<p>A library of algorithms for values-distributed-in-time.</p>"},{"location":"opensource-users/#sfml","title":"SFML","text":"<p>Simple and Fast Multimedia Library.</p>"},{"location":"opensource-users/#soci","title":"SOCI","text":"<p>The C++ Database Access Library.</p>"},{"location":"opensource-users/#textflowcpp","title":"TextFlowCpp","text":"<p>A small, single-header-only, library for wrapping and composing columns of text.</p>"},{"location":"opensource-users/#thor","title":"thor","text":"<p>Wrapper Library for CUDA.</p>"},{"location":"opensource-users/#toml","title":"toml++","text":"<p>A header-only TOML parser and serializer for modern C++.</p>"},{"location":"opensource-users/#trompeloeil","title":"Trompeloeil","text":"<p>A thread-safe header-only mocking framework for C++14.</p>"},{"location":"opensource-users/#wxwidgets","title":"wxWidgets","text":"<p>Cross-Platform C++ GUI Library.</p>"},{"location":"opensource-users/#xmlwrapp","title":"xmlwrapp","text":"<p>C++ XML parsing library using libxml2.</p>"},{"location":"opensource-users/#applications-tools","title":"Applications &amp; Tools","text":""},{"location":"opensource-users/#app-mesh","title":"App Mesh","text":"<p>A high available cloud native micro-service application management platform implemented by modern C++.</p>"},{"location":"opensource-users/#arangodb","title":"ArangoDB","text":"<p>ArangoDB is a native multi-model database with flexible data models for documents, graphs, and key-values.</p>"},{"location":"opensource-users/#cytopia","title":"Cytopia","text":"<p>Cytopia is a free, open source retro pixel-art city building game with a big focus on mods. It utilizes a custom isometric rendering engine based on SDL2.</p>"},{"location":"opensource-users/#d-seams","title":"d-SEAMS","text":"<p>Open source molecular dynamics simulation structure analysis suite of tools in modern C++.</p>"},{"location":"opensource-users/#giada-your-hardcore-loop-machine","title":"Giada - Your Hardcore Loop Machine","text":"<p>Minimal, open-source and cross-platform audio tool for live music production.</p>"},{"location":"opensource-users/#mame","title":"MAME","text":"<p>MAME originally stood for Multiple Arcade Machine Emulator.</p>"},{"location":"opensource-users/#newsbeuter","title":"Newsbeuter","text":"<p>Newsbeuter is an open-source RSS/Atom feed reader for text terminals.</p>"},{"location":"opensource-users/#pophead","title":"PopHead","text":"<p>A 2D, Zombie, RPG game which is being made on our own engine.</p>"},{"location":"opensource-users/#raspigcd","title":"raspigcd","text":"<p>Low level CLI app and library for execution of GCODE on Raspberry Pi without any additional microcontrollers (just RPi + Stepsticks).</p>"},{"location":"opensource-users/#spectre","title":"SpECTRE","text":"<p>SpECTRE is a code for multi-scale, multi-physics problems in astrophysics and gravitational physics.</p>"},{"location":"opensource-users/#standardese","title":"Standardese","text":"<p>Standardese aims to be a nextgen Doxygen.</p>"},{"location":"other-macros/","title":"Other macros","text":""},{"location":"other-macros/#other-macros","title":"Other macros","text":"<p>This page serves as a reference for macros that are not documented elsewhere. For now, these macros are separated into 2 rough categories, \"assertion related macros\" and \"test case related macros\".</p>"},{"location":"other-macros/#assertion-related-macros","title":"Assertion related macros","text":"<ul> <li><code>CHECKED_IF</code> and <code>CHECKED_ELSE</code></li> </ul> <p><code>CHECKED_IF( expr )</code> is an <code>if</code> replacement, that also applies Catch2's stringification machinery to the expr and records the result. As with <code>if</code>, the block after a <code>CHECKED_IF</code> is entered only if the expression evaluates to <code>true</code>. <code>CHECKED_ELSE( expr )</code> work similarly, but the block is entered only if the expr evaluated to <code>false</code>.</p> <p><code>CHECKED_X</code> macros were changed to not count as failure in Catch2 3.0.1.</p> <p>Example: <pre><code>int a = ...;\nint b = ...;\nCHECKED_IF( a == b ) {\n// This block is entered when a == b\n} CHECKED_ELSE ( a == b ) {\n// This block is entered when a != b\n}\n</code></pre></p> <ul> <li><code>CHECK_NOFAIL</code></li> </ul> <p><code>CHECK_NOFAIL( expr )</code> is a variant of <code>CHECK</code> that does not fail the test case if expr evaluates to <code>false</code>. This can be useful for checking some assumption, that might be violated without the test necessarily failing.</p> <p>Example output: <pre><code>main.cpp:6:\nFAILED - but was ok:\n  CHECK_NOFAIL( 1 == 2 )\n\nmain.cpp:7:\nPASSED:\n  CHECK( 2 == 2 )\n</code></pre></p> <ul> <li><code>SUCCEED</code></li> </ul> <p><code>SUCCEED( msg )</code> is mostly equivalent with <code>INFO( msg ); REQUIRE( true );</code>. In other words, <code>SUCCEED</code> is for cases where just reaching a certain line means that the test has been a success.</p> <p>Example usage: <pre><code>TEST_CASE( \"SUCCEED showcase\" ) {\nint I = 1;\nSUCCEED( \"I is \" &lt;&lt; I );\n}\n</code></pre></p> <ul> <li><code>STATIC_REQUIRE</code> and <code>STATIC_CHECK</code></li> </ul> <p><code>STATIC_REQUIRE</code> was introduced in Catch2 2.4.2.</p> <p><code>STATIC_REQUIRE( expr )</code> is a macro that can be used the same way as a <code>static_assert</code>, but also registers the success with Catch2, so it is reported as a success at runtime. The whole check can also be deferred to the runtime, by defining <code>CATCH_CONFIG_RUNTIME_STATIC_REQUIRE</code> before including the Catch2 header.</p> <p>Example: <pre><code>TEST_CASE(\"STATIC_REQUIRE showcase\", \"[traits]\") {\nSTATIC_REQUIRE( std::is_void&lt;void&gt;::value );\nSTATIC_REQUIRE_FALSE( std::is_void&lt;int&gt;::value );\n}\n</code></pre></p> <p><code>STATIC_CHECK</code> was introduced in Catch2 3.0.1.</p> <p><code>STATIC_CHECK( expr )</code> is equivalent to <code>STATIC_REQUIRE( expr )</code>, with the difference that when <code>CATCH_CONFIG_RUNTIME_STATIC_REQUIRE</code> is defined, it becomes equivalent to <code>CHECK</code> instead of <code>REQUIRE</code>.</p> <p>Example: <pre><code>TEST_CASE(\"STATIC_CHECK showcase\", \"[traits]\") {\nSTATIC_CHECK( std::is_void&lt;void&gt;::value );\nSTATIC_CHECK_FALSE( std::is_void&lt;int&gt;::value );\n}\n</code></pre></p>"},{"location":"other-macros/#test-case-related-macros","title":"Test case related macros","text":"<ul> <li><code>METHOD_AS_TEST_CASE</code></li> </ul> <p><code>METHOD_AS_TEST_CASE( member-function-pointer, description )</code> lets you register a member function of a class as a Catch2 test case. The class will be separately instantiated for each method registered in this way.</p> <pre><code>class TestClass {\nstd::string s;\npublic:\nTestClass()\n:s( \"hello\" )\n{}\nvoid testCase() {\nREQUIRE( s == \"hello\" );\n}\n};\nMETHOD_AS_TEST_CASE( TestClass::testCase, \"Use class's method as a test case\", \"[class]\" )\n</code></pre> <ul> <li><code>REGISTER_TEST_CASE</code></li> </ul> <p><code>REGISTER_TEST_CASE( function, description )</code> let's you register a <code>function</code> as a test case. The function has to have <code>void()</code> signature, the description can contain both name and tags.</p> <p>Example: <pre><code>REGISTER_TEST_CASE( someFunction, \"ManuallyRegistered\", \"[tags]\" );\n</code></pre></p> <p>Note that the registration still has to happen before Catch2's session is initiated. This means that it either needs to be done in a global constructor, or before Catch2's session is created in user's own main.</p> <ul> <li><code>DYNAMIC_SECTION</code></li> </ul> <p>Introduced in Catch2 2.3.0.</p> <p><code>DYNAMIC_SECTION</code> is a <code>SECTION</code> where the user can use <code>operator&lt;&lt;</code> to create the final name for that section. This can be useful with e.g. generators, or when creating a <code>SECTION</code> dynamically, within a loop.</p> <p>Example: <pre><code>TEST_CASE( \"looped SECTION tests\" ) {\nint a = 1;\nfor( int b = 0; b &lt; 10; ++b ) {\nDYNAMIC_SECTION( \"b is currently: \" &lt;&lt; b ) {\nCHECK( b &gt; a );\n}\n}\n}\n</code></pre></p>"},{"location":"own-main/","title":"Own main","text":""},{"location":"own-main/#supplying-main-yourself","title":"Supplying main() yourself","text":"<p>Contents Let Catch2 take full control of args and config Amending the Catch2 config Adding your own command line options Version detection</p> <p>The easiest way to use Catch2 is to use its own <code>main</code> function, and let it handle the command line arguments. This is done by linking against Catch2Main library, e.g. through the CMake target, or pkg-config files.</p> <p>If you want to provide your own <code>main</code>, then you should link against the static library (target) only, without the main part. You will then have to write your own <code>main</code> and call into Catch2 test runner manually.</p> <p>Below are some basic recipes on what you can do supplying your own main.</p>"},{"location":"own-main/#let-catch2-take-full-control-of-args-and-config","title":"Let Catch2 take full control of args and config","text":"<p>This is useful if you just need to have code that executes before/after Catch2 runs tests.</p> <pre><code>#include &lt;catch2/catch_session.hpp&gt;\nint main( int argc, char* argv[] ) {\n// your setup ...\nint result = Catch::Session().run( argc, argv );\n// your clean-up...\nreturn result;\n}\n</code></pre> <p>Note that if you only want to run some set up before tests are run, it might be simpler to use event listeners instead.</p>"},{"location":"own-main/#amending-the-catch2-config","title":"Amending the Catch2 config","text":"<p>If you want Catch2 to process command line arguments, but also want to programmatically change the resulting configuration of Catch2 run, you can do it in two ways:</p> <pre><code>int main( int argc, char* argv[] ) {\nCatch::Session session; // There must be exactly one instance\n// writing to session.configData() here sets defaults\n// this is the preferred way to set them\nint returnCode = session.applyCommandLine( argc, argv );\nif( returnCode != 0 ) // Indicates a command line error\nreturn returnCode;\n// writing to session.configData() or session.Config() here\n// overrides command line args\n// only do this if you know you need to\nint numFailed = session.run();\n// numFailed is clamped to 255 as some unices only use the lower 8 bits.\n// This clamping has already been applied, so just return it here\n// You can also do any post run clean-up here\nreturn numFailed;\n}\n</code></pre> <p>If you want full control of the configuration, don't call <code>applyCommandLine</code>.</p>"},{"location":"own-main/#adding-your-own-command-line-options","title":"Adding your own command line options","text":"<p>You can add new command line options to Catch2, by composing the premade CLI parser (called Clara), and add your own options.</p> <pre><code>int main( int argc, char* argv[] ) {\nCatch::Session session; // There must be exactly one instance\nint height = 0; // Some user variable you want to be able to set\n// Build a new parser on top of Catch2's\nusing namespace Catch::Clara;\nauto cli\n= session.cli()           // Get Catch2's command line parser\n| Opt( height, \"height\" ) // bind variable to a new option, with a hint string\n[\"-g\"][\"--height\"]    // the option names it will respond to\n(\"how high?\");        // description string for the help output\n// Now pass the new composite back to Catch2 so it uses that\nsession.cli( cli );\n// Let Catch2 (using Clara) parse the command line\nint returnCode = session.applyCommandLine( argc, argv );\nif( returnCode != 0 ) // Indicates a command line error\nreturn returnCode;\n// if set on the command line then 'height' is now set at this point\nif( height &gt; 0 )\nstd::cout &lt;&lt; \"height: \" &lt;&lt; height &lt;&lt; std::endl;\nreturn session.run();\n}\n</code></pre> <p>See the Clara documentation for more details on how to use the Clara parser.</p>"},{"location":"own-main/#version-detection","title":"Version detection","text":"<p>Catch2 provides a triplet of macros providing the header's version,</p> <ul> <li><code>CATCH_VERSION_MAJOR</code></li> <li><code>CATCH_VERSION_MINOR</code></li> <li><code>CATCH_VERSION_PATCH</code></li> </ul> <p>these macros expand into a single number, that corresponds to the appropriate part of the version. As an example, given single header version v2.3.4, the macros would expand into <code>2</code>, <code>3</code>, and <code>4</code> respectively.</p>"},{"location":"release-notes/","title":"Release notes","text":""},{"location":"release-notes/#release-notes","title":"Release notes","text":"<p>Contents 3.3.2 3.3.1 3.3.0 3.2.1 3.2.0 3.1.1 3.1.0 3.0.1 2.13.7 2.13.6 2.13.5 2.13.4 2.13.3 2.13.2 2.13.1 2.13.0 2.12.4 2.12.3 2.12.2 2.12.1 2.12.0 2.11.3 2.11.2 2.11.1 2.11.0 2.10.2 2.10.1 2.10.0 2.9.2 2.9.1 2.9.0 2.8.0 2.7.2 2.7.1 2.7.0 2.6.1 2.6.0 2.5.0 2.4.2 2.4.1 2.4.0 2.3.0 2.2.3 2.2.2 2.2.1 2.2.0 2.1.2 2.1.1 2.1.0 2.0.1 Older versions Even Older versions</p>"},{"location":"release-notes/#332","title":"3.3.2","text":""},{"location":"release-notes/#improvements","title":"Improvements","text":"<ul> <li>Further reduced allocations</li> <li>The compact, console, TAP and XML reporters perform less allocations in various cases</li> <li>Removed 1 allocation per entered <code>SECTION</code>/<code>TEST_CASE</code>.</li> <li>Removed 2 allocations per test case exit, if stdout/stderr is captured</li> <li>Improved performance</li> <li>Section tracking is 10%-25% faster than in v3.3.0</li> <li>Assertion handling is 5%-10% faster than in v3.3.0</li> <li>Test case registration is 1%-2% faster than in v3.3.0</li> <li>Tiny speedup for registering listeners</li> <li>Tiny speedup for <code>CAPTURE</code>, <code>TEST_CASE_METHOD</code>, <code>METHOD_AS_TEST_CASE</code>, and <code>TEMPLATE_LIST_TEST_*</code> macros.</li> <li><code>Contains</code>, <code>RangeEquals</code> and <code>UnorderedRangeEquals</code> matchers now support ranges with iterator + sentinel pair</li> <li>Added <code>IsNaN</code> matcher</li> <li>Unlike <code>REQUIRE(isnan(x))</code>, <code>REQUIRE_THAT(x, IsNaN())</code> shows you the value of <code>x</code>.</li> <li>Suppressed <code>declared_but_not_referenced</code> warning for NVHPC (#2637)</li> </ul>"},{"location":"release-notes/#fixes","title":"Fixes","text":"<ul> <li>Fixed performance regression in section tracking introduced in v3.3.1</li> <li>Extreme cases would cause the tracking to run about 4x slower than in 3.3.0</li> </ul>"},{"location":"release-notes/#331","title":"3.3.1","text":""},{"location":"release-notes/#improvements_1","title":"Improvements","text":"<ul> <li>Reduced allocations and improved performance</li> <li>The exact improvements are dependent on your usage of Catch2.</li> <li>For example running Catch2's SelfTest binary performs 8k less allocations.</li> <li>The main improvement comes from smarter handling of <code>SECTION</code>s, especially sibling <code>SECTION</code>s</li> </ul>"},{"location":"release-notes/#330","title":"3.3.0","text":""},{"location":"release-notes/#improvements_2","title":"Improvements","text":"<ul> <li>Added <code>MessageMatches</code> exception matcher (#2570)</li> <li>Added <code>RangeEquals</code> and <code>UnorderedRangeEquals</code> generic range matchers (#2377)</li> <li>Added <code>SKIP</code> macro for skipping tests from within the test body (#2360)</li> <li>All built-in reporters have been extended to handle it properly, whether your custom reporter needs changes depends on how it was written</li> <li><code>skipTest</code> reporter event is unrelated to this, and has been deprecated since it has practically no uses</li> <li>Restored support for PPC Macs in the break-into-debugger functionality (#2619)</li> <li>Made our warning suppression compatible with CUDA toolkit pre 11.5 (#2626)</li> <li>Cleaned out some static analysis complaints</li> </ul>"},{"location":"release-notes/#fixes_1","title":"Fixes","text":"<ul> <li>Fixed macro redefinition warning when NVCC was reporting as MSVC (#2603)</li> <li>Fixed throws in generator constructor causing the whole binary to abort (#2615)</li> <li>Now it just fails the test</li> <li>Fixed missing transitive include with libstdc++13 (#2611)</li> </ul>"},{"location":"release-notes/#miscellaneous","title":"Miscellaneous","text":"<ul> <li>Improved support for dynamic library build with non-MSVC compilers on Windows (#2630)</li> <li>When used as a subproject, Catch2 keeps its generated header in a separate directory from the main project (#2604)</li> </ul>"},{"location":"release-notes/#321","title":"3.2.1","text":""},{"location":"release-notes/#improvements_3","title":"Improvements","text":"<ul> <li>Fix the reworked decomposer to work with older (pre 9) GCC versions (#2571)</li> <li>This required more significant changes to properly support C++20, there might be bugs.</li> </ul>"},{"location":"release-notes/#320","title":"3.2.0","text":""},{"location":"release-notes/#improvements_4","title":"Improvements","text":"<ul> <li>Catch2 now compiles on PlayStation (#2562)</li> <li>Added <code>CATCH_CONFIG_GETENV</code> compile-time toggle (#2562)</li> <li>This toggle guards whether Catch2 calls <code>std::getenv</code> when reading env variables</li> <li>Added support for more Bazel test environment variables</li> <li><code>TESTBRIDGE_TEST_ONLY</code> is now supported (#2490)</li> <li>Sharding variables, <code>TEST_SHARD_INDEX</code>, <code>TEST_TOTAL_SHARDS</code>, <code>TEST_SHARD_STATUS_FILE</code>, are now all supported (#2491)</li> <li>Bunch of small tweaks and improvements in reporters</li> <li>The TAP and SonarQube reporters output the used test filters</li> <li>The XML reporter now also reports the version of its output format</li> <li>The compact reporter now uses the same summary output as the console reporter (#878, #2554)</li> <li>Added support for asserting on types that can only be compared with literal 0 (#2555)</li> <li>A canonical example is C++20's <code>std::*_ordering</code> types, which cannot be compared with an <code>int</code> variable, only <code>0</code></li> <li>The support extends to any type with this property, not just the ones in stdlib</li> <li>This change imposes 2-3% slowdown on compiling files that are heavy on <code>REQUIRE</code> and friends</li> <li>This required significant rewrite of decomposition, there might be bugs</li> <li>Simplified internals of matcher related macros</li> <li>This provides about ~2% speed up compiling files that are heavy on <code>REQUIRE_THAT</code> and friends</li> </ul>"},{"location":"release-notes/#fixes_2","title":"Fixes","text":"<ul> <li>Cleaned out some warnings and static analysis issues</li> <li>Suppressed <code>-Wcomma</code> warning rarely occurring in templated test cases (#2543)</li> <li>Constified implementation details in <code>INFO</code> (#2564)</li> <li>Made <code>MatcherGenericBase</code> copy constructor const (#2566)</li> <li>Fixed serialization of test filters so the output roundtrips</li> <li>This means that e.g. <code>./tests/SelfTest \"aaa bbb\", [approx]</code> outputs <code>Filters: \"aaa bbb\",[approx]</code></li> </ul>"},{"location":"release-notes/#miscellaneous_1","title":"Miscellaneous","text":"<ul> <li>Catch2's build no longer leaks <code>-ffile-prefix-map</code> setting  to dependees (#2533)</li> </ul>"},{"location":"release-notes/#311","title":"3.1.1","text":""},{"location":"release-notes/#improvements_5","title":"Improvements","text":"<ul> <li>Added <code>Catch::getSeed</code> function that user code can call to retrieve current rng-seed</li> <li>Better detection of compiler support for <code>-ffile-prefix-map</code> (#2517)</li> <li>Catch2's shared libraries now have <code>SOVERSION</code> set (#2516)</li> <li><code>catch2/catch_all.hpp</code> convenience header no longer transitively includes <code>windows.h</code> (#2432, #2526)</li> </ul>"},{"location":"release-notes/#fixes_3","title":"Fixes","text":"<ul> <li>Fixed compilation on Universal Windows Platform</li> <li>Fixed compilation on VxWorks (#2515)</li> <li>Fixed compilation on Cygwin (#2540)</li> <li>Remove unused variable in reporter registration (#2538)</li> <li>Fixed some symbol visibility issues with dynamic library on Windows (#2527)</li> <li>Suppressed <code>-Wuseless-cast</code> warnings in <code>REQUIRE_THROWS*</code> macros (#2520, #2521)</li> <li>This was triggered when the potentially throwing expression evaluates to <code>void</code></li> <li>Fixed \"warning: storage class is not first\" with <code>nvc++</code> (#2533)</li> <li>Fixed handling of <code>DL_PATHS</code> argument to <code>catch_discover_tests</code> on MacOS (#2483)</li> <li>Suppressed <code>*-avoid-c-arrays</code> clang-tidy warning in <code>TEMPLATE_TEST_CASE</code> (#2095, #2536)</li> </ul>"},{"location":"release-notes/#miscellaneous_2","title":"Miscellaneous","text":"<ul> <li>Fixed CMake install step for Catch2 build as dynamic library (#2485)</li> <li>Raised minimum CMake version to 3.10 (#2523)</li> <li>Expect the minimum CMake version to increase once more in next few releases.</li> <li>Whole bunch of doc updates and fixes</li> <li> </li> <li>Added support for building Catch2 with Meson (#2530, #2539)</li> </ul>"},{"location":"release-notes/#1444-2497-2547-2549-and-more","title":"1444, #2497, #2547, #2549, and more","text":""},{"location":"release-notes/#310","title":"3.1.0","text":""},{"location":"release-notes/#improvements_6","title":"Improvements","text":"<ul> <li>Improved suppression of <code>-Wparentheses</code> for older GCCs</li> <li>Turns out that even GCC 9 does not properly handle <code>_Pragma</code>s in the C++ frontend.</li> <li>Added type constraints onto <code>random</code> generator (#2433)</li> <li>These constraints copy what the standard says for the underlying <code>std::uniform_int_distribution</code></li> <li>Suppressed -Wunused-variable from nvcc (#2306, #2427)</li> <li>Suppressed -Wunused-variable from MinGW (#2132)</li> <li>Added All/Any/NoneTrue range matchers (#2319)</li> <li>These check that all/any/none of boolean values in a range are true.</li> <li>The JUnit reporter now normalizes classnames from C++ namespaces to Java-like namespaces (#2468)</li> <li>This provides better support for other JUnit based tools.</li> <li>The Bazel support now understands <code>BAZEL_TEST</code> environment variable (#2459)</li> <li>The <code>CATCH_CONFIG_BAZEL_SUPPORT</code> configuration option is also still supported.</li> <li>Returned support for compiling Catch2 with GCC 5 (#2448)</li> <li>This required removing inherited constructors from Catch2's internals.</li> <li>I recommend updating to a newer GCC anyway.</li> <li><code>catch_discover_tests</code> now has a new options for setting library load path(s) when running the Catch2 binary (#2467)</li> </ul>"},{"location":"release-notes/#fixes_4","title":"Fixes","text":"<ul> <li>Fixed crash when listing listeners without any registered listeners (#2442)</li> <li>Fixed nvcc compilation error in constructor benchmarking helper (#2477)</li> <li>Catch2's CMakeList supports pre-3.12 CMake again (#2428)</li> <li>The gain from requiring CMake 3.12 was very minor, but y'all should really update to newer CMake</li> </ul>"},{"location":"release-notes/#miscellaneous_3","title":"Miscellaneous","text":"<ul> <li>Fixed SelfTest build on MinGW (#2447)</li> <li>The in-repo conan recipe exports the CMake helper (#2460)</li> <li>Added experimental CMake script to showcase using test case sharding together with CTest</li> <li>Compared to <code>catch_discover_tests</code>, it supports very limited number of options and customization</li> <li>Added documentation page on best practices when running Catch2 tests</li> <li>Catch2 can be built as a dynamic library (#2397, #2398)</li> <li>Note that Catch2 does not have visibility annotations, and you are responsible for ensuring correct visibility built into the resulting library.</li> </ul>"},{"location":"release-notes/#301","title":"3.0.1","text":"<p>Catch2 now uses statically compiled library as its distribution model. This also means that to get all of Catch2's functionality in a test file, you have to include multiple headers.</p> <p>You probably want to look into the migration docs, which were written to help people coming from v2.x.x versions to the v3 releases.</p>"},{"location":"release-notes/#faq","title":"FAQ","text":"<ul> <li>Why is Catch2 moving to separate headers?</li> <li>The short answer is future extensibility and scalability. The long answer is complex and can be found on my blog, but at the most basic level, it is that providing single-header distribution is at odds with providing variety of useful features. When Catch2 was distributed in a single header, adding a new Matcher would cause overhead for everyone, but was useful only to a subset of users. This meant that the barrier to entry for new Matchers/Generators/etc is high in single header model, but much smaller in the new model.</li> <li>Will Catch2 again distribute single-header version in the future?</li> <li>No. But we do provide sqlite-style amalgamated distribution option. This means that you can download just 1 .cpp file and 1 header and place them next to your own sources. However, doing this has downsides similar to using the <code>catch_all.hpp</code> header.</li> <li>Why the big breaking change caused by replacing <code>catch.hpp</code> with <code>catch_all.hpp</code>?</li> <li>The convenience header <code>catch_all.hpp</code> exists for two reasons. One of them is to provide a way for quick migration from Catch2, the second one is to provide a simple way to test things with Catch2. Using it for migration has one drawback in that it is big. This means that including it will cause significant compile time drag, and so using it to migrate should be a conscious decision by the user, not something they can just stumble into unknowingly.</li> </ul>"},{"location":"release-notes/#potentially-breaking-changes","title":"(Potentially) Breaking changes","text":"<ul> <li>Catch2 now uses statically compiled library as its distribution model</li> <li>Including <code>catch.hpp</code> no longer works</li> <li>Catch2 now uses C++14 as the minimum support language version</li> <li><code>ANON_TEST_CASE</code> has been removed, use <code>TEST_CASE</code> with no arguments instead (#1220)</li> <li><code>--list*</code> commands no longer have non-zero return code (#1410)</li> <li><code>--list-test-names-only</code> has been removed (#1190)</li> <li>You should use verbosity-modifiers for <code>--list-tests</code> instead</li> <li><code>--list*</code> commands are now piped through the reporters</li> <li>The top-level reporter interface provides default implementation that works just as the old one</li> <li>XmlReporter outputs a machine-parseable XML</li> <li><code>TEST_CASE</code> description support has been removed</li> <li>If the second argument has text outside tags, the text will be ignored.</li> <li>Hidden test cases are no longer included just because they don't match an exclusion tag</li> <li>Previously, a <code>TEST_CASE(\"A\", \"[.foo]\")</code> would be included by asking for <code>~[bar]</code>.</li> <li><code>PredicateMatcher</code> is no longer type erased.</li> <li>This means that the type of the provided predicate is part of the <code>PredicateMatcher</code>'s type</li> <li><code>SectionInfo</code> no longer contains section description as a member (#1319)</li> <li>You can still write <code>SECTION(\"ShortName\", \"Long and wordy description\")</code>, but the description is thrown away</li> <li>The description type now must be a <code>const char*</code> or be implicitly convertible to it</li> <li>The <code>[!hide]</code> tag has been removed.</li> <li>Use <code>[.]</code> or <code>[.foo]</code> instead.</li> <li>Lvalues of composed matchers cannot be composed further</li> <li>Uses of <code>REGISTER_TEST_CASE</code> macro need to be followed by a semicolon</li> <li>This does not change <code>TEST_CASE</code> and friends in any way</li> <li><code>IStreamingReporter::IsMulti</code> member function was removed</li> <li>This is very unlikely to actually affect anyone, as it was default-implemented in the interface, and only used internally</li> <li>Various classes not designed for user-extension have been made final</li> <li><code>ListeningReporter</code> is now <code>final</code></li> <li>Concrete Matchers (e.g. <code>UnorderedEquals</code> vector matcher) are now <code>final</code></li> <li>All Generators are now <code>final</code></li> <li>Matcher namespacing has been redone</li> <li>Matcher types are no longer in deeply nested namespaces</li> <li>Matcher factory functions are no longer brought into <code>Catch</code> namespace</li> <li>This means that all public-facing matcher-related functionality is now in <code>Catch::Matchers</code> namespace</li> <li>Defining <code>CATCH_CONFIG_MAIN</code> will no longer create main in that TU.</li> <li>Link with <code>libCatch2Main.a</code>, or the proper CMake/pkg-config target</li> <li>If you want to write custom main, include <code>catch2/catch_session.hpp</code></li> <li><code>CATCH_CONFIG_EXTERNAL_INTERFACES</code> has been removed.</li> <li>You should instead include the appropriate headers as needed.</li> <li><code>CATCH_CONFIG_IMPL</code> has been removed.</li> <li>The implementation is now compiled into a static library.</li> <li>Event Listener interface has changed</li> <li><code>TestEventListenerBase</code> was renamed to <code>EventListenerBase</code></li> <li><code>EventListenerBase</code> now directly derives from <code>IStreamingReporter</code>, instead of deriving from <code>StreamingReporterBase</code></li> <li><code>GENERATE</code> decays its arguments (#2012, #2040)</li> <li>This means that <code>str</code> in <code>auto str = GENERATE(\"aa\", \"bb\", \"cc\");</code> is inferred to <code>char const*</code> rather than <code>const char[2]</code>.</li> <li><code>--list-*</code> flags write their output to file specified by the <code>-o</code> flag</li> <li>Many changes to reporter interfaces</li> <li>With the exception of the XmlReporter, the outputs of first party reporters should remain the same</li> <li>New pair of events were added</li> <li>One obsolete event was removed</li> <li>The base class has been renamed</li> <li>The built-in reporter class hierarchy has been redone</li> <li>Catch2 generates a random seed if one hasn't been specified by the user</li> <li>The short flag for <code>--list-tests</code>, <code>-l</code>, has been removed.</li> <li>This is not a commonly used flag and does not need to use up valuable single-letter space.</li> <li>The short flag for <code>--list-tags</code>, <code>-t</code>, has been removed.</li> <li>This is not a commonly used flag and does not need to use up valuable single-letter space.</li> <li>The <code>--colour</code> option has been replaced with <code>--colour-mode</code> option</li> </ul>"},{"location":"release-notes/#improvements_7","title":"Improvements","text":"<ul> <li>Matchers have been extended with the ability to use different signatures of <code>match</code> (#1307, #1553, #1554, #1843)</li> <li>This includes having templated <code>match</code> member function</li> <li>See the rewritten Matchers documentation for details</li> <li>Catch2 currently provides some generic matchers, but there should be more before final release of v3<ul> <li><code>IsEmpty</code>, <code>SizeIs</code> which check that the range has specific properties</li> <li><code>Contains</code>, which checks whether a range contains a specific element</li> <li><code>AllMatch</code>, <code>AnyMatch</code>, <code>NoneMatch</code> range matchers, which apply matchers over a range of elements</li> </ul> </li> <li>Significant compilation time improvements</li> <li>including <code>catch_test_macros.hpp</code> is 80% cheaper than including <code>catch.hpp</code></li> <li>Some runtime performance optimizations</li> <li>In all tested cases the v3 branch was faster, so the table below shows the speedup of v3 to v2 at the same task </li> </ul> task debug build release build Run 1M <code>REQUIRE(true)</code> 1.10 \u00b1 0.01 1.02 \u00b1 0.06 Run 100 tests, 3^3 sections, 1 REQUIRE each 1.27 \u00b1 0.01 1.04 \u00b1 0.01 Run 3k tests, no names, no tags 1.29 \u00b1 0.01 1.05 \u00b1 0.01 Run 3k tests, names, tags 1.49 \u00b1 0.01 1.22 \u00b1 0.01 Run 1 out of 3k tests no names, no tags 1.68 \u00b1 0.02 1.19 \u00b1 0.22 Run 1 out of 3k tests, names, tags 1.79 \u00b1 0.02 2.06 \u00b1 0.23 <ul> <li>POSIX platforms use <code>gmtime_r</code>, rather than <code>gmtime</code> when constructing a date string (#2008, #2165)</li> <li><code>--list-*</code> flags write their output to file specified by the <code>-o</code> flag (#2061, #2163)</li> <li><code>Approx::operator()</code> is now properly <code>const</code></li> <li>Catch2's internal helper variables no longer use reserved identifiers (#578)</li> <li><code>--rng-seed</code> now accepts string <code>\"random-device\"</code> to generate random seed using <code>std::random_device</code></li> <li>Catch2 now supports test sharding (#2257)</li> <li>You can ask for the tests to be split into N groups and only run one of them.</li> <li>This greatly simplifies parallelization of tests in a binary through external runner.</li> <li>The embedded CLI parser now supports repeatedly callable lambdas</li> <li>A lambda-based option parser can opt into being repeatedly specifiable.</li> <li>Added <code>STATIC_CHECK</code> macro, similar to <code>STATIC_REQUIRE</code> (#2318)</li> <li>When deferred tu runtime, it behaves like <code>CHECK</code>, and not like <code>REQUIRE</code>.</li> <li>You can have multiple tests with the same name, as long as other parts of the test identity differ (#1915, #1999, #2175)</li> <li>Test identity includes test's name, test's tags and and test's class name if applicable.</li> <li>Added new warning, <code>UnmatchedTestSpec</code>, to error on test specs with no matching tests</li> <li>The <code>-w</code>, <code>--warn</code> warning flags can now be provided multiple times to enable multiple warnings</li> <li>The case-insensitive handling of tags is now more reliable and takes up less memory</li> <li>Test case and assertion counting can no longer reasonably overflow on 32 bit systems</li> <li>The count is now kept in <code>uint64_t</code> on all platforms, instead of using <code>size_t</code> type.</li> <li>The <code>-o</code>, <code>--out</code> output destination specifiers recognize <code>-</code> as stdout</li> <li>You have to provide it as <code>--out=-</code> to avoid CLI error about missing option</li> <li>The new reporter specification also recognizes <code>-</code> as stdout</li> <li>Multiple reporters can now run at the same time and write to different files (#1712, #2183)</li> <li>To support this, the <code>-r</code>, <code>--reporter</code> flag now also accepts optional output destination</li> <li>For full overview of the semantics of using multiple reporters, look into the reporter documentation</li> <li>To enable the new syntax, reporter names can no longer contain <code>::</code>.</li> <li>Console colour support has been rewritten and significantly improved</li> <li>The colour implementation based on ANSI colour codes is always available</li> <li>Colour implementations respect their associated stream<ul> <li>previously e.g. Win32 impl would change console colour even if Catch2 was writing to a file</li> </ul> </li> <li>The colour API is resilient against changing evaluation order of expressions</li> <li>The associated CLI flag and compile-time configuration options have changed<ul> <li>For details see the docs for command-line and compile-time Catch2 configuration</li> </ul> </li> <li>Added a support for Bazel integration with <code>XML_OUTPUT_FILE</code> env var (#2399)</li> <li>This has to be enabled during compilation.</li> <li>Added <code>--skip-benchmarks</code> flag to run tests without any <code>BENCHMARK</code>s (#2392, #2408)</li> <li>Added option to list all listeners in the binary via <code>--list-listeners</code></li> </ul>"},{"location":"release-notes/#fixes_5","title":"Fixes","text":"<ul> <li>The <code>INFO</code> macro no longer contains superfluous semicolon (#1456)</li> <li>The <code>--list*</code> family of command line flags now return 0 on success (#1410, #1146)</li> <li>Various ways of failing a benchmark are now counted and reporter properly</li> <li>The ULP matcher now handles comparing numbers with different signs properly (#2152)</li> <li>Universal ADL-found operators should no longer break decomposition (#2121)</li> <li>Reporter selection is properly case-insensitive</li> <li>Previously it forced lower cased name, which would fail for reporters with upper case characters in name</li> <li>The cumulative reporter base stores benchmark results alongside assertion results</li> <li>Catch2's SE handling should no longer interferes with ASan on Windows (#2334)</li> <li>Fixed Windows console colour handling for tests that redirect stdout (#2345)</li> <li>Fixed issue with the <code>random</code> generators returning the same value over and over again</li> </ul>"},{"location":"release-notes/#other-changes","title":"Other changes","text":"<ul> <li><code>CATCH_CONFIG_DISABLE_MATCHERS</code> no longer exists.</li> <li>If you do not want to use Matchers in a TU, do not include their header.</li> <li><code>CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER</code> no longer exists.</li> <li><code>StringMaker</code> specializations for <code>&lt;chrono&gt;</code> are always provided</li> <li>Catch2's CMake now provides 2 targets, <code>Catch2</code> and <code>Catch2WithMain</code>.</li> <li><code>Catch2</code> is the statically compiled implementation by itself</li> <li><code>Catch2WithMain</code> also links in the default main</li> <li>Catch2's pkg-config integration also provides 2 packages</li> <li><code>catch2</code> is the statically compiled implementation by itself</li> <li><code>catch2-with-main</code> also links in the default main</li> <li>Passing invalid test specifications passed to Catch2 are now reported before tests are run, and are a hard error.</li> <li>Running 0 tests (e.g. due to empty binary, or test spec not matching anything) returns non-0 exit code</li> <li>Flag <code>--allow-running-no-tests</code> overrides this behaviour.</li> <li><code>NoTests</code> warning has been removed because it is fully subsumed by this change.</li> <li>Catch2's compile-time configuration options (<code>CATCH_CONFIG_FOO</code>) can be set through CMake options of the same name</li> <li>They use the same semantics as C++ defines, including the <code>CATCH_CONFIG_NO_FOO</code> overrides,<ul> <li><code>-DCATCH_CONFIG_DEFAULT_REPORTER=compact</code> changes default reporter to \"compact\"</li> <li><code>-DCATCH_CONFIG_NO_ANDROID_LOGWRITE=ON</code> forces android logwrite to off</li> <li><code>-DCATCH_CONFIG_ANDROID_LOGWRITE=OFF</code> does nothing (the define will not exist)</li> </ul> </li> </ul>"},{"location":"release-notes/#2137","title":"2.13.7","text":""},{"location":"release-notes/#fixes_6","title":"Fixes","text":"<ul> <li>Added missing <code>&lt;iterator&gt;</code> include in benchmarking. (#2231)</li> <li>Fixed noexcept build with benchmarking enabled (#2235)</li> <li>Fixed build for compilers with C++17 support but without C++17 library support (#2195)</li> <li>JUnit only uses 3 decimal places when reporting durations (#2221)</li> <li><code>!mayfail</code> tagged tests are now marked as <code>skipped</code> in JUnit reporter output (#2116)</li> </ul>"},{"location":"release-notes/#2136","title":"2.13.6","text":""},{"location":"release-notes/#fixes_7","title":"Fixes","text":"<ul> <li>Disabling all signal handlers no longer breaks compilation  (#2212, #2213)</li> </ul>"},{"location":"release-notes/#miscellaneous_4","title":"Miscellaneous","text":"<ul> <li><code>catch_discover_tests</code> should handle escaped semicolon (<code>;</code>) better (#2214, #2215)</li> </ul>"},{"location":"release-notes/#2135","title":"2.13.5","text":""},{"location":"release-notes/#improvements_8","title":"Improvements","text":"<ul> <li>Detection of MAC and IPHONE platforms has been improved (#2140, #2157)</li> <li>Added workaround for bug in XLC 16.1.0.1 (#2155)</li> <li>Add detection for LCC when it is masquerading as GCC (#2199)</li> <li>Modified posix signal handling so it supports newer libcs (#2178)</li> <li><code>MINSIGSTKSZ</code> was no longer usable in constexpr context.</li> </ul>"},{"location":"release-notes/#fixes_8","title":"Fixes","text":"<ul> <li>Fixed compilation of benchmarking when <code>min</code> and <code>max</code> macros are defined (#2159)</li> <li>Including <code>windows.h</code> without <code>NOMINMAX</code> remains a really bad idea, don't do it</li> </ul>"},{"location":"release-notes/#miscellaneous_5","title":"Miscellaneous","text":"<ul> <li>The check whether Catch2 is being built as a subproject is now more reliable (#2202, #2204)</li> <li>The problem was that if the variable name used internally was defined the project including Catch2 as subproject, it would not be properly overwritten for Catch2's CMake.</li> </ul>"},{"location":"release-notes/#2134","title":"2.13.4","text":""},{"location":"release-notes/#improvements_9","title":"Improvements","text":"<ul> <li>Improved the hashing algorithm used for shuffling test cases (#2070)</li> <li><code>TEST_CASE</code>s that differ only in the last character should be properly shuffled</li> <li>Note that this means that v2.13.4 gives you a different order of test cases than 2.13.3, even given the same seed.</li> </ul>"},{"location":"release-notes/#miscellaneous_6","title":"Miscellaneous","text":"<ul> <li>Deprecated <code>ParseAndAddCatchTests</code> CMake integration (#2092)</li> <li>It is impossible to implement it properly for all the different test case variants Catch2 provides, and there are better options provided.</li> <li>Use <code>catch_discover_tests</code> instead, which uses runtime information about available tests.</li> <li>Fixed bug in <code>catch_discover_tests</code> that would cause it to fail when used in specific project structures (#2119)</li> <li>Added Bazel build file</li> <li>Added an experimental static library target to CMake</li> </ul>"},{"location":"release-notes/#2133","title":"2.13.3","text":""},{"location":"release-notes/#fixes_9","title":"Fixes","text":"<ul> <li>Fixed possible infinite loop when combining generators with section filter (<code>-c</code> option) (#2025)</li> </ul>"},{"location":"release-notes/#miscellaneous_7","title":"Miscellaneous","text":"<ul> <li>Fixed <code>ParseAndAddCatchTests</code> not finding <code>TEST_CASE</code>s without tags (#2055, #2056)</li> <li><code>ParseAndAddCatchTests</code> supports <code>CMP0110</code> policy for changing behaviour of <code>add_test</code> (#2057)</li> <li>This was the shortlived change in CMake 3.18.0 that temporarily broke <code>ParseAndAddCatchTests</code></li> </ul>"},{"location":"release-notes/#2132","title":"2.13.2","text":""},{"location":"release-notes/#improvements_10","title":"Improvements","text":"<ul> <li>Implemented workaround for AppleClang shadowing bug (#2030)</li> <li>Implemented workaround for NVCC ICE (#2005, #2027)</li> </ul>"},{"location":"release-notes/#fixes_10","title":"Fixes","text":"<ul> <li>Fixed detection of <code>std::uncaught_exceptions</code> support under non-msvc platforms (#2021)</li> <li>Fixed the experimental stdout/stderr capture under Windows (#2013)</li> </ul>"},{"location":"release-notes/#miscellaneous_8","title":"Miscellaneous","text":"<ul> <li><code>catch_discover_tests</code> has been improved significantly (#2023, #2039)</li> <li>You can now specify which reporter should be used</li> <li>You can now modify where the output will be written</li> <li><code>WORKING_DIRECTORY</code> setting is respected</li> <li><code>ParseAndAddCatchTests</code> now supports <code>TEMPLATE_TEST_CASE</code> macros (#2031)</li> <li>Various documentation fixes and improvements (#2022, #2028, #2034)</li> </ul>"},{"location":"release-notes/#2131","title":"2.13.1","text":""},{"location":"release-notes/#improvements_11","title":"Improvements","text":"<ul> <li><code>ParseAndAddCatchTests</code> handles CMake v3.18.0 correctly (#1984)</li> <li>Improved autodetection of <code>std::byte</code> (#1992)</li> <li>Simplified implementation of templated test cases (#2007)</li> <li>This should have a tiny positive effect on its compilation throughput</li> </ul>"},{"location":"release-notes/#fixes_11","title":"Fixes","text":"<ul> <li>Automatic stringification of ranges handles sentinel ranges properly (#2004)</li> </ul>"},{"location":"release-notes/#2130","title":"2.13.0","text":""},{"location":"release-notes/#improvements_12","title":"Improvements","text":"<ul> <li><code>GENERATE</code> can now follow a <code>SECTION</code> at the same level of nesting (#1938)</li> <li>The <code>SECTION</code>(s) before the <code>GENERATE</code> will not be run multiple times, the following ones will.</li> <li>Added <code>-D</code>/<code>--min-duration</code> command line flag (#1910)</li> <li>If a test takes longer to finish than the provided value, its name and duration will be printed.</li> <li>This flag is overridden by setting <code>-d</code>/<code>--duration</code>.</li> </ul>"},{"location":"release-notes/#fixes_12","title":"Fixes","text":"<ul> <li><code>TAPReporter</code> no longer skips successful assertions (#1983)</li> </ul>"},{"location":"release-notes/#2124","title":"2.12.4","text":""},{"location":"release-notes/#improvements_13","title":"Improvements","text":"<ul> <li>Added support for MacOS on ARM (#1971)</li> </ul>"},{"location":"release-notes/#2123","title":"2.12.3","text":""},{"location":"release-notes/#fixes_13","title":"Fixes","text":"<ul> <li><code>GENERATE</code> nested in a for loop no longer creates multiple generators (#1913)</li> <li>Fixed copy paste error breaking <code>TEMPLATE_TEST_CASE_SIG</code> for 6 or more arguments (#1954)</li> <li>Fixed potential UB when handling non-ASCII characters in CLI args (#1943)</li> </ul>"},{"location":"release-notes/#improvements_14","title":"Improvements","text":"<ul> <li>There can be multiple calls to <code>GENERATE</code> on a single line</li> <li>Improved <code>fno-except</code> support for platforms that do not provide shims for exception-related std functions (#1950)</li> <li>E.g. the Green Hills C++ compiler</li> <li>XmlReporter now also reports test-case-level statistics (#1958)</li> <li>This is done via a new element, <code>OverallResultsCases</code></li> </ul>"},{"location":"release-notes/#miscellaneous_9","title":"Miscellaneous","text":"<ul> <li>Added <code>.clang-format</code> file to the repo (#1182, #1920)</li> <li>Rewrote contributing docs</li> <li>They should explain the different levels of testing and so on much better</li> </ul>"},{"location":"release-notes/#2122","title":"2.12.2","text":""},{"location":"release-notes/#fixes_14","title":"Fixes","text":"<ul> <li>Fixed compilation failure if <code>is_range</code> ADL found deleted function (#1929)</li> <li>Fixed potential UB in <code>CAPTURE</code> if the expression contained non-ASCII characters (#1925)</li> </ul>"},{"location":"release-notes/#improvements_15","title":"Improvements","text":"<ul> <li><code>std::result_of</code> is not used if <code>std::invoke_result</code> is available (#1934)</li> <li>JUnit reporter writes out <code>status</code> attribute for tests (#1899)</li> <li>Suppressed clang-tidy's <code>hicpp-vararg</code> warning (#1921)</li> <li>Catch2 was already suppressing the <code>cppcoreguidelines-pro-type-vararg</code> alias of the warning</li> </ul>"},{"location":"release-notes/#2121","title":"2.12.1","text":""},{"location":"release-notes/#fixes_15","title":"Fixes","text":"<ul> <li>Vector matchers now support initializer list literals better</li> </ul>"},{"location":"release-notes/#improvements_16","title":"Improvements","text":"<ul> <li>Added support for <code>^</code> (bitwise xor) to <code>CHECK</code> and <code>REQUIRE</code></li> </ul>"},{"location":"release-notes/#2120","title":"2.12.0","text":""},{"location":"release-notes/#improvements_17","title":"Improvements","text":"<ul> <li>Running tests in random order (<code>--order rand</code>) has been reworked significantly (#1908)</li> <li>Given same seed, all platforms now produce the same order</li> <li>Given same seed, the relative order of tests does not change if you select only a subset of them</li> <li>Vector matchers support custom allocators (#1909)</li> <li><code>|</code> and <code>&amp;</code> (bitwise or and bitwise and) are now supported in <code>CHECK</code> and <code>REQUIRE</code></li> <li>The resulting type must be convertible to <code>bool</code></li> </ul>"},{"location":"release-notes/#fixes_16","title":"Fixes","text":"<ul> <li>Fixed computation of benchmarking column widths in ConsoleReporter (#1885, #1886)</li> <li>Suppressed clang-tidy's <code>cppcoreguidelines-pro-type-vararg</code> in assertions (#1901)</li> <li>It was a false positive triggered by the new warning support workaround</li> <li>Fixed bug in test specification parser handling of OR'd patterns using escaping (#1905)</li> </ul>"},{"location":"release-notes/#miscellaneous_10","title":"Miscellaneous","text":"<ul> <li>Worked around IBM XL's codegen bug (#1907)</li> <li>It would emit code for destructors of temporaries in an unevaluated context</li> <li>Improved detection of stdlib's support for <code>std::uncaught_exceptions</code> (#1911)</li> </ul>"},{"location":"release-notes/#2113","title":"2.11.3","text":""},{"location":"release-notes/#fixes_17","title":"Fixes","text":"<ul> <li>Fixed compilation error caused by lambdas in assertions under MSVC</li> </ul>"},{"location":"release-notes/#2112","title":"2.11.2","text":""},{"location":"release-notes/#improvements_18","title":"Improvements","text":"<ul> <li>GCC and Clang now issue warnings for suspicious code in assertions (#1880)</li> <li>E.g. <code>REQUIRE( int != unsigned int )</code> will now issue mixed signedness comparison warning</li> <li>This has always worked on MSVC, but it now also works for GCC and current Clang versions</li> <li>Colorization of \"Test filters\" output should be more robust now</li> <li><code>--wait-for-keypress</code> now also accepts <code>never</code> as an option (#1866)</li> <li>Reporters no longer round-off nanoseconds when reporting benchmarking results (#1876)</li> <li>Catch2's debug break now supports iOS while using Thumb instruction set (#1862)</li> <li>It is now possible to customize benchmark's warm-up time when running the test binary (#1844)</li> <li><code>--benchmark-warmup-time {ms}</code></li> <li>User can now specify how Catch2 should break into debugger (#1846)</li> </ul>"},{"location":"release-notes/#fixes_18","title":"Fixes","text":"<ul> <li>Fixes missing <code>&lt;random&gt;</code> include in benchmarking (#1831)</li> <li>Fixed missing <code>&lt;iterator&gt;</code> include in benchmarking (#1874)</li> <li>Hidden test cases are now also tagged with <code>[!hide]</code> as per documentation (#1847)</li> <li>Detection of whether libc provides <code>std::nextafter</code> has been improved (#1854)</li> <li>Detection of <code>wmain</code> no longer incorrectly looks for <code>WIN32</code> macro (#1849)</li> <li>Now it just detects Windows platform</li> <li>Composing already-composed matchers no longer modifies the partially-composed matcher expression</li> <li>This bug has been present for the last ~2 years and nobody reported it</li> </ul>"},{"location":"release-notes/#2111","title":"2.11.1","text":""},{"location":"release-notes/#improvements_19","title":"Improvements","text":"<ul> <li>Breaking into debugger is supported on iOS (#1817)</li> <li><code>google-build-using-namespace</code> clang-tidy warning is suppressed (#1799)</li> </ul>"},{"location":"release-notes/#fixes_19","title":"Fixes","text":"<ul> <li>Clang on Windows is no longer assumed to implement MSVC's traditional preprocessor (#1806)</li> <li><code>ObjectStorage</code> now behaves properly in <code>const</code> contexts (#1820)</li> <li><code>GENERATE_COPY(a, b)</code> now compiles properly (#1809, #1815)</li> <li>Some more cleanups in the benchmarking support</li> </ul>"},{"location":"release-notes/#2110","title":"2.11.0","text":""},{"location":"release-notes/#improvements_20","title":"Improvements","text":"<ul> <li>JUnit reporter output now contains more details in case of failure (#1347, #1719)</li> <li>Added SonarQube Test Data reporter (#1738)</li> <li>It is in a separate header, just like the TAP, Automake, and TeamCity reporters</li> <li><code>range</code> generator now allows floating point numbers (#1776)</li> <li>Reworked part of internals to increase throughput</li> </ul>"},{"location":"release-notes/#fixes_20","title":"Fixes","text":"<ul> <li>The single header version should contain full benchmarking support (#1800)</li> <li><code>[.foo]</code> is now properly parsed as <code>[.][foo]</code> when used on the command line (#1798)</li> <li>Fixed compilation of benchmarking on platforms where <code>steady_clock::period</code> is not <code>std::nano</code> (#1794)</li> </ul>"},{"location":"release-notes/#2102","title":"2.10.2","text":""},{"location":"release-notes/#improvements_21","title":"Improvements","text":"<ul> <li>Catch2 will now compile on platform where <code>INFINITY</code> is double (#1782)</li> </ul>"},{"location":"release-notes/#fixes_21","title":"Fixes","text":"<ul> <li>Warning suppressed during listener registration will no longer leak</li> </ul>"},{"location":"release-notes/#2101","title":"2.10.1","text":""},{"location":"release-notes/#improvements_22","title":"Improvements","text":"<ul> <li>Catch2 now guards itself against <code>min</code> and <code>max</code> macros from <code>windows.h</code> (#1772)</li> <li>Templated tests will now compile with ICC (#1748)</li> <li><code>WithinULP</code> matcher now uses scientific notation for stringification (#1760)</li> </ul>"},{"location":"release-notes/#fixes_22","title":"Fixes","text":"<ul> <li>Templated tests no longer trigger <code>-Wunused-templates</code> (#1762)</li> <li>Suppressed clang-analyzer false positive in context getter (#1230, #1735)</li> </ul>"},{"location":"release-notes/#miscellaneous_11","title":"Miscellaneous","text":"<ul> <li>CMake no longer prohibits in-tree build when Catch2 is used as a subproject (#1773, #1774)</li> </ul>"},{"location":"release-notes/#2100","title":"2.10.0","text":""},{"location":"release-notes/#fixes_23","title":"Fixes","text":"<ul> <li><code>TEMPLATE_LIST_TEST_CASE</code> now properly handles non-copyable and non-movable types (#1729)</li> <li>Fixed compilation error on Solaris caused by a system header defining macro <code>TT</code> (#1722, #1723)</li> <li><code>REGISTER_ENUM</code> will now fail at compilation time if the registered enum is too large</li> <li>Removed use of <code>std::is_same_v</code> in C++17 mode (#1757)</li> <li>Fixed parsing of escaped special characters when reading test specs from a file (#1767, #1769)</li> </ul>"},{"location":"release-notes/#improvements_23","title":"Improvements","text":"<ul> <li>Trailing and leading whitespace in test/section specs are now ignored.</li> <li>Writing to Android debug log now uses <code>__android_log_write</code> instead of <code>__android_log_print</code></li> <li>Android logging support can now be turned on/off at compile time (#1743)</li> <li>The toggle is <code>CATCH_CONFIG_ANDROID_LOGWRITE</code></li> <li>Added a generator that returns elements of a range</li> <li>Use via <code>from_range(from, to)</code> or <code>from_range(container)</code></li> <li>Added support for CRTs that do not provide <code>std::nextafter</code> (#1739)</li> <li>They must still provide global <code>nextafter{f,l,}</code></li> <li>Enabled via <code>CATCH_CONFIG_GLOBAL_NEXTAFTER</code></li> <li>Special cased <code>Approx(inf)</code> not to match non-infinite values</li> <li>Very strictly speaking this might be a breaking change, but it should match user expectations better</li> <li>The output of benchmarking through the Console reporter when <code>--benchmark-no-analysis</code> is set is now much simpler (#1768)</li> <li>Added a matcher that can be used for checking an exceptions message (#1649, #1728)</li> <li>The matcher helper function is called <code>Message</code></li> <li>The exception must publicly derive from <code>std::exception</code></li> <li>The matching is done exactly, including case and whitespace</li> <li>Added a matcher that can be used for checking relative equality of floating point numbers (#1746)</li> <li>Unlike <code>Approx</code>, it considers both sides when determining the allowed margin</li> <li>Special cases <code>NaN</code> and <code>INFINITY</code> to match user expectations</li> <li>The matcher helper function is called <code>WithinRel</code></li> <li>The ULP matcher now allows for any possible distance between the two numbers</li> <li>The random number generators now use Catch-global instance of RNG (#1734, #1736)</li> <li>This means that nested random number generators actually generate different numbers</li> </ul>"},{"location":"release-notes/#miscellaneous_12","title":"Miscellaneous","text":"<ul> <li>In-repo PNGs have been optimized to lower overhead of using Catch2 via git clone</li> <li>Catch2 now uses its own implementation of the URBG concept</li> <li>In the future we also plan to use our own implementation of the distributions from <code>&lt;random&gt;</code> to provide cross-platform repeatability of random results</li> </ul>"},{"location":"release-notes/#292","title":"2.9.2","text":""},{"location":"release-notes/#fixes_24","title":"Fixes","text":"<ul> <li><code>ChunkGenerator</code> can now be used with chunks of size 0 (#1671)</li> <li>Nested subsections are now run properly when specific section is run via the <code>-c</code> argument (#1670, #1673)</li> <li>Catch2 now consistently uses <code>_WIN32</code> to detect Windows platform (#1676)</li> <li><code>TEMPLATE_LIST_TEST_CASE</code> now support non-default constructible type lists (#1697)</li> <li>Fixed a crash in the XMLReporter when a benchmark throws exception during warmup (#1706)</li> <li>Fixed a possible infinite loop in CompactReporter (#1715)</li> <li>Fixed <code>-w NoTests</code> returning 0 even when no tests were matched (#1449, #1683, #1684)</li> <li>Fixed matcher compilation under Obj-C++ (#1661)</li> </ul>"},{"location":"release-notes/#improvements_24","title":"Improvements","text":"<ul> <li><code>RepeatGenerator</code> and <code>FixedValuesGenerator</code> now fail to compile when used with <code>bool</code> (#1692)</li> <li>Previously they would fail at runtime.</li> <li>Catch2 now supports Android's debug logging for its debug output (#1710)</li> <li>Catch2 now detects and configures itself for the RTX platform (#1693)</li> <li>You still need to pass <code>--benchmark-no-analysis</code> if you are using benchmarking under RTX</li> <li>Removed a \"storage class is not first\" warning when compiling Catch2 with PGI compiler (#1717)</li> </ul>"},{"location":"release-notes/#miscellaneous_13","title":"Miscellaneous","text":"<ul> <li>Documentation now contains indication when a specific feature was introduced (#1695)</li> <li>These start with Catch2 v2.3.0, (a bit over a year ago).</li> <li><code>docs/contributing.md</code> has been updated to provide contributors guidance on how to add these to newly written documentation</li> <li>Various other documentation improvements</li> <li>ToC fixes</li> <li>Documented <code>--order</code> and <code>--rng-seed</code> command line options</li> <li>Benchmarking documentation now clearly states that it requires opt-in</li> <li>Documented <code>CATCH_CONFIG_CPP17_OPTIONAL</code> and <code>CATCH_CONFIG_CPP17_BYTE</code> macros</li> <li>Properly documented built-in vector matchers</li> <li>Improved <code>*_THROWS_MATCHES</code> documentation a bit</li> <li>CMake config file is now arch-independent even if <code>CMAKE_SIZEOF_VOID_P</code> is in CMake cache (#1660)</li> <li><code>CatchAddTests</code> now properly escapes <code>[</code> and <code>]</code> in test names (#1634, #1698)</li> <li>Reverted <code>CatchAddTests</code> adding tags as CTest labels (#1658)</li> <li>The script broke when test names were too long</li> <li>Overwriting <code>LABELS</code> caused trouble for users who set them manually</li> <li>CMake does not let users append to <code>LABELS</code> if the test name has spaces</li> </ul>"},{"location":"release-notes/#291","title":"2.9.1","text":""},{"location":"release-notes/#fixes_25","title":"Fixes","text":"<ul> <li>Fix benchmarking compilation failure in files without <code>CATCH_CONFIG_EXTERNAL_INTERFACES</code> (or implementation)</li> </ul>"},{"location":"release-notes/#290","title":"2.9.0","text":""},{"location":"release-notes/#improvements_25","title":"Improvements","text":"<ul> <li>The experimental benchmarking support has been replaced by integrating Nonius code (#1616)</li> <li>This provides a much more featurefull micro-benchmarking support.</li> <li>Due to the compilation cost, it is disabled by default. See the documentation for details.</li> <li>As far as backwards compatibility is concerned, this feature is still considered experimental in that we might change the interface based on user feedback.</li> <li><code>WithinULP</code> matcher now shows the acceptable range (#1581)</li> <li>Template test cases now support type lists (#1627)</li> </ul>"},{"location":"release-notes/#280","title":"2.8.0","text":""},{"location":"release-notes/#improvements_26","title":"Improvements","text":"<ul> <li>Templated test cases no longer check whether the provided types are unique (#1628)</li> <li>This allows you to e.g. test over <code>uint32_t</code>, <code>uint64_t</code>, and <code>size_t</code> without compilation failing</li> <li>The precision of floating point stringification can be modified by user (#1612, #1614)</li> <li>We now provide <code>REGISTER_ENUM</code> convenience macro for generating <code>StringMaker</code> specializations for enums</li> <li>See the \"String conversion\" documentation for details</li> <li>Added new set of macros for template test cases that enables the use of NTTPs (#1531, #1609)</li> <li>See \"Test cases and sections\" documentation for details</li> </ul>"},{"location":"release-notes/#fixes_26","title":"Fixes","text":"<ul> <li><code>UNSCOPED_INFO</code> macro now has a prefixed/disabled/prefixed+disabled versions (#1611)</li> <li>Reporting errors at startup should no longer cause a segfault under certain circumstances (#1626)</li> </ul>"},{"location":"release-notes/#miscellaneous_14","title":"Miscellaneous","text":"<ul> <li>CMake will now prevent you from attempting in-tree build (#1636, #1638)</li> <li>Previously it would break with an obscure error message during the build step</li> </ul>"},{"location":"release-notes/#272","title":"2.7.2","text":""},{"location":"release-notes/#improvements_27","title":"Improvements","text":"<ul> <li>Added an approximate vector matcher (#1499)</li> </ul>"},{"location":"release-notes/#fixes_27","title":"Fixes","text":"<ul> <li>Filters will no longer be shown if there were none</li> <li>Fixed compilation error when using Homebrew GCC on OS X (#1588, #1589)</li> <li>Fixed the console reporter not showing messages that start with a newline (#1455, #1470)</li> <li>Modified JUnit reporter's output so that rng seed and filters are reported according to the JUnit schema (#1598)</li> <li>Fixed some obscure warnings and static analysis passes</li> </ul>"},{"location":"release-notes/#miscellaneous_15","title":"Miscellaneous","text":"<ul> <li>Various improvements to <code>ParseAndAddCatchTests</code> (#1559, #1601)</li> <li>When a target is parsed, it receives <code>ParseAndAddCatchTests_TESTS</code> property which summarizes found tests</li> <li>Fixed problem with tests not being found if the <code>OptionalCatchTestLauncher</code> variables is used</li> <li>Including the script will no longer forcefully modify <code>CMAKE_MINIMUM_REQUIRED_VERSION</code></li> <li>CMake object libraries are ignored when parsing to avoid needless warnings</li> <li><code>CatchAddTests</code> now adds test's tags to their CTest labels (#1600)</li> <li>Added basic CPack support to our build</li> </ul>"},{"location":"release-notes/#271","title":"2.7.1","text":""},{"location":"release-notes/#improvements_28","title":"Improvements","text":"<ul> <li>Reporters now print out the filters applied to test cases (#1550, #1585)</li> <li>Added <code>GENERATE_COPY</code> and <code>GENERATE_REF</code> macros that can use variables inside the generator expression</li> <li>Because of the significant danger of lifetime issues, the default <code>GENERATE</code> macro still does not allow variables</li> <li>The <code>map</code> generator helper now deduces the mapped return type (#1576)</li> </ul>"},{"location":"release-notes/#fixes_28","title":"Fixes","text":"<ul> <li>Fixed ObjC++ compilation (#1571)</li> <li>Fixed test tag parsing so that <code>[.foo]</code> is now parsed as <code>[.][foo]</code>.</li> <li>Suppressed warning caused by the Windows headers defining SE codes in different manners (#1575)</li> </ul>"},{"location":"release-notes/#270","title":"2.7.0","text":""},{"location":"release-notes/#improvements_29","title":"Improvements","text":"<ul> <li><code>TEMPLATE_PRODUCT_TEST_CASE</code> now uses the resulting type in the name, instead of the serial number (#1544)</li> <li>Catch2's single header is now strictly ASCII (#1542)</li> <li>Added generator for random integral/floating point types</li> <li>The types are inferred within the <code>random</code> helper</li> <li>Added back RangeGenerator (#1526)</li> <li>RangeGenerator returns elements within a certain range</li> <li>Added ChunkGenerator generic transform (#1538)</li> <li>A ChunkGenerator returns the elements from different generator in chunks of n elements</li> <li>Added <code>UNSCOPED_INFO</code> (#415, #983, #1522)</li> <li>This is a variant of <code>INFO</code> that lives until next assertion/end of the test case.</li> </ul>"},{"location":"release-notes/#fixes_29","title":"Fixes","text":"<ul> <li>All calls to C stdlib functions are now <code>std::</code> qualified (#1541)</li> <li>Code brought in from Clara was also updated.</li> <li>Running tests will no longer open the specified output file twice (#1545)</li> <li>This would cause trouble when the file was not a file, but rather a named pipe</li> <li>Fixes the CLion/Resharper integration with Catch</li> <li>Fixed <code>-Wunreachable-code</code> occurring with (old) ccache+cmake+clang combination (#1540)</li> <li>Fixed <code>-Wdefaulted-function-deleted</code> warning with Clang 8 (#1537)</li> <li>Catch2's type traits and helpers are now properly namespaced inside <code>Catch::</code> (#1548)</li> <li>Fixed std{out,err} redirection for failing test (#1514, #1525)</li> <li>Somehow, this bug has been present for well over a year before it was reported</li> </ul>"},{"location":"release-notes/#contrib","title":"Contrib","text":"<ul> <li><code>ParseAndAddCatchTests</code> now properly escapes commas in the test name</li> </ul>"},{"location":"release-notes/#261","title":"2.6.1","text":""},{"location":"release-notes/#improvements_30","title":"Improvements","text":"<ul> <li>The JUnit reporter now also reports random seed (#1520, #1521)</li> </ul>"},{"location":"release-notes/#fixes_30","title":"Fixes","text":"<ul> <li>The TAP reporter now formats comments with test name properly (#1529)</li> <li><code>CATCH_REQUIRE_THROWS</code>'s internals were unified with <code>REQUIRE_THROWS</code> (#1536)</li> <li>This fixes a potential <code>-Wunused-value</code> warning when used</li> <li>Fixed a potential segfault when using any of the <code>--list-*</code> options (#1533, #1534)</li> </ul>"},{"location":"release-notes/#260","title":"2.6.0","text":"<p>With this release the data generator feature is now fully supported.</p>"},{"location":"release-notes/#improvements_31","title":"Improvements","text":"<ul> <li>Added <code>TEMPLATE_PRODUCT_TEST_CASE</code> (#1454, #1468)</li> <li>This allows you to easily test various type combinations, see documentation for details</li> <li>The error message for <code>&amp;&amp;</code> and <code>||</code> inside assertions has been improved (#1273, #1480)</li> <li>The error message for chained comparisons inside assertions has been improved (#1481)</li> <li>Added <code>StringMaker</code> specialization for <code>std::optional</code> (#1510)</li> <li>The generator interface has been redone once again (#1516)</li> <li>It is no longer considered experimental and is fully supported</li> <li>The new interface supports \"Input\" generators</li> <li>The generator documentation has been fully updated</li> <li>We also added 2 generator examples</li> </ul>"},{"location":"release-notes/#fixes_31","title":"Fixes","text":"<ul> <li>Fixed <code>-Wredundant-move</code> on newer Clang (#1474)</li> <li>Removed unreachable mentions <code>std::current_exception</code>, <code>std::rethrow_exception</code> in no-exceptions mode (#1462)</li> <li>This should fix compilation with IAR</li> <li>Fixed missing <code>&lt;type_traits&gt;</code> include (#1494)</li> <li>Fixed various static analysis warnings</li> <li>Unrestored stream state in <code>XmlWriter</code> (#1489)</li> <li>Potential division by zero in <code>estimateClockResolution</code> (#1490)</li> <li>Uninitialized member in <code>RunContext</code> (#1491)</li> <li><code>SourceLineInfo</code> move ops are now marked <code>noexcept</code></li> <li><code>CATCH_BREAK_INTO_DEBUGGER</code> is now always a function</li> <li>Fix double run of a test case if user asks for a specific section (#1394, #1492)</li> <li>ANSI colour code output now respects <code>-o</code> flag and writes to the file as well (#1502)</li> <li>Fixed detection of <code>std::variant</code> support for compilers other than Clang (#1511)</li> </ul>"},{"location":"release-notes/#contrib_1","title":"Contrib","text":"<ul> <li><code>ParseAndAddCatchTests</code> has learned how to use <code>DISABLED</code> CTest property (#1452)</li> <li><code>ParseAndAddCatchTests</code> now works when there is a whitespace before the test name (#1493)</li> </ul>"},{"location":"release-notes/#miscellaneous_16","title":"Miscellaneous","text":"<ul> <li>We added new issue templates for reporting issues on GitHub</li> <li><code>contributing.md</code> has been updated to reflect the current test status (#1484)</li> </ul>"},{"location":"release-notes/#250","title":"2.5.0","text":""},{"location":"release-notes/#improvements_32","title":"Improvements","text":"<ul> <li>Added support for templated tests via <code>TEMPLATE_TEST_CASE</code> (#1437)</li> </ul>"},{"location":"release-notes/#fixes_32","title":"Fixes","text":"<ul> <li>Fixed compilation of <code>PredicateMatcher&lt;const char*&gt;</code> by removing partial specialization of <code>MatcherMethod&lt;T*&gt;</code></li> <li>Listeners now implicitly support any verbosity (#1426)</li> <li>Fixed compilation with Embarcadero builder by introducing <code>Catch::isnan</code> polyfill (#1438)</li> <li>Fixed <code>CAPTURE</code> asserting for non-trivial captures (#1436, #1448)</li> </ul>"},{"location":"release-notes/#miscellaneous_17","title":"Miscellaneous","text":"<ul> <li>We should now be providing first party Conan support via https://bintray.com/catchorg/Catch2 (#1443)</li> <li>Added new section \"deprecations and planned changes\" to the documentation</li> <li>It contains summary of what is deprecated and might change with next major version</li> <li>From this release forward, the released headers should be pgp signed (#430)</li> <li>KeyID <code>E29C 46F3 B8A7 5028 6079 3B7D ECC9 C20E 314B 2360</code></li> <li>or https://codingnest.com/files/horenmar-publickey.asc</li> </ul>"},{"location":"release-notes/#242","title":"2.4.2","text":""},{"location":"release-notes/#improvements_33","title":"Improvements","text":"<ul> <li>XmlReporter now also outputs the RNG seed that was used in a run (#1404)</li> <li><code>Catch::Session::applyCommandLine</code> now also accepts <code>wchar_t</code> arguments.</li> <li>However, Catch2 still does not support unicode.</li> <li>Added <code>STATIC_REQUIRE</code> macro (#1356, #1362)</li> <li>Catch2's singleton's are now cleaned up even if tests are run (#1411)</li> <li>This is mostly useful as a FP prevention for users who define their own main.</li> <li>Specifying an invalid reporter via <code>-r</code> is now reported sooner (#1351, #1422)</li> </ul>"},{"location":"release-notes/#fixes_33","title":"Fixes","text":"<ul> <li>Stringification no longer assumes that <code>char</code> is signed (#1399, #1407)</li> <li>This caused a <code>Wtautological-compare</code> warning.</li> <li>SFINAE for <code>operator&lt;&lt;</code> no longer sees different overload set than the actual insertion (#1403)</li> </ul>"},{"location":"release-notes/#contrib_2","title":"Contrib","text":"<ul> <li><code>catch_discover_tests</code> correctly adds tests with comma in name (#1327, #1409)</li> <li>Added a new customization point in how the tests are launched to <code>catch_discover_tests</code></li> </ul>"},{"location":"release-notes/#241","title":"2.4.1","text":""},{"location":"release-notes/#improvements_34","title":"Improvements","text":"<ul> <li>Added a StringMaker for <code>std::(w)string_view</code> (#1375, #1376)</li> <li>Added a StringMaker for <code>std::variant</code> (#1380)</li> <li>This one is disabled by default to avoid increased compile-time drag</li> <li>Added detection for cygwin environment without <code>std::to_string</code> (#1396, #1397)</li> </ul>"},{"location":"release-notes/#fixes_34","title":"Fixes","text":"<ul> <li><code>UnorderedEqualsMatcher</code> will no longer accept erroneously accept vectors that share suffix, but are not permutation of the desired vector</li> <li>Abort after (<code>-x N</code>) can no longer be overshot by nested <code>REQUIRES</code> and subsequently ignored (#1391, #1392)</li> </ul>"},{"location":"release-notes/#240","title":"2.4.0","text":"<p>This release brings two new experimental features, generator support and a <code>-fno-exceptions</code> support. Being experimental means that they will not be subject to the usual stability guarantees provided by semver.</p>"},{"location":"release-notes/#improvements_35","title":"Improvements","text":"<ul> <li>Various small runtime performance improvements</li> <li><code>CAPTURE</code> macro is now variadic</li> <li>Added <code>AND_GIVEN</code> macro (#1360)</li> <li>Added experimental support for data generators</li> <li>See their documentation for details</li> <li>Added support for compiling and running Catch without exceptions</li> <li>Doing so limits the functionality somewhat</li> <li>Look into the documentation for details</li> </ul>"},{"location":"release-notes/#fixes_35","title":"Fixes","text":"<ul> <li>Suppressed <code>-Wnon-virtual-dtor</code> warnings in Matchers (#1357)</li> <li>Suppressed <code>-Wunreachable-code</code> warnings in floating point matchers (#1350)</li> </ul>"},{"location":"release-notes/#cmake","title":"CMake","text":"<ul> <li>It is now possible to override which Python is used to run Catch's tests (#1365)</li> <li>Catch now provides infrastructure for adding tests that check compile-time configuration</li> <li>Catch no longer tries to install itself when used as a subproject (#1373)</li> <li>Catch2ConfigVersion.cmake is now generated as arch-independent (#1368)</li> <li>This means that installing Catch from 32-bit machine and copying it to 64-bit one works</li> <li>This fixes conan installation of Catch</li> </ul>"},{"location":"release-notes/#230","title":"2.3.0","text":"<p>This release changes the include paths provided by our CMake and pkg-config integration. The proper include path for the single-header when using one of the above is now <code>&lt;catch2/catch.hpp&gt;</code>. This change also necessitated changes to paths inside the repository, so that the single-header version is now at <code>single_include/catch2/catch.hpp</code>, rather than <code>single_include/catch.hpp</code>.</p>"},{"location":"release-notes/#fixes_36","title":"Fixes","text":"<ul> <li>Fixed Objective-C++ build</li> <li><code>-Wunused-variable</code> suppression no longer leaks from Catch's header under Clang</li> <li>Implementation of the experimental new output capture can now be disabled (#1335)</li> <li>This allows building Catch2 on platforms that do not provide things like <code>dup</code> or <code>tmpfile</code>.</li> <li>The JUnit and XML reporters will no longer skip over successful tests when running without <code>-s</code>  (#1264, #1267, #1310)</li> <li>See improvements for more details</li> </ul>"},{"location":"release-notes/#improvements_36","title":"Improvements","text":"<ul> <li>pkg-config and CMake integration has been rewritten</li> <li>If you use them, the new include path is <code>#include &lt;catch2/catch.hpp&gt;</code></li> <li>CMake installation now also installs scripts from <code>contrib/</code></li> <li>For details see the new documentation</li> <li>Reporters now have a new customization point, <code>ReporterPreferences::shouldReportAllAssertions</code></li> <li>When this is set to <code>false</code> and the tests are run without <code>-s</code>, passing assertions are not sent to the reporter.</li> <li>Defaults to <code>false</code>.</li> <li>Added <code>DYNAMIC_SECTION</code>, a section variant that constructs its name using stream</li> <li>This means that you can do <code>DYNAMIC_SECTION(\"For X := \" &lt;&lt; x)</code>.</li> </ul>"},{"location":"release-notes/#223","title":"2.2.3","text":"<p>To fix some of the bugs, some behavior had to change in potentially breaking manner. This means that even though this is a patch release, it might not be a drop-in replacement.</p>"},{"location":"release-notes/#fixes_37","title":"Fixes","text":"<ul> <li>Listeners are now called before reporter</li> <li>This was always documented to be the case, now it actually works that way</li> <li>Catch's commandline will no longer accept multiple reporters</li> <li>This was done because multiple reporters never worked properly and broke things in non-obvious ways</li> <li>This has potential to be a breaking change</li> <li>MinGW is now detected as Windows platform w/o SEH support (#1257)</li> <li>This means that Catch2 no longer tries to use POSIX signal handling when compiled with MinGW</li> <li>Fixed potential UB in parsing tags using non-ASCII characters (#1266)</li> <li>Note that Catch2 still supports only ASCII test names/tags/etc</li> <li><code>TEST_CASE_METHOD</code> can now be used on classnames containing commas (#1245)</li> <li>You have to enclose the classname in extra set of parentheses</li> <li>Fixed insufficient alt stack size for POSIX signal handling (#1225)</li> <li>Fixed compilation error on Android due to missing <code>std::to_string</code> in C++11 mode (#1280)</li> <li>Fixed the order of user-provided <code>FALLBACK_STRINGIFIER</code> in stringification machinery (#1024)</li> <li>It was intended to be replacement for built-in fallbacks, but it was used after them.</li> <li>This has potential to be a breaking change</li> <li>Fixed compilation error when a type has an <code>operator&lt;&lt;</code> with templated lhs (#1285, #1306)</li> </ul>"},{"location":"release-notes/#improvements_37","title":"Improvements","text":"<ul> <li>Added a new, experimental, output capture (#1243)</li> <li>This capture can also redirect output written via C apis, e.g. <code>printf</code></li> <li>To opt-in, define <code>CATCH_CONFIG_EXPERIMENTAL_REDIRECT</code> in the implementation file</li> <li>Added a new fallback stringifier for classes derived from <code>std::exception</code></li> <li>Both <code>StringMaker</code> specialization and <code>operator&lt;&lt;</code> overload are given priority</li> </ul>"},{"location":"release-notes/#miscellaneous_18","title":"Miscellaneous","text":"<ul> <li><code>contrib/</code> now contains dbg scripts that skip over Catch's internals (#904, #1283)</li> <li><code>gdbinit</code> for gdb <code>lldbinit</code> for lldb</li> <li><code>CatchAddTests.cmake</code> no longer strips whitespace from tests (#1265, #1281)</li> <li>Online documentation now describes <code>--use-colour</code> option (#1263)</li> </ul>"},{"location":"release-notes/#222","title":"2.2.2","text":""},{"location":"release-notes/#fixes_38","title":"Fixes","text":"<ul> <li>Fixed bug in <code>WithinAbs::match()</code> failing spuriously (#1228)</li> <li>Fixed clang-tidy diagnostic about virtual call in destructor (#1226)</li> <li>Reduced the number of GCC warnings suppression leaking out of the header (#1090, #1091)</li> <li>Only <code>-Wparentheses</code> should be leaking now</li> <li>Added upper bound on the time benchmark timer calibration is allowed to take (#1237)</li> <li>On platforms where <code>std::chrono::high_resolution_clock</code>'s resolution is low, the calibration would appear stuck</li> <li>Fixed compilation error when stringifying static arrays of <code>unsigned char</code>s (#1238)</li> </ul>"},{"location":"release-notes/#improvements_38","title":"Improvements","text":"<ul> <li>XML encoder now hex-encodes invalid UTF-8 sequences (#1207)</li> <li>This affects xml and junit reporters</li> <li>Some invalid UTF-8 parts are left as is, e.g. surrogate pairs. This is because certain extensions of UTF-8 allow them, such as WTF-8.</li> <li>CLR objects (<code>T^</code>) can now be stringified (#1216)</li> <li>This affects code compiled as C++/CLI</li> <li>Added <code>PredicateMatcher</code>, a matcher that takes an arbitrary predicate function (#1236)</li> <li>See documentation for details</li> </ul>"},{"location":"release-notes/#others","title":"Others","text":"<ul> <li>Modified CMake-installed pkg-config to allow <code>#include &lt;catch.hpp&gt;</code>(#1239)</li> <li>The plans to standardize on <code>#include &lt;catch2/catch.hpp&gt;</code> are still in effect</li> </ul>"},{"location":"release-notes/#221","title":"2.2.1","text":""},{"location":"release-notes/#fixes_39","title":"Fixes","text":"<ul> <li>Fixed compilation error when compiling Catch2 with <code>std=c++17</code> against libc++ (#1214)</li> <li>Clara (Catch2's CLI parsing library) used <code>std::optional</code> without including it explicitly</li> <li>Fixed Catch2 return code always being 0 (#1215)</li> <li>In the words of STL, \"We feel superbad about letting this in\"</li> </ul>"},{"location":"release-notes/#220","title":"2.2.0","text":""},{"location":"release-notes/#fixes_40","title":"Fixes","text":"<ul> <li>Hidden tests are not listed by default when listing tests (#1175)</li> <li>This makes <code>catch_discover_tests</code> CMake script work better</li> <li>Fixed regression that meant <code>&lt;windows.h&gt;</code> could potentially not be included properly (#1197)</li> <li>Fixed installing <code>Catch2ConfigVersion.cmake</code> when Catch2 is a subproject.</li> </ul>"},{"location":"release-notes/#improvements_39","title":"Improvements","text":"<ul> <li>Added an option to warn (+ exit with error) when no tests were ran (#1158)</li> <li>Use as <code>-w NoTests</code></li> <li>Added provisional support for Emscripten (#1114)</li> <li>Added a way to override the fallback stringifier (#1024)</li> <li>This allows project's own stringification machinery to be easily reused for Catch</li> <li><code>Catch::Session::run()</code> now accepts <code>char const * const *</code>, allowing it to accept array of string literals (#1031, #1178)</li> <li>The embedded version of Clara was bumped to v1.1.3</li> <li>Various minor performance improvements</li> <li>Added support for DJGPP DOS crosscompiler (#1206)</li> </ul>"},{"location":"release-notes/#212","title":"2.1.2","text":""},{"location":"release-notes/#fixes_41","title":"Fixes","text":"<ul> <li>Fixed compilation error with <code>-fno-rtti</code> (#1165)</li> <li>Fixed NoAssertion warnings</li> <li><code>operator&lt;&lt;</code> is used before range-based stringification (#1172)</li> <li>Fixed <code>-Wpedantic</code> warnings (extra semicolons and binary literals) (#1173)</li> </ul>"},{"location":"release-notes/#improvements_40","title":"Improvements","text":"<ul> <li>Added <code>CATCH_VERSION_{MAJOR,MINOR,PATCH}</code> macros (#1131)</li> <li>Added <code>BrightYellow</code> colour for use in reporters (#979)</li> <li>It is also used by ConsoleReporter for reconstructed expressions</li> </ul>"},{"location":"release-notes/#other-changes_1","title":"Other changes","text":"<ul> <li>Catch is now exported as a CMake package and linkable target (#1170)</li> </ul>"},{"location":"release-notes/#211","title":"2.1.1","text":""},{"location":"release-notes/#improvements_41","title":"Improvements","text":"<ul> <li>Static arrays are now properly stringified like ranges across MSVC/GCC/Clang</li> <li>Embedded newer version of Clara -- v1.1.1</li> <li>This should fix some warnings dragged in from Clara</li> <li>MSVC's CLR exceptions are supported</li> </ul>"},{"location":"release-notes/#fixes_42","title":"Fixes","text":"<ul> <li>Fixed compilation when comparison operators do not return bool (#1147)</li> <li>Fixed CLR exceptions blowing up the executable during translation (#1138)</li> </ul>"},{"location":"release-notes/#other-changes_2","title":"Other changes","text":"<ul> <li>Many CMake changes</li> <li><code>NO_SELFTEST</code> option is deprecated, use <code>BUILD_TESTING</code> instead.</li> <li>Catch specific CMake options were prefixed with <code>CATCH_</code> for namespacing purposes</li> <li>Other changes to simplify Catch2's packaging</li> </ul>"},{"location":"release-notes/#210","title":"2.1.0","text":""},{"location":"release-notes/#improvements_42","title":"Improvements","text":"<ul> <li>Various performance improvements</li> <li>On top of the performance regression fixes</li> <li>Experimental support for PCH was added (#1061)</li> <li><code>CATCH_CONFIG_EXTERNAL_INTERFACES</code> now brings in declarations of Console, Compact, XML and JUnit reporters</li> <li><code>MatcherBase</code> no longer has a pointless second template argument</li> <li>Reduced the number of warning suppressions that leak into user's code</li> <li>Bugs in g++ 4.x and 5.x mean that some of them have to be left in</li> </ul>"},{"location":"release-notes/#fixes_43","title":"Fixes","text":"<ul> <li>Fixed performance regression from Catch classic</li> <li>One of the performance improvement patches for Catch classic was not applied to Catch2</li> <li>Fixed platform detection for iOS (#1084)</li> <li>Fixed compilation when <code>g++</code> is used together with <code>libc++</code> (#1110)</li> <li>Fixed TeamCity reporter compilation with the single header version</li> <li>To fix the underlying issue we will be versioning reporters in single_include folder per release</li> <li>The XML reporter will now report <code>WARN</code> messages even when not used with <code>-s</code></li> <li>Fixed compilation when <code>VectorContains</code> matcher was combined using <code>&amp;&amp;</code> (#1092)</li> <li>Fixed test duration overflowing after 10 seconds (#1125, #1129)</li> <li>Fixed <code>std::uncaught_exception</code> deprecation warning (#1124)</li> </ul>"},{"location":"release-notes/#new-features","title":"New features","text":"<ul> <li>New Matchers</li> <li>Regex matcher for strings, <code>Matches</code>.</li> <li>Set-equal matcher for vectors, <code>UnorderedEquals</code></li> <li>Floating point matchers, <code>WithinAbs</code> and <code>WithinULP</code>.</li> <li>Stringification now attempts to decompose all containers (#606)</li> <li>Containers are objects that respond to ADL <code>begin(T)</code> and <code>end(T)</code>.</li> </ul>"},{"location":"release-notes/#other-changes_3","title":"Other changes","text":"<ul> <li>Reporters will now be versioned in the <code>single_include</code> folder to ensure their compatibility with the last released version</li> </ul>"},{"location":"release-notes/#201","title":"2.0.1","text":""},{"location":"release-notes/#breaking-changes","title":"Breaking changes","text":"<ul> <li>Removed C++98 support</li> <li>Removed legacy reporter support</li> <li>Removed legacy generator support</li> <li>Generator support will come back later, reworked</li> <li>Removed <code>Catch::toString</code> support</li> <li>The new stringification machinery uses <code>Catch::StringMaker</code> specializations first and <code>operator&lt;&lt;</code> overloads second.</li> <li>Removed legacy <code>SCOPED_MSG</code> and <code>SCOPED_INFO</code> macros</li> <li>Removed <code>INTERNAL_CATCH_REGISTER_REPORTER</code></li> <li><code>CATCH_REGISTER_REPORTER</code> should be used to register reporters</li> <li>Removed legacy <code>[hide]</code> tag</li> <li><code>[.]</code>, <code>[.foo]</code> and <code>[!hide]</code> are still supported</li> <li>Output into debugger is now colourized</li> <li><code>*_THROWS_AS(expr, exception_type)</code> now unconditionally appends <code>const&amp;</code> to the exception type.</li> <li><code>CATCH_CONFIG_FAST_COMPILE</code> now affects the <code>CHECK_</code> family of assertions as well as <code>REQUIRE_</code> family of assertions</li> <li>This is most noticeable in <code>CHECK(throws())</code>, which would previously report failure, properly stringify the exception and continue. Now it will report failure and stop executing current section.</li> <li>Removed deprecated matcher utility functions <code>Not</code>, <code>AllOf</code> and <code>AnyOf</code>.</li> <li>They are superseded by operators <code>!</code>, <code>&amp;&amp;</code> and <code>||</code>, which are natural and do not have limited arity</li> <li>Removed support for non-const comparison operators</li> <li>Non-const comparison operators are an abomination that should not exist</li> <li>They were breaking support for comparing function to function pointer</li> <li><code>std::pair</code> and <code>std::tuple</code> are no longer stringified by default</li> <li>This is done to avoid dragging in <code>&lt;tuple&gt;</code> and <code>&lt;utility&gt;</code> headers in common path</li> <li>Their stringification can be enabled per-file via new configuration macros</li> <li><code>Approx</code> is subtly different and hopefully behaves more as users would expect</li> <li><code>Approx::scale</code> defaults to <code>0.0</code></li> <li><code>Approx::epsilon</code> no longer applies to the larger of the two compared values, but only to the <code>Approx</code>'s value</li> <li><code>INFINITY == Approx(INFINITY)</code> returns true</li> </ul>"},{"location":"release-notes/#improvements_43","title":"Improvements","text":"<ul> <li>Reporters and Listeners can be defined in files different from the main file</li> <li>The file has to define <code>CATCH_CONFIG_EXTERNAL_INTERFACES</code> before including catch.hpp.</li> <li>Errors that happen during set up before main are now caught and properly reported once main is entered</li> <li>If you are providing your own main, you can access and use these as well.</li> <li>New assertion macros, *_THROWS_MATCHES(expr, exception_type, matcher) are provided</li> <li>As the arguments suggest, these allow you to assert that an expression throws desired type of exception and pass the exception to a matcher.</li> <li>JUnit reporter no longer has significantly different output for test cases with and without sections</li> <li>Most assertions now support expressions containing commas (ie <code>REQUIRE(foo() == std::vector&lt;int&gt;{1, 2, 3});</code>)</li> <li>Catch now contains experimental micro benchmarking support</li> <li>See <code>projects/SelfTest/Benchmark.tests.cpp</code> for examples</li> <li>The support being experiment means that it can be changed without prior notice</li> <li>Catch uses new CLI parsing library (Clara)</li> <li>Users can now easily add new command line options to the final executable</li> <li>This also leads to some changes in <code>Catch::Session</code> interface</li> <li>All parts of matchers can be removed from a TU by defining <code>CATCH_CONFIG_DISABLE_MATCHERS</code></li> <li>This can be used to somewhat speed up compilation times</li> <li>An experimental implementation of <code>CATCH_CONFIG_DISABLE</code> has been added</li> <li>Inspired by Doctest's <code>DOCTEST_CONFIG_DISABLE</code></li> <li>Useful for implementing tests in source files<ul> <li>ie for functions in anonymous namespaces</li> </ul> </li> <li>Removes all assertions</li> <li>Prevents <code>TEST_CASE</code> registrations</li> <li>Exception translators are not registered</li> <li>Reporters are not registered</li> <li>Listeners are not registered</li> <li>Reporters/Listeners are now notified of fatal errors</li> <li>This means specific signals or structured exceptions</li> <li>The Reporter/Listener interface provides default, empty, implementation to preserve backward compatibility</li> <li>Stringification of <code>std::chrono::duration</code> and <code>std::chrono::time_point</code> is now supported</li> <li>Needs to be enabled by a per-file compile time configuration option</li> <li>Add <code>pkg-config</code> support to CMake install command</li> </ul>"},{"location":"release-notes/#fixes_44","title":"Fixes","text":"<ul> <li>Don't use console colour if running in XCode</li> <li>Explicit constructor in reporter base class</li> <li>Swept out <code>-Wweak-vtables</code>, <code>-Wexit-time-destructors</code>, <code>-Wglobal-constructors</code> warnings</li> <li>Compilation for Universal Windows Platform (UWP) is supported</li> <li>SEH handling and colorized output are disabled when compiling for UWP</li> <li>Implemented a workaround for <code>std::uncaught_exception</code> issues in libcxxrt</li> <li>These issues caused incorrect section traversals</li> <li>The workaround is only partial, user's test can still trigger the issue by using <code>throw;</code> to rethrow an exception</li> <li>Suppressed C4061 warning under MSVC</li> </ul>"},{"location":"release-notes/#internal-changes","title":"Internal changes","text":"<ul> <li>The development version now uses .cpp files instead of header files containing implementation.</li> <li>This makes partial rebuilds much faster during development</li> <li>The expression decomposition layer has been rewritten</li> <li>The evaluation layer has been rewritten</li> <li>New library (TextFlow) is used for formatting text to output</li> </ul>"},{"location":"release-notes/#older-versions","title":"Older versions","text":""},{"location":"release-notes/#112x","title":"1.12.x","text":""},{"location":"release-notes/#1122","title":"1.12.2","text":""},{"location":"release-notes/#fixes_45","title":"Fixes","text":"<ul> <li>Fixed missing  include"},{"location":"release-notes/#1121","title":"1.12.1","text":""},{"location":"release-notes/#fixes_46","title":"Fixes","text":"<ul> <li>Fixed deprecation warning in <code>ScopedMessage::~ScopedMessage</code></li> <li>All uses of <code>min</code> or <code>max</code> identifiers are now wrapped in parentheses</li> <li>This avoids problems when Windows headers define <code>min</code> and <code>max</code> macros</li> </ul>"},{"location":"release-notes/#1120","title":"1.12.0","text":""},{"location":"release-notes/#fixes_47","title":"Fixes","text":"<ul> <li>Fixed compilation for strict C++98 mode (ie not gnu++98) and older compilers (#1103)</li> <li><code>INFO</code> messages are included in the <code>xml</code> reporter output even without <code>-s</code> specified.</li> </ul>"},{"location":"release-notes/#111x","title":"1.11.x","text":""},{"location":"release-notes/#1110","title":"1.11.0","text":""},{"location":"release-notes/#fixes_48","title":"Fixes","text":"<ul> <li>The original expression in <code>REQUIRE_FALSE( expr )</code> is now reporter properly as <code>!( expr )</code> (#1051)</li> <li>Previously the parentheses were missing and <code>x != y</code> would be expanded as <code>!x != x</code></li> <li><code>Approx::Margin</code> is now inclusive (#952)</li> <li>Previously it was meant and documented as inclusive, but the check itself wasn't</li> <li>This means that <code>REQUIRE( 0.25f == Approx( 0.0f ).margin( 0.25f ) )</code> passes, instead of fails</li> <li><code>RandomNumberGenerator::result_type</code> is now unsigned (#1050)</li> </ul>"},{"location":"release-notes/#improvements_44","title":"Improvements","text":"<ul> <li><code>__JETBRAINS_IDE__</code> macro handling is now CLion version specific (#1017)</li> <li>When CLion 2017.3 or newer is detected, <code>__COUNTER__</code> is used instead of</li> <li>TeamCity reporter now explicitly flushes output stream after each report (#1057)</li> <li>On some platforms, output from redirected streams would show up only after the tests finished running</li> <li><code>ParseAndAddCatchTests</code> now can add test files as dependency to CMake configuration</li> <li>This means you do not have to manually rerun CMake configuration step to detect new tests</li> </ul>"},{"location":"release-notes/#110x","title":"1.10.x","text":""},{"location":"release-notes/#1100","title":"1.10.0","text":""},{"location":"release-notes/#fixes_49","title":"Fixes","text":"<ul> <li>Evaluation layer has been rewritten (backported from Catch 2)</li> <li>The new layer is much simpler and fixes some issues (#981)</li> <li>Implemented workaround for VS 2017 raw string literal stringification bug (#995)</li> <li>Fixed interaction between <code>[!shouldfail]</code> and <code>[!mayfail]</code> tags and sections</li> <li>Previously sections with failing assertions would be marked as failed, not failed-but-ok</li> </ul>"},{"location":"release-notes/#improvements_45","title":"Improvements","text":"<ul> <li>Added libidentify support</li> <li>Added \"wait-for-keypress\" option</li> </ul>"},{"location":"release-notes/#19x","title":"1.9.x","text":""},{"location":"release-notes/#196","title":"1.9.6","text":""},{"location":"release-notes/#improvements_46","title":"Improvements","text":"<ul> <li>Catch's runtime overhead has been significantly decreased (#937, #939)</li> <li>Added <code>--list-extra-info</code> cli option (#934).</li> <li>It lists all tests together with extra information, ie filename, line number and description.</li> </ul>"},{"location":"release-notes/#195","title":"1.9.5","text":""},{"location":"release-notes/#fixes_50","title":"Fixes","text":"<ul> <li>Truthy expressions are now reconstructed properly, not as booleans (#914)</li> <li>Various warnings are no longer erroneously suppressed in test files (files that include <code>catch.hpp</code>, but do not define <code>CATCH_CONFIG_MAIN</code> or <code>CATCH_CONFIG_RUNNER</code>) (#871)</li> <li>Catch no longer fails to link when main is compiled as C++, but linked against Objective-C (#855)</li> <li>Fixed incorrect gcc version detection when deciding to use <code>__COUNTER__</code> (#928)</li> <li>Previously any GCC with minor version less than 3 would be incorrectly classified as not supporting <code>__COUNTER__</code>.</li> <li>Suppressed C4996 warning caused by upcoming updated to MSVC 2017, marking <code>std::uncaught_exception</code> as deprecated. (#927)</li> </ul>"},{"location":"release-notes/#improvements_47","title":"Improvements","text":"<ul> <li>CMake integration script now incorporates debug messages and registers tests in an improved way (#911)</li> <li>Various documentation improvements</li> </ul>"},{"location":"release-notes/#194","title":"1.9.4","text":""},{"location":"release-notes/#fixes_51","title":"Fixes","text":"<ul> <li><code>CATCH_FAIL</code> macro no longer causes compilation error without variadic macro support</li> <li><code>INFO</code> messages are no longer cleared after being reported once</li> </ul>"},{"location":"release-notes/#improvements-and-minor-changes","title":"Improvements and minor changes","text":"<ul> <li>Catch now uses <code>wmain</code> when compiled under Windows and <code>UNICODE</code> is defined.</li> <li>Note that Catch still officially supports only ASCII</li> </ul>"},{"location":"release-notes/#193","title":"1.9.3","text":""},{"location":"release-notes/#fixes_52","title":"Fixes","text":"<ul> <li>Completed the fix for (lack of) uint64_t in earlier Visual Studios</li> </ul>"},{"location":"release-notes/#192","title":"1.9.2","text":""},{"location":"release-notes/#improvements-and-minor-changes_1","title":"Improvements and minor changes","text":"<ul> <li>All of <code>Approx</code>'s member functions now accept strong typedefs in C++11 mode (#888)</li> <li>Previously <code>Approx::scale</code>, <code>Approx::epsilon</code>, <code>Approx::margin</code> and <code>Approx::operator()</code> didn't.</li> </ul>"},{"location":"release-notes/#fixes_53","title":"Fixes","text":"<ul> <li>POSIX signals are now disabled by default under QNX (#889)</li> <li>QNX does not support current enough (2001) POSIX specification</li> <li>JUnit no longer counts exceptions as failures if given test case is marked as ok to fail.</li> <li><code>Catch::Option</code> should now have its storage properly aligned.</li> <li>Catch no longer attempts to define <code>uint64_t</code> on windows (#862)</li> <li>This was causing trouble when compiled under Cygwin</li> </ul>"},{"location":"release-notes/#other","title":"Other","text":"<ul> <li>Catch is now compiled under MSVC 2017 using <code>std:c++latest</code> (C++17 mode) in CI</li> <li>We now provide cmake script that autoregisters Catch tests into ctest.</li> <li>See <code>contrib</code> folder.</li> </ul>"},{"location":"release-notes/#191","title":"1.9.1","text":""},{"location":"release-notes/#fixes_54","title":"Fixes","text":"<ul> <li>Unexpected exceptions are no longer ignored by default (#885, #887)</li> </ul>"},{"location":"release-notes/#190","title":"1.9.0","text":""},{"location":"release-notes/#improvements-and-minor-changes_2","title":"Improvements and minor changes","text":"<ul> <li>Catch no longer attempts to ensure the exception type passed by user in <code>REQUIRE_THROWS_AS</code> is a constant reference.</li> <li>It was causing trouble when <code>REQUIRE_THROWS_AS</code> was used inside templated functions</li> <li>This actually reverts changes made in v1.7.2</li> <li>Catch's <code>Version</code> struct should no longer be double freed when multiple instances of Catch tests are loaded into single program (#858)</li> <li>It is now a static variable in an inline function instead of being an <code>extern</code>ed struct.</li> <li>Attempt to register invalid tag or tag alias now throws instead of calling <code>exit()</code>.</li> <li>Because this happen before entering main, it still aborts execution</li> <li>Further improvements to this are coming</li> <li><code>CATCH_CONFIG_FAST_COMPILE</code> now speeds-up compilation of <code>REQUIRE*</code> assertions by further ~15%.</li> <li>The trade-off is disabling translation of unexpected exceptions into text.</li> <li>When Catch is compiled using C++11, <code>Approx</code> is now constructible with anything that can be explicitly converted to <code>double</code>.</li> <li>Captured messages are now printed on unexpected exceptions</li> </ul>"},{"location":"release-notes/#fixes_55","title":"Fixes:","text":"<ul> <li>Clang's <code>-Wexit-time-destructors</code> should be suppressed for Catch's internals</li> <li>GCC's <code>-Wparentheses</code> is now suppressed for all TU's that include <code>catch.hpp</code>.</li> <li>This is functionally a revert of changes made in 1.8.0, where we tried using <code>_Pragma</code> based suppression. This should have kept the suppression local to Catch's assertions, but bugs in GCC's handling of <code>_Pragma</code>s in C++ mode meant that it did not always work.</li> <li>You can now tell Catch to use C++11-based check when checking whether a type can be streamed to output.</li> <li>This fixes cases when an unstreamable type has streamable private base (#877)</li> <li>Details can be found in documentation</li> </ul>"},{"location":"release-notes/#other-notes","title":"Other notes:","text":"<ul> <li>We have added VS 2017 to our CI</li> <li>Work on Catch 2 should start soon</li> </ul>"},{"location":"release-notes/#18x","title":"1.8.x","text":""},{"location":"release-notes/#182","title":"1.8.2","text":""},{"location":"release-notes/#improvements-and-minor-changes_3","title":"Improvements and minor changes","text":"<ul> <li>TAP reporter now behaves as if <code>-s</code> was always set</li> <li>This should be more consistent with the protocol desired behaviour.</li> <li>Compact reporter now obeys <code>-d yes</code> argument (#780)</li> <li>The format is \"XXX.123 s: \" (3 decimal places are always present). <li>Before it did not report the durations at all.</li> <li>XML reporter now behaves the same way as Console reporter in regards to <code>INFO</code></li> <li>This means it reports <code>INFO</code> messages on success, if output on success (<code>-s</code>) is enabled.</li> <li>Previously it only reported <code>INFO</code> messages on failure.</li> <li><code>CAPTURE(expr)</code> now stringifies <code>expr</code> in the same way assertion macros do (#639)</li> <li>Listeners are now finally documented.</li> <li>Listeners provide a way to hook into events generated by running your tests, including start and end of run, every test case, every section and every assertion.</li>"},{"location":"release-notes/#fixes_56","title":"Fixes:","text":"<ul> <li>Catch no longer attempts to reconstruct expression that led to a fatal error  (#810)</li> <li>This fixes possible signal/SEH loop when processing expressions, where the signal was triggered by expression decomposition.</li> <li>Fixed (C4265) missing virtual destructor warning in Matchers (#844)</li> <li><code>std::string</code>s are now taken by <code>const&amp;</code> everywhere (#842).</li> <li>Previously some places were taking them by-value.</li> <li>Catch should no longer change errno (#835).</li> <li>This was caused by libstdc++ bug that we now work around.</li> <li>Catch now provides <code>FAIL_CHECK( ... )</code> macro (#765).</li> <li>Same as <code>FAIL( ... )</code>, but does not abort the test.</li> <li>Functions like <code>fabs</code>, <code>tolower</code>, <code>memset</code>, <code>isalnum</code> are now used with <code>std::</code> qualification (#543).</li> <li>Clara no longer assumes first argument (binary name) is always present (#729)</li> <li>If it is missing, empty string is used as default.</li> <li>Clara no longer reads 1 character past argument string (#830)</li> <li>Regression in Objective-C bindings (Matchers) fixed (#854)</li> </ul>"},{"location":"release-notes/#other-notes_1","title":"Other notes:","text":"<ul> <li>We have added VS 2013 and 2015 to our CI</li> <li>Catch Classic (1.x.x) now contains its own, forked, version of Clara (the argument parser).</li> </ul>"},{"location":"release-notes/#181","title":"1.8.1","text":""},{"location":"release-notes/#fixes_57","title":"Fixes","text":"<p>Cygwin issue with <code>gettimeofday</code> - <code>#define</code> was not early enough</p>"},{"location":"release-notes/#180","title":"1.8.0","text":""},{"location":"release-notes/#new-features-minor-changes","title":"New features/ minor changes","text":"<ul> <li>Matchers have new, simpler (and documented) interface.</li> <li>Catch provides string and vector matchers.</li> <li>For details see Matchers documentation.</li> <li>Changed console reporter test duration reporting format (#322)</li> <li>Old format: <code>Some simple comparisons between doubles completed in 0.000123s</code></li> <li>New format: <code>xxx.123s: Some simple comparisons between doubles</code> (There will always be exactly 3 decimal places)</li> <li>Added opt-in leak detection under MSVC + Windows (#439)</li> <li>Enable it by compiling Catch's main with <code>CATCH_CONFIG_WINDOWS_CRTDBG</code></li> <li>Introduced new compile-time flag, <code>CATCH_CONFIG_FAST_COMPILE</code>, trading features for compilation speed.</li> <li>Moves debug breaks out of tests and into implementation, speeding up test compilation time (~10% on linux).</li> <li>More changes are coming</li> <li>Added TAP (Test Anything Protocol) and Automake reporters.</li> <li>These are not present in the default single-include header and need to be downloaded from GitHub separately.</li> <li>For details see documentation about integrating with build systems.</li> <li>XML reporter now reports filename as part of the <code>Section</code> and <code>TestCase</code> tags.</li> <li><code>Approx</code> now supports an optional margin of absolute error</li> <li>It has also received new documentation.</li> </ul>"},{"location":"release-notes/#fixes_58","title":"Fixes","text":"<ul> <li>Silenced C4312 (\"conversion from int to 'ClassName *\") warnings in the evaluate layer.</li> <li>Fixed C4512 (\"assignment operator could not be generated\") warnings under VS2013.</li> <li>Cygwin compatibility fixes</li> <li>Signal handling is no longer compiled by default.</li> <li>Usage of <code>gettimeofday</code> inside Catch should no longer cause compilation errors.</li> <li>Improved <code>-Wparentheses</code> suppression for gcc (#674)</li> <li>When compiled with gcc 4.8 or newer, the suppression is localized to assertions only</li> <li>Otherwise it is suppressed for the whole TU</li> <li>Fixed test spec parser issue (with escapes in multiple names)</li> </ul>"},{"location":"release-notes/#other_1","title":"Other","text":"<ul> <li>Various documentation fixes and improvements</li> </ul>"},{"location":"release-notes/#17x","title":"1.7.x","text":""},{"location":"release-notes/#172","title":"1.7.2","text":""},{"location":"release-notes/#fixes-and-minor-improvements","title":"Fixes and minor improvements","text":"<p>Xml:</p> <p>(technically the first two are breaking changes but are also fixes and arguably break few if any people) * C-escape control characters instead of XML encoding them (which requires XML 1.1) * Revert XML output to XML 1.0 * Can provide stylesheet references by extending the XML reporter * Added description and tags attributes to XML Reporter * Tags are closed and the stream flushed more eagerly to avoid stdout interpolation</p> <p>Other: * <code>REQUIRE_THROWS_AS</code> now catches exception by <code>const&amp;</code> and reports expected type * In <code>SECTION</code>s the file/ line is now of the <code>SECTION</code>. not the <code>TEST_CASE</code> * Added std:: qualification to some functions from C stdlib * Removed use of RTTI (<code>dynamic_cast</code>) that had crept back in * Silenced a few more warnings in different circumstances * Travis improvements</p>"},{"location":"release-notes/#171","title":"1.7.1","text":""},{"location":"release-notes/#fixes_59","title":"Fixes:","text":"<ul> <li>Fixed inconsistency in defining <code>NOMINMAX</code> and <code>WIN32_LEAN_AND_MEAN</code> inside <code>catch.hpp</code>.</li> <li>Fixed SEH-related compilation error under older MinGW compilers, by making Windows SEH handling opt-in for compilers other than MSVC.</li> <li>For specifics, look into the documentation.</li> <li>Fixed compilation error under MinGW caused by improper compiler detection.</li> <li>Fixed XML reporter sometimes leaving an empty output file when a test ends with signal/structured exception.</li> <li>Fixed XML reporter not reporting captured stdout/stderr.</li> <li>Fixed possible infinite recursion in Windows SEH.</li> <li>Fixed possible compilation error caused by Catch's operator overloads being ambiguous in regards to user-defined templated operators.</li> </ul>"},{"location":"release-notes/#170","title":"1.7.0","text":""},{"location":"release-notes/#features-changes","title":"Features/ Changes:","text":"<ul> <li>Catch now runs significantly faster for passing tests</li> <li>Microbenchmark focused on Catch's overhead went from ~3.4s to ~0.7s.</li> <li>Real world test using JSON for Modern C++'s test suite went from ~6m 25s to ~4m 14s.</li> <li>Catch can now run specific sections within test cases.</li> <li>For now the support is only basic (no wildcards or tags), for details see the documentation.</li> <li>Catch now supports SEH on Windows as well as signals on Linux.</li> <li>After receiving a signal, Catch reports failing assertion and then passes the signal onto the previous handler.</li> <li>Approx can be used to compare values against strong typedefs (available in C++11 mode only).</li> <li>Strong typedefs mean types that are explicitly convertible to double.</li> <li>CHECK macro no longer stops executing section if an exception happens.</li> <li>Certain characters (space, tab, etc) are now pretty printed.</li> <li>This means that a <code>char c = ' '; REQUIRE(c == '\\t');</code> would be printed as <code>' ' == '\\t'</code>, instead of <code>== 9</code>.</li> </ul>"},{"location":"release-notes/#fixes_60","title":"Fixes:","text":"<ul> <li>Text formatting no longer attempts to access out-of-bounds characters under certain conditions.</li> <li>THROW family of assertions no longer trigger <code>-Wunused-value</code> on expressions containing explicit cast.</li> <li>Breaking into debugger under OS X works again and no longer required <code>DEBUG</code> to be defined.</li> <li>Compilation no longer breaks under certain compiler if a lambda is used inside assertion macro.</li> </ul>"},{"location":"release-notes/#other_2","title":"Other:","text":"<ul> <li>Catch's CMakeLists now defines install command.</li> <li>Catch's CMakeLists now generates projects with warnings enabled.</li> </ul>"},{"location":"release-notes/#16x","title":"1.6.x","text":""},{"location":"release-notes/#161","title":"1.6.1","text":""},{"location":"release-notes/#features-changes_1","title":"Features/ Changes:","text":"<ul> <li>Catch now supports breaking into debugger on Linux</li> </ul>"},{"location":"release-notes/#fixes_61","title":"Fixes:","text":"<ul> <li>Generators no longer leak memory (generators are still unsupported in general)</li> <li>JUnit reporter now reports UTC timestamps, instead of \"tbd\"</li> <li><code>CHECK_THAT</code> macro is now properly defined as <code>CATCH_CHECK_THAT</code> when using <code>CATCH_</code> prefixed macros</li> </ul>"},{"location":"release-notes/#other_3","title":"Other:","text":"<ul> <li>Types with overloaded <code>&amp;&amp;</code> operator are no longer evaluated twice when used in an assertion macro.</li> <li>The use of <code>__COUNTER__</code> is suppressed when Catch is parsed by CLion</li> <li>This change is not active when compiling a binary</li> <li>Approval tests can now be run on Windows</li> <li>CMake will now warn if a file is present in the <code>include</code> folder but not is not enumerated as part of the project</li> <li>Catch now defines <code>NOMINMAX</code> and <code>WIN32_LEAN_AND_MEAN</code> before including <code>windows.h</code></li> <li>This can be disabled if needed, see documentation for details.</li> </ul>"},{"location":"release-notes/#160","title":"1.6.0","text":""},{"location":"release-notes/#cmake-projects","title":"Cmake/ projects:","text":"<ul> <li>Moved CMakeLists.txt to root, made it friendlier for CLion and generating XCode and VS projects, and removed the manually maintained XCode and VS projects.</li> </ul>"},{"location":"release-notes/#features-changes_2","title":"Features/ Changes:","text":"<ul> <li>Approx now supports <code>&gt;=</code> and <code>&lt;=</code></li> <li>Can now use <code>\\</code> to escape chars in test names on command line</li> <li>Standardize C++11 feature toggles</li> </ul>"},{"location":"release-notes/#fixes_62","title":"Fixes:","text":"<ul> <li>Blue shell colour</li> <li>Missing argument to <code>CATCH_CHECK_THROWS</code></li> <li>Don't encode extended ASCII in XML</li> <li>use <code>std::shuffle</code> on more compilers (fixes deprecation warning/error)</li> <li>Use <code>__COUNTER__</code> more consistently (where available)</li> </ul>"},{"location":"release-notes/#other_4","title":"Other:","text":"<ul> <li>Tweaks and changes to scripts - particularly for Approval test - to make them more portable</li> </ul>"},{"location":"release-notes/#even-older-versions","title":"Even Older versions","text":"<p>Release notes were not maintained prior to v1.6.0, but you should be able to work them out from the Git history</p>"},{"location":"release-process/","title":"Release process","text":""},{"location":"release-process/#how-to-release","title":"How to release","text":"<p>When enough changes have accumulated, it is time to release new version of Catch. This document describes the process in doing so, that no steps are forgotten. Note that all referenced scripts can be found in the <code>tools/scripts/</code> directory.</p>"},{"location":"release-process/#necessary-steps","title":"Necessary steps","text":"<p>These steps are necessary and have to be performed before each new release. They serve to make sure that the new release is correct and linked-to from the standard places.</p>"},{"location":"release-process/#testing","title":"Testing","text":"<p>All of the tests are currently run in our CI setup based on TravisCI and AppVeyor. As long as the last commit tested green, the release can proceed.</p>"},{"location":"release-process/#incrementing-version-number","title":"Incrementing version number","text":"<p>Catch uses a variant of semantic versioning, with breaking API changes (and thus major version increments) being very rare. Thus, the release will usually increment the patch version, when it only contains couple of bugfixes, or minor version, when it contains new functionality, or larger changes in implementation of current functionality.</p> <p>After deciding which part of version number should be incremented, you can use one of the <code>*Release.py</code> scripts to perform the required changes to Catch.</p> <p>This will take care of generating the single include header, updating version numbers everywhere and pushing the new version to Wandbox.</p>"},{"location":"release-process/#release-notes","title":"Release notes","text":"<p>Once a release is ready, release notes need to be written. They should summarize changes done since last release. For rough idea of expected notes see previous releases. Once written, release notes should be added to <code>docs/release-notes.md</code>.</p>"},{"location":"release-process/#commit-and-push-update-to-github","title":"Commit and push update to GitHub","text":"<p>After version number is incremented, single-include header is regenerated and release notes are updated, changes should be committed and pushed to GitHub.</p>"},{"location":"release-process/#release-on-github","title":"Release on GitHub","text":"<p>After pushing changes to GitHub, GitHub release needs to be created. Tag version and release title should be same as the new version, description should contain the release notes for the current release. We also attach the two amalgamated files as \"binaries\".</p> <p>Since 2.5.0, the release tag and the \"binaries\" (amalgamated files) should be PGP signed.</p>"},{"location":"release-process/#signing-a-tag","title":"Signing a tag","text":"<p>To create a signed tag, use <code>git tag -s &lt;VERSION&gt;</code>, where <code>&lt;VERSION&gt;</code> is the version being released, e.g. <code>git tag -s v2.6.0</code>.</p> <p>Use the version name as the short message and the release notes as the body (long) message.</p>"},{"location":"release-process/#signing-the-amalgamated-files","title":"Signing the amalgamated files","text":"<p>This will create ASCII-armored signatures for the two amalgamated files that are uploaded to the GitHub release:</p> <pre><code>gpg --armor --output extras/catch_amalgamated.hpp.asc --detach-sig extras/catch_amalgamated.hpp\ngpg --armor --output extras/catch_amalgamated.cpp.asc --detach-sig extras/catch_amalgamated.cpp\n</code></pre> <p>GPG does not support signing multiple files in single invocation.</p>"},{"location":"reporter-events/","title":"Reporter events","text":""},{"location":"reporter-events/#reporter-events","title":"Reporter events","text":"<p>Contents Test running events Benchmarking events Listings events Miscellaneous events</p> <p>Reporter events are one of the customization points for user code. They are used by reporters to customize Catch2's output, and by event listeners to perform in-process actions under some conditions.</p> <p>There are currently 21 reporter events in Catch2, split between 4 distinct event groups: * test running events (10 events) * benchmarking (4 events) * listings (3 events) * miscellaneous (4 events)</p>"},{"location":"reporter-events/#test-running-events","title":"Test running events","text":"<p>Test running events are always paired so that for each <code>fooStarting</code> event, there is a <code>fooEnded</code> event. This means that the 10 test running events consist of 5 pairs of events:</p> <ul> <li><code>testRunStarting</code> and <code>testRunEnded</code>,</li> <li><code>testCaseStarting</code> and <code>testCaseEnded</code>,</li> <li><code>testCasePartialStarting</code> and <code>testCasePartialEnded</code>,</li> <li><code>sectionStarting</code> and <code>sectionEnded</code>,</li> <li><code>assertionStarting</code> and <code>assertionEnded</code></li> </ul>"},{"location":"reporter-events/#testrun-events","title":"<code>testRun</code> events","text":"<pre><code>void testRunStarting( TestRunInfo const&amp; testRunInfo );\nvoid testRunEnded( TestRunStats const&amp; testRunStats );\n</code></pre> <p>The <code>testRun</code> events bookend the entire test run. <code>testRunStarting</code> is emitted before the first test case is executed, and <code>testRunEnded</code> is emitted after all the test cases have been executed.</p>"},{"location":"reporter-events/#testcase-events","title":"<code>testCase</code> events","text":"<pre><code>void testCaseStarting( TestCaseInfo const&amp; testInfo );\nvoid testCaseEnded( TestCaseStats const&amp; testCaseStats );\n</code></pre> <p>The <code>testCase</code> events bookend one full run of a specific test case. Individual runs through a test case, e.g. due to <code>SECTION</code>s or <code>GENERATE</code>s, are handled by a different event.</p>"},{"location":"reporter-events/#testcasepartial-events","title":"<code>testCasePartial</code> events","text":"<p>Introduced in Catch2 3.0.1</p> <pre><code>void testCasePartialStarting( TestCaseInfo const&amp; testInfo, uint64_t partNumber );\nvoid testCasePartialEnded(TestCaseStats const&amp; testCaseStats, uint64_t partNumber );\n</code></pre> <p><code>testCasePartial</code> events bookend one partial run of a specific test case. This means that for any given test case, these events can be emitted multiple times, e.g. due to multiple leaf sections.</p> <p>In regards to nesting with <code>testCase</code> events, <code>testCasePartialStarting</code> will never be emitted before the corresponding <code>testCaseStarting</code>, and <code>testCasePartialEnded</code> will always be emitted before the corresponding <code>testCaseEnded</code>.</p>"},{"location":"reporter-events/#section-events","title":"<code>section</code> events","text":"<pre><code>void sectionStarting( SectionInfo const&amp; sectionInfo );\nvoid sectionEnded( SectionStats const&amp; sectionStats );\n</code></pre> <p><code>section</code> events are emitted only for active <code>SECTION</code>s, that is, sections that are entered. Sections that are skipped in this test case run-through do not cause events to be emitted.</p> <p>Note that test cases always contain one implicit section. The event for this section is emitted after the corresponding <code>testCasePartialStarting</code> event.</p>"},{"location":"reporter-events/#assertion-events","title":"<code>assertion</code> events","text":"<pre><code>void assertionStarting( AssertionInfo const&amp; assertionInfo );\nvoid assertionEnded( AssertionStats const&amp; assertionStats );\n</code></pre> <p>The <code>assertionStarting</code> event is emitted before the expression in the assertion is captured or evaluated and <code>assertionEnded</code> is emitted afterwards. This means that given assertion like <code>REQUIRE(a + b == c + d)</code>, Catch2 first emits <code>assertionStarting</code> event, then <code>a + b</code> and <code>c + d</code> are evaluated, then their results are captured, the comparison is evaluated, and then <code>assertionEnded</code> event is emitted.</p>"},{"location":"reporter-events/#benchmarking-events","title":"Benchmarking events","text":"<p>Introduced in Catch2 2.9.0.</p> <pre><code>void benchmarkPreparing( StringRef name ) override;\nvoid benchmarkStarting( BenchmarkInfo const&amp; benchmarkInfo ) override;\nvoid benchmarkEnded( BenchmarkStats&lt;&gt; const&amp; benchmarkStats ) override;\nvoid benchmarkFailed( StringRef error ) override;\n</code></pre> <p>Due to the benchmark lifecycle being bit more complicated, the benchmarking events have their own category, even though they could be seen as parallel to the <code>assertion*</code> events. You should expect running a benchmark to generate at least 2 of the events above.</p> <p>To understand the explanation below, you should read the benchmarking documentation first.</p> <ul> <li><code>benchmarkPreparing</code> event is sent after the environmental probe finishes, but before the user code is first estimated.</li> <li><code>benchmarkStarting</code> event is sent after the user code is estimated, but has not been benchmarked yet.</li> <li><code>benchmarkEnded</code> event is sent after the user code has been benchmarked, and contains the benchmarking results.</li> <li><code>benchmarkFailed</code> event is sent if either the estimation or the benchmarking itself fails.</li> </ul>"},{"location":"reporter-events/#listings-events","title":"Listings events","text":"<p>Introduced in Catch2 3.0.1.</p> <p>Listings events are events that correspond to the test binary being invoked with <code>--list-foo</code> flag.</p> <p>There are currently 3 listing events, one for reporters, one for tests, and one for tags. Note that they are not exclusive to each other.</p> <pre><code>void listReporters( std::vector&lt;ReporterDescription&gt; const&amp; descriptions );\nvoid listTests( std::vector&lt;TestCaseHandle&gt; const&amp; tests );\nvoid listTags( std::vector&lt;TagInfo&gt; const&amp; tagInfos );\n</code></pre>"},{"location":"reporter-events/#miscellaneous-events","title":"Miscellaneous events","text":"<pre><code>void reportInvalidTestSpec( StringRef unmatchedSpec );\nvoid fatalErrorEncountered( StringRef error );\nvoid noMatchingTestCases( StringRef unmatchedSpec );\n</code></pre> <p>These are one-off events that do not neatly fit into other categories.</p> <p><code>reportInvalidTestSpec</code> is sent for each test specification command line argument that wasn't parsed into a valid spec.</p> <p><code>fatalErrorEncountered</code> is sent when Catch2's POSIX signal handling or Windows SE handler is called into with a fatal signal/exception.</p> <p><code>noMatchingTestCases</code> is sent for each user provided test specification that did not match any registered tests.</p>"},{"location":"reporters/","title":"Reporters","text":""},{"location":"reporters/#reporters","title":"Reporters","text":"<p>Reporters are a customization point for most of Catch2's output, e.g. formatting and writing out assertions (whether passing or failing), sections, test cases, benchmarks, and so on.</p> <p>Catch2 comes with a bunch of reporters by default (currently 8), and you can also write your own reporter. Because multiple reporters can be active at the same time, your own reporters do not even have to handle all reporter event, just the ones you are interested in, e.g. benchmarks.</p>"},{"location":"reporters/#using-different-reporters","title":"Using different reporters","text":"<p>You can see which reporters are available by running the test binary with <code>--list-reporters</code>. You can then pick one of them with the <code>-r</code>, <code>--reporter</code> option, followed by the name of the desired reporter, like so:</p> <pre><code>--reporter xml\n</code></pre> <p>You can also select multiple reporters to be used at the same time. In that case you should read the section on using multiple reporters to avoid any surprises from doing so.</p> <p></p>"},{"location":"reporters/#using-multiple-reporters","title":"Using multiple reporters","text":"<p>Support for having multiple parallel reporters was introduced in Catch2 3.0.1</p> <p>Catch2 supports using multiple reporters at the same time while having them write into different destinations. The two main uses of this are</p> <ul> <li>having both human-friendly and machine-parseable (e.g. in JUnit format)   output from one run of binary</li> <li>having \"partial\" reporters that are highly specialized, e.g. having one   reporter that writes out benchmark results as markdown tables and does   nothing else, while also having standard testing output separately</li> </ul> <p>Specifying multiple reporter looks like this: <pre><code>--reporter JUnit::out=result-junit.xml --reporter console::out=-::colour-mode=ansi\n</code></pre></p> <p>This tells Catch2 to use two reporters, <code>JUnit</code> reporter that writes its machine-readable XML output to file <code>result-junit.xml</code>, and the <code>console</code> reporter that writes its user-friendly output to stdout and uses ANSI colour codes for colouring the output.</p> <p>Using multiple reporters (or one reporter and one-or-more event listeners) can have surprisingly complex semantics when using customization points provided to reporters by Catch2, namely capturing stdout/stderr from test cases.</p> <p>As long as at least one reporter (or listener) asks Catch2 to capture stdout/stderr, captured stdout and stderr will be available to all reporters and listeners.</p> <p>Because this might be surprising to the users, if at least one active reporter is non-capturing, then Catch2 tries to roughly emulate non-capturing behaviour by printing out the captured stdout/stderr just before <code>testCasePartialEnded</code> event is sent out to the active reporters and listeners. This means that stdout/stderr is no longer printed out from tests as it is being written, but instead it is written out in batch after each runthrough of a test case is finished.</p>"},{"location":"reporters/#writing-your-own-reporter","title":"Writing your own reporter","text":"<p>You can also write your own custom reporter and tell Catch2 to use it. When writing your reporter, you have two options:</p> <ul> <li>Derive from <code>Catch::ReporterBase</code>. When doing this, you will have   to provide handling for all reporter events.</li> <li>Derive from one of the provided utility reporter bases in   Catch2.</li> </ul> <p>Generally we recommend doing the latter, as it is less work.</p> <p>Apart from overriding handling of the individual reporter events, reporters have access to some extra customization points, described below.</p>"},{"location":"reporters/#utility-reporter-bases","title":"Utility reporter bases","text":"<p>Catch2 currently provides two utility reporter bases:</p> <ul> <li><code>Catch::StreamingReporterBase</code></li> <li><code>Catch::CumulativeReporterBase</code></li> </ul> <p><code>StreamingReporterBase</code> is useful for reporters that can format and write out the events as they come in. It provides (usually empty) implementation for all reporter events, and if you let it handle the relevant events, it also handles storing information about active test run and test case.</p> <p><code>CumulativeReporterBase</code> is a base for reporters that need to see the whole test run, before they can start writing the output, such as the JUnit and SonarQube reporters. This post-facto approach requires the assertions to be stringified when it is finished, so that the assertion can be written out later. Because the stringification can be expensive, and not all cumulative reporters need the assertions, this base provides customization point to change whether the assertions are saved or not, separate for passing and failing assertions.</p> <p>Generally we recommend that if you override a member function from either of the bases, you call into the base's implementation first. This is not necessarily in all cases, but it is safer and easier.</p> <p>Writing your own reporter then looks like this:</p> <pre><code>#include &lt;catch2/reporters/catch_reporter_streaming_base.hpp&gt;\n#include &lt;catch2/catch_test_case_info.hpp&gt;\n#include &lt;catch2/reporters/catch_reporter_registrars.hpp&gt;\n#include &lt;iostream&gt;\nclass PartialReporter : public Catch::StreamingReporterBase {\npublic:\nusing StreamingReporterBase::StreamingReporterBase;\nstatic std::string getDescription() {\nreturn \"Reporter for testing TestCasePartialStarting/Ended events\";\n}\nvoid testCasePartialStarting(Catch::TestCaseInfo const&amp; testInfo,\nuint64_t partNumber) override {\nstd::cout &lt;&lt; \"TestCaseStartingPartial: \" &lt;&lt; testInfo.name &lt;&lt; '#' &lt;&lt; partNumber &lt;&lt; '\\n';\n}\nvoid testCasePartialEnded(Catch::TestCaseStats const&amp; testCaseStats,\nuint64_t partNumber) override {\nstd::cout &lt;&lt; \"TestCasePartialEnded: \" &lt;&lt; testCaseStats.testInfo-&gt;name &lt;&lt; '#' &lt;&lt; partNumber &lt;&lt; '\\n';\n}\n};\nCATCH_REGISTER_REPORTER(\"partial\", PartialReporter)\n</code></pre> <p>This create a simple reporter that responds to <code>testCasePartial*</code> events, and calls itself \"partial\" reporter, so it can be invoked with <code>--reporter partial</code> command line flag.</p>"},{"location":"reporters/#reporterpreferences","title":"<code>ReporterPreferences</code>","text":"<p>Each reporter instance contains instance of <code>ReporterPreferences</code>, a type that holds flags for the behaviour of Catch2 when this reporter run. Currently there are two customization options:</p> <ul> <li><code>shouldRedirectStdOut</code> - whether the reporter wants to handle    writes to stdout/stderr from user code, or not. This is useful for    reporters that output machine-parseable output, e.g. the JUnit    reporter, or the XML reporter.</li> <li><code>shouldReportAllAssertions</code> - whether the reporter wants to handle   <code>assertionEnded</code> events for passing assertions as well as failing    assertions. Usually reporters do not report successful assertions    and don't need them for their output, but sometimes the desired output    format includes passing assertions even without the <code>-s</code> flag.</li> </ul>"},{"location":"reporters/#per-reporter-configuration","title":"Per-reporter configuration","text":"<p>Per-reporter configuration was introduced in Catch2 3.0.1</p> <p>Catch2 supports some configuration to happen per reporter. The configuration options fall into one of two categories:</p> <ul> <li>Catch2-recognized options</li> <li>Reporter-specific options</li> </ul> <p>The former is a small set of universal options that Catch2 handles for the reporters, e.g. output file or console colour mode. The latter are options that the reporters have to handle themselves, but the keys and values can be arbitrary strings, as long as they don't contain <code>::</code>. This allows writing reporters that can be significantly customized at runtime.</p> <p>Reporter-specific options always have to be prefixed with \"X\" (large letter X).</p>"},{"location":"reporters/#other-expected-functionality-of-a-reporter","title":"Other expected functionality of a reporter","text":"<p>When writing a custom reporter, there are few more things that you should keep in mind. These are not important for correctness, but they are important for the reporter to work nicely.</p> <ul> <li> <p>Catch2 provides a simple verbosity option for users. There are three   verbosity levels, \"quiet\", \"normal\", and \"high\", and if it makes sense   for reporter's output format, it should respond to these by changing   what, and how much, it writes out.</p> </li> <li> <p>Catch2 operates with an rng-seed. Knowing what seed a test run had   is important if you want to replicate it, so your reporter should   report the rng-seed, if at all possible given the target output format.</p> </li> <li> <p>Catch2 also operates with test filters, or test specs. If a filter   is present, you should also report the filter, if at all possible given   the target output format.</p> </li> </ul>"},{"location":"skipping-passing-failing/","title":"Skipping passing failing","text":""},{"location":"skipping-passing-failing/#explicitly-skipping-passing-and-failing-tests-at-runtime","title":"Explicitly skipping, passing, and failing tests at runtime","text":""},{"location":"skipping-passing-failing/#skipping-test-cases-at-runtime","title":"Skipping Test Cases at Runtime","text":"<p>Introduced in Catch2 3.3.0.</p> <p>In some situations it may not be possible to meaningfully execute a test case, for example when the system under test is missing certain hardware capabilities. If the required conditions can only be determined at runtime, it often doesn't make sense to consider such a test case as either passed or failed, because it simply can not run at all.</p> <p>To properly express such scenarios, Catch2 provides a way to explicitly skip test cases, using the <code>SKIP</code> macro:</p> <pre><code>SKIP( [streamable expression] )\n</code></pre> <p>Example usage:</p> <pre><code>TEST_CASE(\"copy files between drives\") {\nif(getNumberOfHardDrives() &lt; 2) {\nSKIP(\"at least two hard drives required\");\n}\n// ...\n}\n</code></pre> <p>This test case is then reported as skipped instead of passed or failed.</p> <p>The <code>SKIP</code> macro behaves similarly to an explicit <code>FAIL</code>, in that it is the last expression that will be executed:</p> <pre><code>TEST_CASE(\"my test\") {\nprintf(\"foo\");\nSKIP();\nprintf(\"bar\"); // not printed\n}\n</code></pre> <p>However a failed assertion before a <code>SKIP</code> still causes the entire test case to fail:</p> <pre><code>TEST_CASE(\"failing test\") {\nCHECK(1 == 2);\nSKIP();\n}\n</code></pre>"},{"location":"skipping-passing-failing/#interaction-with-sections-and-generators","title":"Interaction with Sections and Generators","text":"<p>Sections, nested sections as well as specific outputs from generators can all be individually skipped, with the rest executing as usual:</p> <pre><code>TEST_CASE(\"complex test case\") {\nint value = GENERATE(2, 4, 6);\nSECTION(\"a\") {\nSECTION(\"a1\") { CHECK(value &lt; 8); }\nSECTION(\"a2\") {\nif (value == 4) {\nSKIP();\n}\nCHECK(value % 2 == 0);\n}\n}\n}\n</code></pre> <p>This test case will report 5 passing assertions; one for each of the three values in section <code>a1</code>, and then two in section <code>a2</code>, from values 2 and 4.</p> <p>Note that as soon as one section is skipped, the entire test case will be reported as skipped (unless there is a failing assertion, in which case the test is handled as failed instead).</p> <p>Note that if all test cases in a run are skipped, Catch2 returns a non-zero exit code, same as it does if no test cases have run. This behaviour can be overridden using the --allow-running-no-tests flag.</p>"},{"location":"skipping-passing-failing/#skip-inside-generators","title":"<code>SKIP</code> inside generators","text":"<p>You can also use the <code>SKIP</code> macro inside generator's constructor to handle cases where the generator is empty, but you do not want to fail the test case.</p>"},{"location":"skipping-passing-failing/#passing-and-failing-test-cases","title":"Passing and failing test cases","text":"<p>Test cases can also be explicitly passed or failed, without the use of assertions, and with a specific message. This can be useful to handle complex preconditions/postconditions and give useful error messages when they fail.</p> <ul> <li><code>SUCCEED( [streamable expression] )</code></li> </ul> <p><code>SUCCEED</code> is morally equivalent with <code>INFO( [streamable expression] ); REQUIRE( true );</code>. Note that it does not stop further test execution, so it cannot be used to guard failing assertions from being executed.</p> <p>In practice, <code>SUCCEED</code> is usually used as a test placeholder, to avoid failing a test case due to missing assertions.</p> <pre><code>TEST_CASE( \"SUCCEED showcase\" ) {\nint I = 1;\nSUCCEED( \"I is \" &lt;&lt; I );\n// ... execution continues here ...\n}\n</code></pre> <ul> <li><code>FAIL( [streamable expression] )</code></li> </ul> <p><code>FAIL</code> is morally equivalent with <code>INFO( [streamable expression] ); REQUIRE( false );</code>.</p> <p>In practice, <code>FAIL</code> is usually used to stop executing test that is currently known to be broken, but has to be fixed later.</p> <pre><code>TEST_CASE( \"FAIL showcase\" ) {\nFAIL( \"This test case causes segfault, which breaks CI.\" );\n// ... this will not be executed ...\n}\n</code></pre>"},{"location":"test-cases-and-sections/","title":"Test cases and sections","text":""},{"location":"test-cases-and-sections/#test-cases-and-sections","title":"Test cases and sections","text":"<p>Contents Tags Tag aliases BDD-style test cases Type parametrised test cases Signature based parametrised test cases</p> <p>While Catch fully supports the traditional, xUnit, style of class-based fixtures containing test case methods this is not the preferred style.</p> <p>Instead Catch provides a powerful mechanism for nesting test case sections within a test case. For a more detailed discussion see the tutorial.</p> <p>Test cases and sections are very easy to use in practice:</p> <ul> <li>TEST_CASE( test name [, tags ] )</li> <li>SECTION( section name, [, section description ] )</li> </ul> <p>test name and section name are free form, quoted, strings. The optional tags argument is a quoted string containing one or more tags enclosed in square brackets, and are discussed below. section description can be used to provide long form description of a section while keeping the section name short for use with the <code>-c</code> command line parameter.</p> <p>The combination of test names and tags must be unique within the Catch2 executable.</p> <p>For examples see the Tutorial</p>"},{"location":"test-cases-and-sections/#tags","title":"Tags","text":"<p>Tags allow an arbitrary number of additional strings to be associated with a test case. Test cases can be selected (for running, or just for listing) by tag - or even by an expression that combines several tags. At their most basic level they provide a simple way to group several related tests together.</p> <p>As an example - given the following test cases:</p> <pre><code>TEST_CASE( \"A\", \"[widget]\" ) { /* ... */ }\nTEST_CASE( \"B\", \"[widget]\" ) { /* ... */ }\nTEST_CASE( \"C\", \"[gadget]\" ) { /* ... */ }\nTEST_CASE( \"D\", \"[widget][gadget]\" ) { /* ... */ }\n</code></pre> <p>The tag expression, <code>\"[widget]\"</code> selects A, B &amp; D. <code>\"[gadget]\"</code> selects C &amp; D. <code>\"[widget][gadget]\"</code> selects just D and <code>\"[widget],[gadget]\"</code> selects all four test cases.</p> <p>For more detail on command line selection see the command line docs</p> <p>Tag names are not case sensitive and can contain any ASCII characters. This means that tags <code>[tag with spaces]</code> and <code>[I said \"good day\"]</code> are both allowed tags and can be filtered on. However, escapes are not supported however and <code>[\\]]</code> is not a valid tag.</p> <p>The same tag can be specified multiple times for a single test case, but only one of the instances of identical tags will be kept. Which one is kept is functionally random.</p>"},{"location":"test-cases-and-sections/#special-tags","title":"Special Tags","text":"<p>All tag names beginning with non-alphanumeric characters are reserved by Catch. Catch defines a number of \"special\" tags, which have meaning to the test runner itself. These special tags all begin with a symbol character. Following is a list of currently defined special tags and their meanings.</p> <ul> <li> <p><code>[.]</code> - causes test cases to be skipped from the default list (i.e. when no test cases have been explicitly selected through tag expressions or name wildcards). The hide tag is often combined with another, user, tag (for example <code>[.][integration]</code> - so all integration tests are excluded from the default run but can be run by passing <code>[integration]</code> on the command line). As a short-cut you can combine these by simply prefixing your user tag with a <code>.</code> - e.g. <code>[.integration]</code>.</p> </li> <li> <p><code>[!throws]</code> - lets Catch know that this test is likely to throw an exception even if successful. This causes the test to be excluded when running with <code>-e</code> or <code>--nothrow</code>.</p> </li> <li> <p><code>[!mayfail]</code> - doesn't fail the test if any given assertion fails (but still reports it). This can be useful to flag a work-in-progress, or a known issue that you don't want to immediately fix but still want to track in your tests.</p> </li> <li> <p><code>[!shouldfail]</code> - like <code>[!mayfail]</code> but fails the test if it passes. This can be useful if you want to be notified of accidental, or third-party, fixes.</p> </li> <li> <p><code>[!nonportable]</code> - Indicates that behaviour may vary between platforms or compilers.</p> </li> <li> <p><code>[#&lt;filename&gt;]</code> - these tags are added to test cases when you run Catch2                     with <code>-#</code> or <code>--filenames-as-tags</code>.</p> </li> <li> <p><code>[@&lt;alias&gt;]</code> - tag aliases all begin with <code>@</code> (see below).</p> </li> <li> <p><code>[!benchmark]</code> - this test case is actually a benchmark. Currently this only serves to hide the test case by default, to avoid the execution time costs.</p> </li> </ul>"},{"location":"test-cases-and-sections/#tag-aliases","title":"Tag aliases","text":"<p>Between tag expressions and wildcarded test names (as well as combinations of the two) quite complex patterns can be constructed to direct which test cases are run. If a complex pattern is used often it is convenient to be able to create an alias for the expression. This can be done, in code, using the following form:</p> <pre><code>CATCH_REGISTER_TAG_ALIAS( &lt;alias string&gt;, &lt;tag expression&gt; )\n</code></pre> <p>Aliases must begin with the <code>@</code> character. An example of a tag alias is:</p> <pre><code>CATCH_REGISTER_TAG_ALIAS( \"[@nhf]\", \"[failing]~[.]\" )\n</code></pre> <p>Now when <code>[@nhf]</code> is used on the command line this matches all tests that are tagged <code>[failing]</code>, but which are not also hidden.</p>"},{"location":"test-cases-and-sections/#bdd-style-test-cases","title":"BDD-style test cases","text":"<p>In addition to Catch's take on the classic style of test cases, Catch supports an alternative syntax that allow tests to be written as \"executable specifications\" (one of the early goals of Behaviour Driven Development). This set of macros map on to <code>TEST_CASE</code>s and <code>SECTION</code>s, with a little internal support to make them smoother to work with.</p> <ul> <li>SCENARIO( scenario name [, tags ] )</li> </ul> <p>This macro maps onto <code>TEST_CASE</code> and works in the same way, except that the test case name will be prefixed by \"Scenario: \"</p> <ul> <li>GIVEN( something )</li> <li>WHEN( something )</li> <li>THEN( something )</li> </ul> <p>These macros map onto <code>SECTION</code>s except that the section names are the something texts prefixed by \"given: \", \"when: \" or \"then: \" respectively. These macros also map onto the AAA or A3 test pattern (standing either for Assemble-Activate-Assert or Arrange-Act-Assert), and in this context, the macros provide both code documentation and reporting of these parts of a test case without the need for extra comments or code to do so.</p> <p>Semantically, a <code>GIVEN</code> clause may have multiple independent <code>WHEN</code> clauses within it. This allows a test to have, e.g., one set of \"given\" objects and multiple subtests using those objects in various ways in each of the <code>WHEN</code> clauses without repeating the initialisation from the <code>GIVEN</code> clause. When there are dependent clauses -- such as a second <code>WHEN</code> clause that should only happen after the previous <code>WHEN</code> clause has been executed and validated -- there are additional macros starting with <code>AND_</code>:</p> <ul> <li>AND_GIVEN( something )</li> <li>AND_WHEN( something )</li> <li>AND_THEN( something )</li> </ul> <p>These are used to chain <code>GIVEN</code>s, <code>WHEN</code>s and <code>THEN</code>s together. The <code>AND_*</code> clause is placed inside the clause on which it depends. There can be multiple independent clauses that are all dependent on a single outer clause. <pre><code>SCENARIO( \"vector can be sized and resized\" ) {\nGIVEN( \"An empty vector\" ) {\nauto v = std::vector&lt;std::string&gt;{};\n// Validate assumption of the GIVEN clause\nTHEN( \"The size and capacity start at 0\" ) {\nREQUIRE( v.size() == 0 );\nREQUIRE( v.capacity() == 0 );\n}\n// Validate one use case for the GIVEN object\nWHEN( \"push_back() is called\" ) {\nv.push_back(\"hullo\");\nTHEN( \"The size changes\" ) {\nREQUIRE( v.size() == 1 );\nREQUIRE( v.capacity() &gt;= 1 );\n}\n}\n}\n}\n</code></pre></p> <p>This code will result in two runs through the scenario: <pre><code>Scenario : vector can be sized and resized\n  Given  : An empty vector\n  Then   : The size and capacity start at 0\n\nScenario : vector can be sized and resized\n  Given  : An empty vector\n  When   : push_back() is called\n  Then   : The size changes\n</code></pre></p> <p>See also runnable example on godbolt, with a more complicated (and failing) example.</p> <p><code>AND_GIVEN</code> was introduced in Catch2 2.4.0.</p> <p>When any of these macros are used the console reporter recognises them and formats the test case header such that the Givens, Whens and Thens are aligned to aid readability.</p> <p>Other than the additional prefixes and the formatting in the console reporter these macros behave exactly as <code>TEST_CASE</code>s and <code>SECTION</code>s. As such there is nothing enforcing the correct sequencing of these macros - that's up to the programmer!</p>"},{"location":"test-cases-and-sections/#type-parametrised-test-cases","title":"Type parametrised test cases","text":"<p>In addition to <code>TEST_CASE</code>s, Catch2 also supports test cases parametrised by types, in the form of <code>TEMPLATE_TEST_CASE</code>, <code>TEMPLATE_PRODUCT_TEST_CASE</code> and <code>TEMPLATE_LIST_TEST_CASE</code>. These macros are defined in the <code>catch_template_test_macros.hpp</code> header, so compiling the code examples below also requires <code>#include &lt;catch2/catch_template_test_macros.hpp&gt;</code>.</p> <ul> <li>TEMPLATE_TEST_CASE( test name , tags,  type1, type2, ..., typen )</li> </ul> <p>Introduced in Catch2 2.5.0.</p> <p>test name and tag are exactly the same as they are in <code>TEST_CASE</code>, with the difference that the tag string must be provided (however, it can be empty). type1 through typen is the list of types for which this test case should run, and, inside the test code, the current type is available as the <code>TestType</code> type.</p> <p>Because of limitations of the C++ preprocessor, if you want to specify a type with multiple template parameters, you need to enclose it in parentheses, e.g. <code>std::map&lt;int, std::string&gt;</code> needs to be passed as <code>(std::map&lt;int, std::string&gt;)</code>.</p> <p>Example: <pre><code>TEMPLATE_TEST_CASE( \"vectors can be sized and resized\", \"[vector][template]\", int, std::string, (std::tuple&lt;int,float&gt;) ) {\nstd::vector&lt;TestType&gt; v( 5 );\nREQUIRE( v.size() == 5 );\nREQUIRE( v.capacity() &gt;= 5 );\nSECTION( \"resizing bigger changes size and capacity\" ) {\nv.resize( 10 );\nREQUIRE( v.size() == 10 );\nREQUIRE( v.capacity() &gt;= 10 );\n}\nSECTION( \"resizing smaller changes size but not capacity\" ) {\nv.resize( 0 );\nREQUIRE( v.size() == 0 );\nREQUIRE( v.capacity() &gt;= 5 );\nSECTION( \"We can use the 'swap trick' to reset the capacity\" ) {\nstd::vector&lt;TestType&gt; empty;\nempty.swap( v );\nREQUIRE( v.capacity() == 0 );\n}\n}\nSECTION( \"reserving smaller does not change size or capacity\" ) {\nv.reserve( 0 );\nREQUIRE( v.size() == 5 );\nREQUIRE( v.capacity() &gt;= 5 );\n}\n}\n</code></pre></p> <ul> <li>TEMPLATE_PRODUCT_TEST_CASE( test name , tags, (template-type1, template-type2, ..., template-typen), (template-arg1, template-arg2, ..., template-argm) )</li> </ul> <p>Introduced in Catch2 2.6.0.</p> <p>template-type1 through template-typen is list of template template types which should be combined with each of template-arg1 through  template-argm, resulting in n * m test cases. Inside the test case, the resulting type is available under the name of <code>TestType</code>.</p> <p>To specify more than 1 type as a single template-type or template-arg, you must enclose the types in an additional set of parentheses, e.g. <code>((int, float), (char, double))</code> specifies 2 template-args, each consisting of 2 concrete types (<code>int</code>, <code>float</code> and <code>char</code>, <code>double</code> respectively). You can also omit the outer set of parentheses if you specify only one type as the full set of either the template-types, or the template-args.</p> <p>Example: <pre><code>template&lt; typename T&gt;\nstruct Foo {\nsize_t size() {\nreturn 0;\n}\n};\nTEMPLATE_PRODUCT_TEST_CASE(\"A Template product test case\", \"[template][product]\", (std::vector, Foo), (int, float)) {\nTestType x;\nREQUIRE(x.size() == 0);\n}\n</code></pre></p> <p>You can also have different arities in the template-arg packs: <pre><code>TEMPLATE_PRODUCT_TEST_CASE(\"Product with differing arities\", \"[template][product]\", std::tuple, (int, (int, double), (int, double, float))) {\nTestType x;\nREQUIRE(std::tuple_size&lt;TestType&gt;::value &gt;= 1);\n}\n</code></pre></p> <ul> <li>TEMPLATE_LIST_TEST_CASE( test name, tags, type list )</li> </ul> <p>Introduced in Catch2 2.9.0.</p> <p>type list is a generic list of types on which test case should be instantiated. List can be <code>std::tuple</code>, <code>boost::mpl::list</code>, <code>boost::mp11::mp_list</code> or anything with <code>template &lt;typename...&gt;</code> signature.</p> <p>This allows you to reuse the type list in multiple test cases.</p> <p>Example: <pre><code>using MyTypes = std::tuple&lt;int, char, float&gt;;\nTEMPLATE_LIST_TEST_CASE(\"Template test case with test types specified inside std::tuple\", \"[template][list]\", MyTypes)\n{\nREQUIRE(sizeof(TestType) &gt; 0);\n}\n</code></pre></p>"},{"location":"test-cases-and-sections/#signature-based-parametrised-test-cases","title":"Signature based parametrised test cases","text":"<p>Introduced in Catch2 2.8.0.</p> <p>In addition to type parametrised test cases Catch2 also supports signature base parametrised test cases, in form of <code>TEMPLATE_TEST_CASE_SIG</code> and <code>TEMPLATE_PRODUCT_TEST_CASE_SIG</code>. These test cases have similar syntax like type parametrised test cases, with one additional positional argument which specifies the signature. These macros are defined in the <code>catch_template_test_macros.hpp</code> header, so compiling the code examples below also requires <code>#include &lt;catch2/catch_template_test_macros.hpp&gt;</code>.</p>"},{"location":"test-cases-and-sections/#signature","title":"Signature","text":"<p>Signature has some strict rules for these tests cases to work properly: * signature with multiple template parameters e.g. <code>typename T, size_t S</code> must have this format in test case declaration   <code>((typename T, size_t S), T, S)</code> * signature with variadic template arguments e.g. <code>typename T, size_t S, typename...Ts</code> must have this format in test case declaration   <code>((typename T, size_t S, typename...Ts), T, S, Ts...)</code> * signature with single non type template parameter e.g. <code>int V</code> must have this format in test case declaration <code>((int V), V)</code> * signature with single type template parameter e.g. <code>typename T</code> should not be used as it is in fact <code>TEMPLATE_TEST_CASE</code></p> <p>Currently Catch2 support up to 11 template parameters in signature</p>"},{"location":"test-cases-and-sections/#examples","title":"Examples","text":"<ul> <li>TEMPLATE_TEST_CASE_SIG( test name , tags,  signature, type1, type2, ..., typen )</li> </ul> <p>Inside <code>TEMPLATE_TEST_CASE_SIG</code> test case you can use the names of template parameters as defined in signature.</p> <pre><code>TEMPLATE_TEST_CASE_SIG(\"TemplateTestSig: arrays can be created from NTTP arguments\", \"[vector][template][nttp]\",\n((typename T, int V), T, V), (int,5), (float,4), (std::string,15), ((std::tuple&lt;int, float&gt;), 6)) {\nstd::array&lt;T, V&gt; v;\nREQUIRE(v.size() &gt; 1);\n}\n</code></pre> <ul> <li>TEMPLATE_PRODUCT_TEST_CASE_SIG( test name , tags, signature, (template-type1, template-type2, ..., template-typen), (template-arg1, template-arg2, ..., template-argm) )</li> </ul> <pre><code>template&lt;typename T, size_t S&gt;\nstruct Bar {\nsize_t size() { return S; }\n};\nTEMPLATE_PRODUCT_TEST_CASE_SIG(\"A Template product test case with array signature\", \"[template][product][nttp]\", ((typename T, size_t S), T, S), (std::array, Bar), ((int, 9), (float, 42))) {\nTestType x;\nREQUIRE(x.size() &gt; 0);\n}\n</code></pre>"},{"location":"test-fixtures/","title":"Test fixtures","text":""},{"location":"test-fixtures/#test-fixtures","title":"Test fixtures","text":""},{"location":"test-fixtures/#defining-test-fixtures","title":"Defining test fixtures","text":"<p>Although Catch allows you to group tests together as sections within a test case, it can still be convenient, sometimes, to group them using a more traditional test fixture. Catch fully supports this too. You define the test fixture as a simple structure:</p> <pre><code>class UniqueTestsFixture {\nprivate:\nstatic int uniqueID;\nprotected:\nDBConnection conn;\npublic:\nUniqueTestsFixture() : conn(DBConnection::createConnection(\"myDB\")) {\n}\nprotected:\nint getID() {\nreturn ++uniqueID;\n}\n};\nint UniqueTestsFixture::uniqueID = 0;\nTEST_CASE_METHOD(UniqueTestsFixture, \"Create Employee/No Name\", \"[create]\") {\nREQUIRE_THROWS(conn.executeSQL(\"INSERT INTO employee (id, name) VALUES (?, ?)\", getID(), \"\"));\n}\nTEST_CASE_METHOD(UniqueTestsFixture, \"Create Employee/Normal\", \"[create]\") {\nREQUIRE(conn.executeSQL(\"INSERT INTO employee (id, name) VALUES (?, ?)\", getID(), \"Joe Bloggs\"));\n}\n</code></pre> <p>The two test cases here will create uniquely-named derived classes of UniqueTestsFixture and thus can access the <code>getID()</code> protected method and <code>conn</code> member variables. This ensures that both the test cases are able to create a DBConnection using the same method (DRY principle) and that any ID's created are unique such that the order that tests are executed does not matter.</p> <p>Catch2 also provides <code>TEMPLATE_TEST_CASE_METHOD</code> and <code>TEMPLATE_PRODUCT_TEST_CASE_METHOD</code> that can be used together with templated fixtures and templated template fixtures to perform tests for multiple different types. Unlike <code>TEST_CASE_METHOD</code>, <code>TEMPLATE_TEST_CASE_METHOD</code> and <code>TEMPLATE_PRODUCT_TEST_CASE_METHOD</code> do require the tag specification to be non-empty, as it is followed by further macro arguments.</p> <p>Also note that, because of limitations of the C++ preprocessor, if you want to specify a type with multiple template parameters, you need to enclose it in parentheses, e.g. <code>std::map&lt;int, std::string&gt;</code> needs to be passed as <code>(std::map&lt;int, std::string&gt;)</code>. In the case of <code>TEMPLATE_PRODUCT_TEST_CASE_METHOD</code>, if a member of the type list should consist of more than single type, it needs to be enclosed in another pair of parentheses, e.g. <code>(std::map, std::pair)</code> and <code>((int, float), (char, double))</code>.</p> <p>Example: <pre><code>template&lt; typename T &gt;\nstruct Template_Fixture {\nTemplate_Fixture(): m_a(1) {}\nT m_a;\n};\nTEMPLATE_TEST_CASE_METHOD(Template_Fixture,\n\"A TEMPLATE_TEST_CASE_METHOD based test run that succeeds\",\n\"[class][template]\",\nint, float, double) {\nREQUIRE( Template_Fixture&lt;TestType&gt;::m_a == 1 );\n}\ntemplate&lt;typename T&gt;\nstruct Template_Template_Fixture {\nTemplate_Template_Fixture() {}\nT m_a;\n};\ntemplate&lt;typename T&gt;\nstruct Foo_class {\nsize_t size() {\nreturn 0;\n}\n};\nTEMPLATE_PRODUCT_TEST_CASE_METHOD(Template_Template_Fixture,\n\"A TEMPLATE_PRODUCT_TEST_CASE_METHOD based test succeeds\",\n\"[class][template]\",\n(Foo_class, std::vector),\nint) {\nREQUIRE( Template_Template_Fixture&lt;TestType&gt;::m_a.size() == 0 );\n}\n</code></pre></p> <p>While there is an upper limit on the number of types you can specify in single <code>TEMPLATE_TEST_CASE_METHOD</code> or <code>TEMPLATE_PRODUCT_TEST_CASE_METHOD</code>, the limit is very high and should not be encountered in practice.</p>"},{"location":"test-fixtures/#signature-based-parametrised-test-fixtures","title":"Signature-based parametrised test fixtures","text":"<p>Introduced in Catch2 2.8.0.</p> <p>Catch2 also provides <code>TEMPLATE_TEST_CASE_METHOD_SIG</code> and <code>TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG</code> to support fixtures using non-type template parameters. These test cases work similar to <code>TEMPLATE_TEST_CASE_METHOD</code> and <code>TEMPLATE_PRODUCT_TEST_CASE_METHOD</code>, with additional positional argument for signature.</p> <p>Example: <pre><code>template &lt;int V&gt;\nstruct Nttp_Fixture{\nint value = V;\n};\nTEMPLATE_TEST_CASE_METHOD_SIG(\nNttp_Fixture,\n\"A TEMPLATE_TEST_CASE_METHOD_SIG based test run that succeeds\",\n\"[class][template][nttp]\",\n((int V), V),\n1, 3, 6) {\nREQUIRE(Nttp_Fixture&lt;V&gt;::value &gt; 0);\n}\ntemplate&lt;typename T&gt;\nstruct Template_Fixture_2 {\nTemplate_Fixture_2() {}\nT m_a;\n};\ntemplate&lt; typename T, size_t V&gt;\nstruct Template_Foo_2 {\nsize_t size() { return V; }\n};\nTEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG(\nTemplate_Fixture_2,\n\"A TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG based test run that succeeds\",\n\"[class][template][product][nttp]\",\n((typename T, size_t S), T, S),\n(std::array, Template_Foo_2),\n((int,2), (float,6))) {\nREQUIRE(Template_Fixture_2&lt;TestType&gt;{}.m_a.size() &gt;= 2);\n}\n</code></pre></p>"},{"location":"test-fixtures/#template-fixtures-with-types-specified-in-template-type-lists","title":"Template fixtures with types specified in template type lists","text":"<p>Catch2 also provides <code>TEMPLATE_LIST_TEST_CASE_METHOD</code> to support template fixtures with types specified in template type lists like <code>std::tuple</code>, <code>boost::mpl::list</code> or <code>boost::mp11::mp_list</code>. This test case works the same as <code>TEMPLATE_TEST_CASE_METHOD</code>, only difference is the source of types. This allows you to reuse the template type list in multiple test cases.</p> <p>Example: <pre><code>using MyTypes = std::tuple&lt;int, char, double&gt;;\nTEMPLATE_LIST_TEST_CASE_METHOD(Template_Fixture,\n\"Template test case method with test types specified inside std::tuple\",\n\"[class][template][list]\",\nMyTypes) {\nREQUIRE( Template_Fixture&lt;TestType&gt;::m_a == 1 );\n}\n</code></pre></p>"},{"location":"tostring/","title":"Tostring","text":""},{"location":"tostring/#string-conversions","title":"String conversions","text":"<p>Contents operator &lt;&lt; overload for std::ostream Catch::StringMaker specialisation Catch::is_range specialisation Exceptions Enums Floating point precision</p> <p>Catch needs to be able to convert types you use in assertions and logging expressions into strings (for logging and reporting purposes). Most built-in or std types are supported out of the box but there are two ways that you can tell Catch how to convert your own types (or other, third-party types) into strings.</p>"},{"location":"tostring/#operator-overload-for-stdostream","title":"operator &lt;&lt; overload for std::ostream","text":"<p>This is the standard way of providing string conversions in C++ - and the chances are you may already provide this for your own purposes. If you're not familiar with this idiom it involves writing a free function of the form:</p> <pre><code>std::ostream&amp; operator &lt;&lt; ( std::ostream&amp; os, T const&amp; value ) {\nos &lt;&lt; convertMyTypeToString( value );\nreturn os;\n}\n</code></pre> <p>(where <code>T</code> is your type and <code>convertMyTypeToString</code> is where you'll write whatever code is necessary to make your type printable - it doesn't have to be in another function).</p> <p>You should put this function in the same namespace as your type, or the global namespace, and have it declared before including Catch's header.</p>"},{"location":"tostring/#catchstringmaker-specialisation","title":"Catch::StringMaker specialisation","text":"<p>If you don't want to provide an <code>operator &lt;&lt;</code> overload, or you want to convert your type differently for testing purposes, you can provide a specialization for <code>Catch::StringMaker&lt;T&gt;</code>:</p> <pre><code>namespace Catch {\ntemplate&lt;&gt;\nstruct StringMaker&lt;T&gt; {\nstatic std::string convert( T const&amp; value ) {\nreturn convertMyTypeToString( value );\n}\n};\n}\n</code></pre>"},{"location":"tostring/#catchis_range-specialisation","title":"Catch::is_range specialisation","text":"<p>As a fallback, Catch attempts to detect if the type can be iterated (<code>begin(T)</code> and <code>end(T)</code> are valid) and if it can be, it is stringified as a range. For certain types this can lead to infinite recursion, so it can be disabled by specializing <code>Catch::is_range</code> like so:</p> <pre><code>namespace Catch {\ntemplate&lt;&gt;\nstruct is_range&lt;T&gt; {\nstatic const bool value = false;\n};\n}\n</code></pre>"},{"location":"tostring/#exceptions","title":"Exceptions","text":"<p>By default all exceptions deriving from <code>std::exception</code> will be translated to strings by calling the <code>what()</code> method. For exception types that do not derive from <code>std::exception</code> - or if <code>what()</code> does not return a suitable string - use <code>CATCH_TRANSLATE_EXCEPTION</code>. This defines a function that takes your exception type, by reference, and returns a string. It can appear anywhere in the code - it doesn't have to be in the same translation unit. For example:</p> <pre><code>CATCH_TRANSLATE_EXCEPTION( MyType const&amp; ex ) {\nreturn ex.message();\n}\n</code></pre>"},{"location":"tostring/#enums","title":"Enums","text":"<p>Introduced in Catch2 2.8.0.</p> <p>Enums that already have a <code>&lt;&lt;</code> overload for <code>std::ostream</code> will convert to strings as expected. If you only need to convert enums to strings for test reporting purposes you can provide a <code>StringMaker</code> specialisations as any other type. However, as a convenience, Catch provides the <code>REGISTER_ENUM</code> helper macro that will generate the <code>StringMaker</code> specialiation for you with minimal code. Simply provide it the (qualified) enum name, followed by all the enum values, and you're done!</p> <p>E.g.</p> <pre><code>enum class Fruits { Banana, Apple, Mango };\nCATCH_REGISTER_ENUM( Fruits, Fruits::Banana, Fruits::Apple, Fruits::Mango )\nTEST_CASE() {\nREQUIRE( Fruits::Mango == Fruits::Apple );\n}\n</code></pre> <p>... or if the enum is in a namespace: <pre><code>namespace Bikeshed {\nenum class Colours { Red, Green, Blue };\n}\n// Important!: This macro must appear at top level scope - not inside a namespace\n// You can fully qualify the names, or use a using if you prefer\nCATCH_REGISTER_ENUM( Bikeshed::Colours,\nBikeshed::Colours::Red,\nBikeshed::Colours::Green,\nBikeshed::Colours::Blue )\nTEST_CASE() {\nREQUIRE( Bikeshed::Colours::Red == Bikeshed::Colours::Blue );\n}\n</code></pre></p>"},{"location":"tostring/#floating-point-precision","title":"Floating point precision","text":"<p>Introduced in Catch2 2.8.0.</p> <p>Catch provides a built-in <code>StringMaker</code> specialization for both <code>float</code> and <code>double</code>. By default, it uses what we think is a reasonable precision, but you can customize it by modifying the <code>precision</code> static variable inside the <code>StringMaker</code> specialization, like so:</p> <pre><code>        Catch::StringMaker&lt;float&gt;::precision = 15;\nconst float testFloat1 = 1.12345678901234567899f;\nconst float testFloat2 = 1.12345678991234567899f;\nREQUIRE(testFloat1 == testFloat2);\n</code></pre> <p>This assertion will fail and print out the <code>testFloat1</code> and <code>testFloat2</code> to 15 decimal places.</p>"},{"location":"tutorial/","title":"Tutorial","text":""},{"location":"tutorial/#tutorial","title":"Tutorial","text":"<p>Contents Getting Catch2 Writing tests Test cases and sections BDD style testing Data and Type driven tests Next steps</p>"},{"location":"tutorial/#getting-catch2","title":"Getting Catch2","text":"<p>Ideally you should be using Catch2 through its CMake integration. Catch2 also provides pkg-config files and two file (header + cpp) distribution, but this documentation will assume you are using CMake. If you are using the two file distribution instead, remember to replace the included header with <code>catch_amalgamated.hpp</code>.</p>"},{"location":"tutorial/#writing-tests","title":"Writing tests","text":"<p>Let's start with a really simple example (code). Say you have written a function to calculate factorials and now you want to test it (let's leave aside TDD for now).</p> <pre><code>unsigned int Factorial( unsigned int number ) {\nreturn number &lt;= 1 ? number : Factorial(number-1)*number;\n}\n</code></pre> <pre><code>#include &lt;catch2/catch_test_macros.hpp&gt;\nunsigned int Factorial( unsigned int number ) {\nreturn number &lt;= 1 ? number : Factorial(number-1)*number;\n}\nTEST_CASE( \"Factorials are computed\", \"[factorial]\" ) {\nREQUIRE( Factorial(1) == 1 );\nREQUIRE( Factorial(2) == 2 );\nREQUIRE( Factorial(3) == 6 );\nREQUIRE( Factorial(10) == 3628800 );\n}\n</code></pre> <p>This will compile to a complete executable which responds to command line arguments. If you just run it with no arguments it will execute all test cases (in this case there is just one), report any failures, report a summary of how many tests passed and failed and return the number of failed tests (useful for if you just want a yes/ no answer to: \"did it work\").</p> <p>Anyway, as the tests above as written will pass, but there is a bug. The problem is that <code>Factorial(0)</code> should return 1 (due to its definition). Let's add that as an assertion to the test case:</p> <pre><code>TEST_CASE( \"Factorials are computed\", \"[factorial]\" ) {\nREQUIRE( Factorial(0) == 1 );\nREQUIRE( Factorial(1) == 1 );\nREQUIRE( Factorial(2) == 2 );\nREQUIRE( Factorial(3) == 6 );\nREQUIRE( Factorial(10) == 3628800 );\n}\n</code></pre> <p>After another compile &amp; run cycle, we will see a test failure. The output will look something like:</p> <pre><code>Example.cpp:9: FAILED:\n  REQUIRE( Factorial(0) == 1 )\nwith expansion:\n  0 == 1\n</code></pre> <p>Note that the output contains both the original expression, <code>REQUIRE( Factorial(0) == 1 )</code> and the actual value returned by the call to the <code>Factorial</code> function: <code>0</code>.</p> <p>We can fix this bug by slightly modifying the <code>Factorial</code> function to: <pre><code>unsigned int Factorial( unsigned int number ) {\nreturn number &gt; 1 ? Factorial(number-1)*number : 1;\n}\n</code></pre></p>"},{"location":"tutorial/#what-did-we-do-here","title":"What did we do here?","text":"<p>Although this was a simple test it's been enough to demonstrate a few things about how Catch2 is used. Let's take a moment to consider those before we move on.</p> <ul> <li>We introduce test cases with the <code>TEST_CASE</code> macro. This macro takes   one or two string arguments - a free form test name and, optionally,   one or more tags (for more see Test cases and Sections).</li> <li>The test automatically self-registers with the test runner, and user   does not have do anything more to ensure that it is picked up by the test   framework. Note that you can run specific test, or set of tests,   through the command line.</li> <li>The individual test assertions are written using the <code>REQUIRE</code> macro.   It accepts a boolean expression, and uses expression templates to   internally decompose it, so that it can be individually stringified   on test failure.</li> </ul> <p>On the last point, note that there are more testing macros available, because not all useful checks can be expressed as a simple boolean expression. As an example, checking that an expression throws an exception is done with the <code>REQUIRE_THROWS</code> macro. More on that later.</p>"},{"location":"tutorial/#test-cases-and-sections","title":"Test cases and sections","text":"<p>Like most test frameworks, Catch2 supports a class-based fixture mechanism, where individual tests are methods on class and setup/teardown can be done in constructor/destructor of the type.</p> <p>However, their use in Catch2 is rare, because idiomatic Catch2 tests instead use sections to share setup and teardown code between test code. This is best explained through an example (code):</p> <pre><code>TEST_CASE( \"vectors can be sized and resized\", \"[vector]\" ) {\nstd::vector&lt;int&gt; v( 5 );\nREQUIRE( v.size() == 5 );\nREQUIRE( v.capacity() &gt;= 5 );\nSECTION( \"resizing bigger changes size and capacity\" ) {\nv.resize( 10 );\nREQUIRE( v.size() == 10 );\nREQUIRE( v.capacity() &gt;= 10 );\n}\nSECTION( \"resizing smaller changes size but not capacity\" ) {\nv.resize( 0 );\nREQUIRE( v.size() == 0 );\nREQUIRE( v.capacity() &gt;= 5 );\n}\nSECTION( \"reserving bigger changes capacity but not size\" ) {\nv.reserve( 10 );\nREQUIRE( v.size() == 5 );\nREQUIRE( v.capacity() &gt;= 10 );\n}\nSECTION( \"reserving smaller does not change size or capacity\" ) {\nv.reserve( 0 );\nREQUIRE( v.size() == 5 );\nREQUIRE( v.capacity() &gt;= 5 );\n}\n}\n</code></pre> <p>For each <code>SECTION</code> the <code>TEST_CASE</code> is executed from the start. This means that each section is entered with a freshly constructed vector <code>v</code>, that we know has size 5 and capacity at least 5, because the two assertions are also checked before the section is entered. Each run through a test case will execute one, and only one, leaf section.</p> <p>Section can also be nested, in which case the parent section can be entered multiple times, once for each leaf section. Nested sections are most useful when you have multiple tests that share part of the set up. To continue on the vector example above, you could add a check that <code>std::vector::reserve</code> does not remove unused excess capacity, like this:</p> <pre><code>    SECTION( \"reserving bigger changes capacity but not size\" ) {\nv.reserve( 10 );\nREQUIRE( v.size() == 5 );\nREQUIRE( v.capacity() &gt;= 10 );\nSECTION( \"reserving down unused capacity does not change capacity\" ) {\nv.reserve( 7 );\nREQUIRE( v.size() == 5 );\nREQUIRE( v.capacity() &gt;= 10 );\n}\n}\n</code></pre> <p>Another way to look at sections is that they are a way to define a tree of paths through the test. Each section represents a node, and the final tree is walked in depth-first manner, with each path only visiting only one leaf node.</p> <p>There is no practical limit on nesting sections, as long as your compiler can handle them, but keep in mind that overly nested sections can become unreadable. From experience, having section nest more than 3 levels is usually very hard to follow and not worth the removed duplication.</p>"},{"location":"tutorial/#bdd-style-testing","title":"BDD style testing","text":"<p>Catch2 also provides some basic support for BDD-style testing. There are macro aliases for <code>TEST_CASE</code> and <code>SECTIONS</code> that you can use so that the resulting tests read as BDD spec. <code>SCENARIO</code> acts as a <code>TEST_CASE</code> with \"Scenario: \" name prefix. Then there are <code>GIVEN</code>, <code>WHEN</code>, <code>THEN</code> (and their variants with <code>AND_</code> prefix), which act as a <code>SECTION</code>, similarly prefixed with the macro name.</p> <p>For more details on the macros look at the test cases and sections part of the reference docs, or at the vector example done with BDD macros.</p>"},{"location":"tutorial/#data-and-type-driven-tests","title":"Data and Type driven tests","text":"<p>Test cases in Catch2 can also be driven by types, input data, or both at the same time.</p> <p>For more details look into the Catch2 reference, either at the type parametrized test cases, or data generators.</p>"},{"location":"tutorial/#next-steps","title":"Next steps","text":"<p>This page is a brief introduction to get you up and running with Catch2, and to show the basic features of Catch2. The features mentioned here can get you quite far, but there are many more. However, you can read about these as you go, in the ever-growing reference section of the documentation.</p>"},{"location":"usage-tips/","title":"Usage tips","text":""},{"location":"usage-tips/#best-practices-and-other-tips-on-using-catch2","title":"Best practices and other tips on using Catch2","text":""},{"location":"usage-tips/#running-tests","title":"Running tests","text":"<p>Your tests should be run in a manner roughly equivalent with:</p> <pre><code>./tests --order rand --warn NoAssertions\n</code></pre> <p>Notice that all the tests are run in a large batch, their relative order is randomized, and that you ask Catch2 to fail test whose leaf-path does not contain an assertion.</p> <p>The reason I recommend running all your tests in the same process is that this exposes your tests to interference from their runs. This can be both positive interference, where the changes in global state from previous test allow later tests to pass, but also negative interference, where changes in global state from previous test causes later tests to fail.</p> <p>In my experience, interference, especially destructive interference, usually comes from errors in the code under test, rather than the tests themselves. This means that by allowing interference to happen, our tests can find these issues. Obviously, to shake out interference coming from different orderings of tests, the test order also need to be shuffled between runs.</p> <p>However, running all tests in a single batch eventually becomes impractical as they will take too long to run, and you will want to run your tests in parallel.</p> <p></p>"},{"location":"usage-tips/#running-tests-in-parallel","title":"Running tests in parallel","text":"<p>There are multiple ways of running tests in parallel, with various level of structure. If you are using CMake and CTest, then we provide a helper function <code>catch_discover_tests</code> that registers each Catch2 <code>TEST_CASE</code> as a single CTest test, which is then run in a separate process. This is an easy way to set up parallel tests if you are already using CMake &amp; CTest to run your tests, but you will lose the advantage of running tests in batches.</p> <p>Catch2 also supports splitting tests in a binary into multiple shards. This can be used by any test runner to run batches of tests in parallel. Do note that when selecting on the number of shards, you should have more shards than there are cores, to avoid issues with long-running tests getting accidentally grouped in the same shard, and causing long-tailed execution time.</p> <p>Note that naively composing sharding and random ordering of tests will break.</p> <p>Invoking Catch2 test executable like this</p> <pre><code>./tests --order rand --shard-index 0 --shard-count 3\n./tests --order rand --shard-index 1 --shard-count 3\n./tests --order rand --shard-index 2 --shard-count 3\n</code></pre> <p>does not guarantee covering all tests inside the executable, because each invocation will have its own random seed, thus it will have its own random order of tests and thus the partitioning of tests into shards will be different as well.</p> <p>To do this properly, you need the individual shards to share the random seed, e.g. <pre><code>./tests --order rand --shard-index 0 --shard-count 3 --rng-seed 0xBEEF\n./tests --order rand --shard-index 1 --shard-count 3 --rng-seed 0xBEEF\n./tests --order rand --shard-index 2 --shard-count 3 --rng-seed 0xBEEF\n</code></pre></p> <p>Catch2 actually provides a helper to automatically register multiple shards as CTest tests, with shared random seed that changes each CTest invocation. For details look at the documentation of <code>CatchShardTests.cmake</code> CMake script.</p>"},{"location":"usage-tips/#organizing-tests-into-binaries","title":"Organizing tests into binaries","text":"<p>Both overly large and overly small test binaries can cause issues. Overly large test binaries have to be recompiled and relinked often, and the link times are usually also long. Overly small test binaries in turn pay significant overhead from linking against Catch2 more often per compiled test case, and also make it hard/impossible to run tests in batches.</p> <p>Because there is no hard and fast rule for the right size of a test binary, I recommend having 1:1 correspondence between libraries in project and test binaries. (At least if it is possible, in some cases it is not.) Having a test binary for each library in project keeps related tests together, and makes tests easy to navigate by reflecting the project's organizational structure.</p>"},{"location":"why-catch/","title":"Why catch","text":""},{"location":"why-catch/#why-do-we-need-yet-another-c-test-framework","title":"Why do we need yet another C++ test framework?","text":"<p>Good question. For C++ there are quite a number of established frameworks, including (but not limited to), Google Test, Boost.Test, CppUnit, Cute, and many, many more.</p> <p>So what does Catch2 bring to the party that differentiates it from these? Apart from the catchy name, of course.</p>"},{"location":"why-catch/#key-features","title":"Key Features","text":"<ul> <li>Quick and easy to get started. Just download two files, add them into your project and you're away.</li> <li>No external dependencies. As long as you can compile C++14 and have the C++ standard library available.</li> <li>Write test cases as, self-registering, functions (or methods, if you prefer).</li> <li>Divide test cases into sections, each of which is run in isolation (eliminates the need for fixtures).</li> <li>Use BDD-style Given-When-Then sections as well as traditional unit test cases.</li> <li>Only one core assertion macro for comparisons. Standard C/C++ operators are used for the comparison - yet the full expression is decomposed and lhs and rhs values are logged.</li> <li>Tests are named using free-form strings - no more couching names in legal identifiers.</li> </ul>"},{"location":"why-catch/#other-core-features","title":"Other core features","text":"<ul> <li>Tests can be tagged for easily running ad-hoc groups of tests.</li> <li>Failures can (optionally) break into the debugger on common platforms.</li> <li>Output is through modular reporter objects. Basic textual and XML reporters are included. Custom reporters can easily be added.</li> <li>JUnit xml output is supported for integration with third-party tools, such as CI servers.</li> <li>A default main() function is provided, but you can supply your own for complete control (e.g. integration into your own test runner GUI).</li> <li>A command line parser is provided and can still be used if you choose to provided your own main() function.</li> <li>Alternative assertion macro(s) report failures but don't abort the test case</li> <li>Good set of facilities for floating point comparisons (<code>Catch::Approx</code> and full set of matchers)</li> <li>Internal and friendly macros are isolated so name clashes can be managed</li> <li>Data generators (data driven test support)</li> <li>Hamcrest-style Matchers for testing complex properties</li> <li>Microbenchmarking support</li> </ul>"},{"location":"why-catch/#who-else-is-using-catch2","title":"Who else is using Catch2?","text":"<p>A whole lot of people. According to the 2021 JetBrains C++ ecosystem survey, about 11% of C++ programmers use Catch2 for unit testing, making it the second most popular unit testing framework.</p> <p>You can also take a look at the (incomplete) list of open source projects or the (very incomplete) list of commercial users of Catch2 for some idea on who else also uses Catch2.</p> <p>See the tutorial to get more of a taste of using Catch2 in practice.</p>"}]}